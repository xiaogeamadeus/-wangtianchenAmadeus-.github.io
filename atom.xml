<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WANG Tianchen</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-22T14:21:57.437Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Formal Language Theory</title>
    <link href="http://example.com/2022/04/22/Formal-Language-Theory/"/>
    <id>http://example.com/2022/04/22/Formal-Language-Theory/</id>
    <published>2022-04-22T13:08:38.000Z</published>
    <updated>2022-04-22T14:21:57.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Formal-Language-Theory-形式语言理论"><a href="#Formal-Language-Theory-形式语言理论" class="headerlink" title="Formal Language Theory 形式语言理论"></a>Formal Language Theory 形式语言理论</h1><h3 id="什么是形式语言？-x2F-语言的形式定义"><a href="#什么是形式语言？-x2F-语言的形式定义" class="headerlink" title="什么是形式语言？/ 语言的形式定义"></a>什么是形式语言？/ 语言的形式定义</h3><p> 形式语言（Formal Language）是用精确的数学/及其可处理的公式定义的语言。一般作为一个集合出现。</p><p>语言定义在某一个特定的字母表上，字母表可以为任意有限集合（一般由$\Sigma$表示）。例如集合${a, b, c…, z}$就表示所有小写字母构成的字母表。</p><p>而字符串就是字母表中元素构成的有穷序列。</p><p>所以直觉上，一个语言是字母表所能构成的所有串的集合的一个子集。</p><h3 id="语言的表示方法"><a href="#语言的表示方法" class="headerlink" title="语言的表示方法"></a>语言的表示方法</h3><p>不像自然语言，一个形式语言作为一个集合，需要有某种明确的标准来定义一个字符串是否是他的元素。定义方法主要有如下几种。</p><ul><li>枚举法</li><li>形式文法（Formal Grammars，也叫做Phrase Structure Grammars）</li><li>正则文法（Regular Grammars）</li><li>自动机（图灵机、有限状态自动机）（Automata）</li><li>上下文无关文法（Context-Free Grammars, CFG）</li></ul><!--注：在NLP中，S表示句子；NP/VP/PP是名词短语、动词短语、介词短语（短语级别）；N/V/P分别是名词、动词、介词--><h2 id="Formal-Grammars-（形式文法）"><a href="#Formal-Grammars-（形式文法）" class="headerlink" title="Formal Grammars （形式文法）"></a>Formal Grammars （形式文法）</h2><p>在形式语言理论中，形式文法是形式语言中字符串的一套产生式规则(Production Rules)。这些规则描述了如何用语言的字母表生成复合语法的有效字符串。</p><p>文法不描述字符串的含义，也不描述任何上下文中可以用他们做什么，只描述他们的形式。</p><p>![截屏2022-04-22 22.35.39](Formal-Language-Theory/截屏2022-04-22 22.35.39.png)</p><h3 id="Phrase-Structure-Grammar（句子结构语法）"><a href="#Phrase-Structure-Grammar（句子结构语法）" class="headerlink" title="Phrase Structure Grammar（句子结构语法）"></a>Phrase Structure Grammar（句子结构语法）</h3><p>$G = &lt;N, T, P, S&gt;$</p><p>G：一个有限语法集合</p><p>N： 一个非终端标记(Nonterminal Symbol)的有限集合</p><p>T：一个终端标记(Terminal Symbol)的有限集合</p><p>P：一个生成规则的有限集合</p><p>$\alpha\to\beta$     $\alpha\in(N\cup T)$     $\beta\in(N\cup T)$</p><p>S：启动标记</p><h2 id="正则文法-regular-Grammars"><a href="#正则文法-regular-Grammars" class="headerlink" title="正则文法(regular Grammars)"></a>正则文法(regular Grammars)</h2><p>正则文法分为两种类型。</p><p>第一类要求生成式的形式必须是$A\to \omega B$或$A\to \omega$。其中$A, B$都是变元，$\omega$是Terminal Symbol（可以为空）这种特殊的正则文法被称为右线形（右正则）文法。</p><p>第二类则形式相反，要求必须是$A\to B\omega $或$A\to \omega$的形式被称为左线形（左正则文法）</p><p>由正则文法生成的语言被称为正则语言，是有穷自动机所识别的语言类型。</p><p>$A\to aB$, $A\to a$    $A,B\in N$, $a\in T$ (Right-regular grammar)</p><p>$G:S\to aA$    $S\to bB$</p><p>​       $A\to aA$   $A\to a$</p><p>​       $B\to bB$    $B\to b$  </p><p>最后一定会等于$a^nb^n$</p><h2 id="有限自动机（Finite-Automata）与正则文法"><a href="#有限自动机（Finite-Automata）与正则文法" class="headerlink" title="有限自动机（Finite Automata）与正则文法"></a>有限自动机（Finite Automata）与正则文法</h2><h3 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h3><p>有限自动机分为两种：确定的有限自动机(Definite Automata, DFA)和不确定的有限自动机(Non-definite Automata, NFA)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Formal-Language-Theory-形式语言理论&quot;&gt;&lt;a href=&quot;#Formal-Language-Theory-形式语言理论&quot; class=&quot;headerlink&quot; title=&quot;Formal Language Theory 形式语言理论&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="NLP" scheme="http://example.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>哈希表_总结</title>
    <link href="http://example.com/2022/04/21/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/04/21/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-21T14:38:56.000Z</published>
    <updated>2022-04-21T14:54:35.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表-Hash-Table"><a href="#哈希表-Hash-Table" class="headerlink" title="哈希表(Hash Table)"></a>哈希表(Hash Table)</h2><h3 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h3><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p><p>简单来讲，数组就是一种哈希表。哈希表中关键码就是数组的索引下标，通过下标直接访问数组中的元素。</p><h3 id="哈希表一般用于解决什么问题？"><a href="#哈希表一般用于解决什么问题？" class="headerlink" title="哈希表一般用于解决什么问题？"></a>哈希表一般用于解决什么问题？</h3><p>用来快速判断一个元素是否出现在集合里。O(1)就可以做到，无需遍历。但需要额外空间。</p><h3 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h3><p>当我们想用哈希法解决问题的时候，一般会选择如下三种关系结构。</p><ul><li>数组</li><li>set 集合</li><li>map 映射</li></ul><p>set只能储存一种值，但map可以储存一个<code>&lt;key, value&gt;</code>的键值对</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;哈希表-Hash-Table&quot;&gt;&lt;a href=&quot;#哈希表-Hash-Table&quot; class=&quot;headerlink&quot; title=&quot;哈希表(Hash Table)&quot;&gt;&lt;/a&gt;哈希表(Hash Table)&lt;/h2&gt;&lt;h3 id=&quot;什么是哈希表&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Git for PyCharm</title>
    <link href="http://example.com/2022/04/18/Git-for-PyCharm/"/>
    <id>http://example.com/2022/04/18/Git-for-PyCharm/</id>
    <published>2022-04-18T00:33:53.000Z</published>
    <updated>2022-04-18T00:44:19.549Z</updated>
    
    <content type="html"><![CDATA[<p>在利用<code>Python</code>进行日常开发中，经常会使用<code>Git</code>来管理项目，IDE使用<code>PyCharm</code>，<code>PyCharm</code>中的<code>Git</code>操作可以节约我们用shell打代码的时间。</p><p>IDE: PyCharm</p><p>OS: MacOS</p><h2 id="拉取仓库"><a href="#拉取仓库" class="headerlink" title="拉取仓库"></a>拉取仓库</h2><p>利用PyCharm使用<code>Git clone</code>的方法：</p><p>直接选择左上角<code>Git</code>，然后克隆，输入克隆地址即可。</p><h2 id="Git-commit"><a href="#Git-commit" class="headerlink" title="Git commit"></a>Git commit</h2><p>修改好文件之后需要<code>commit</code>操作。</p><p>打开<code>commit</code>窗口</p><h3 id="添加到-gitignore"><a href="#添加到-gitignore" class="headerlink" title="添加到.gitignore"></a>添加到.gitignore</h3><p>选中需要添加到<code>.gitignore</code>的文件，鼠标右键选择<code>add to .gitignore</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在利用&lt;code&gt;Python&lt;/code&gt;进行日常开发中，经常会使用&lt;code&gt;Git&lt;/code&gt;来管理项目，IDE使用&lt;code&gt;PyCharm&lt;/code&gt;，&lt;code&gt;PyCharm&lt;/code&gt;中的&lt;code&gt;Git&lt;/code&gt;操作可以节约我们用shell打代</summary>
      
    
    
    
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Numpy &amp; Matplotlib for Python</title>
    <link href="http://example.com/2022/04/17/Numpy-Matplotlib-for-Python/"/>
    <id>http://example.com/2022/04/17/Numpy-Matplotlib-for-Python/</id>
    <published>2022-04-17T01:00:30.000Z</published>
    <updated>2022-04-17T01:47:37.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NumPy-amp-Matplotlib-for-Python"><a href="#NumPy-amp-Matplotlib-for-Python" class="headerlink" title="NumPy &amp; Matplotlib for Python"></a>NumPy &amp; Matplotlib for Python</h2><p>写在前面：</p><p>本篇文章为个人学习总结所用。</p><p>使用环境：Anaconda + Python3.7 + Jupyter notebook + Tensorflow</p><p><strong>NumPy 与 Matplotlib一同创造了一个MATLAB的完全替代品。配合Jupiter-notebook一同使用可以在数据处理上达到令人满意的效果。</strong></p><h3 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h3><p>NumPy最重要的一个特点是其N维数组对象ndarray，是一系列同类型数据的集合。</p><p>创建一个ndarray只需要调用NumPy的array函数即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 一维数组</span><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span> (a)<br><span class="hljs-comment"># 输出结果：[1 2 3]</span><br><br><span class="hljs-comment"># 多于一个维度</span><br>a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])<br><span class="hljs-comment"># 输出结果：[[1 2]</span><br><span class="hljs-comment">#           [3 4]]</span><br><br><span class="hljs-comment"># 最小维度</span><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], ndmin = <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> (a)<br><span class="hljs-comment"># 输出结果：[[1 2 3 4 5]]（这是一个二维数组，但是第二行没有赋值）</span><br><br><span class="hljs-comment"># dtype参数</span><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype = <span class="hljs-built_in">complex</span>)<br><span class="hljs-built_in">print</span> (a)<br><span class="hljs-comment"># 输出结果：[1.+0.j 2.+0.j 3.+0.j]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>Matplotlib 是 Python 的绘图库。通常和NumPy共同进行使用。</p><p>Pyplot是Matplotlib的子库，提供了和Matlab类似的绘图API</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># plot()方法绘制二维图形</span><br>xpoints = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">6</span>])<br>ypoints = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">100</span>])<br><br>plt.plot(xpoints, ypoints)<br>plt.show()<br><span class="hljs-comment"># 得到一个(0,0) 到 (6,100) 的直线</span><br></code></pre></td></tr></tbody></table></figure><p>plot函数可以绘制点和线，语法格式如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画单条线</span><br>plt.plot([x], y, [fmt], *, data=<span class="hljs-literal">None</span>, **kwargs)<br><span class="hljs-comment"># 画多条线</span><br>plt.plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)<br></code></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li>x, y：点或线的节点。x为x轴数据，y为y轴数据，数据可以列表或数组。</li><li>fmt：可选，定义基本格式（颜色，标记和线条样式）</li><li>**kwargs：可选，用在二维平面图上，设置指定属性，如标签和线的宽度。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>plot(x, y)        <span class="hljs-comment"># 创建 y 中数据与 x 中对应值的二维线图，使用默认样式</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>plot(x, y, <span class="hljs-string">'bo'</span>)  <span class="hljs-comment"># 创建 y 中数据与 x 中对应值的二维线图，使用蓝色实心圈绘制</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>plot(y)           <span class="hljs-comment"># x 的值为 0..N-1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>plot(y, <span class="hljs-string">'r+'</span>)     <span class="hljs-comment"># 使用红色 + 号</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NumPy-amp-Matplotlib-for-Python&quot;&gt;&lt;a href=&quot;#NumPy-amp-Matplotlib-for-Python&quot; class=&quot;headerlink&quot; title=&quot;NumPy &amp;amp; Matplotlib for Pyt</summary>
      
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda for Mac</title>
    <link href="http://example.com/2022/04/16/Anaconda-for-Mac/"/>
    <id>http://example.com/2022/04/16/Anaconda-for-Mac/</id>
    <published>2022-04-16T13:53:57.000Z</published>
    <updated>2022-04-16T14:40:43.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anaconda-使用教程"><a href="#Anaconda-使用教程" class="headerlink" title="Anaconda 使用教程"></a>Anaconda 使用教程</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">查看anaconda的版本</span><br>conda -V<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">查看已安装的envs</span><br>conda info -e<br></code></pre></td></tr></tbody></table></figure><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">1. 创建一个环境，指定python版本</span><br>conda create --prefix=./machinelearning python=3.9<br><span class="hljs-meta"># </span><span class="language-bash">或者</span><br>conda create --name machinelearning python=3.9<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">2. 启动该环境</span><br>conda activate machinelearning<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">3. 验证环境是否被选中</span><br>conda info --envs<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">4. 验证python版本</span><br>python --version<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">5. 禁用环境</span><br>conda deactive<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">6. 删除虚拟环境</span><br>conda env remove -n ENV_NAME<br></code></pre></td></tr></tbody></table></figure><h3 id="管理Python包"><a href="#管理Python包" class="headerlink" title="管理Python包"></a>管理Python包</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">查看当前环境下的包</span><br>conda list<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">包查询</span><br>conda search 'setup' # 替换为自己的包名<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">安装一个包</span><br>conda install [package1]<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">安装多个安装包</span><br>conda install [package1] [package2]<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">删除包</span><br>conda remove [package1]<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">升级安装包</span><br>conda upgrade [package1]<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Anaconda-使用教程&quot;&gt;&lt;a href=&quot;#Anaconda-使用教程&quot; class=&quot;headerlink&quot; title=&quot;Anaconda 使用教程&quot;&gt;&lt;/a&gt;Anaconda 使用教程&lt;/h2&gt;&lt;h3 id=&quot;验证&quot;&gt;&lt;a href=&quot;#验证&quot; cla</summary>
      
    
    
    
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法详解</title>
    <link href="http://example.com/2022/04/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/04/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-07T14:44:26.000Z</published>
    <updated>2022-04-09T06:27:07.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯问题概述"><a href="#回溯问题概述" class="headerlink" title="回溯问题概述"></a>回溯问题概述</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>注2: dfs与回溯之间并不是并列的关系，dfs是一种深度优先的遍历方法，而回溯是一种解决问题的手段。dfs可以有回溯，回溯也可以用dfs。</p><h4 id="什么是回溯算法？"><a href="#什么是回溯算法？" class="headerlink" title="什么是回溯算法？"></a>什么是回溯算法？</h4><p>回溯法也可以叫做回溯搜索法，是一种搜索的方式。回溯是递归的副产品，有递归就会有回溯。</p><h4 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="回溯法的效率"></a>回溯法的效率</h4><p>回溯法的性能如何呢？实际上不是什么高效的算法。因为本质是穷举。如果想要回溯法高效，可以增加一些剪枝的操作。但效率仍然一般，因为其本质就是穷举。</p><h4 id="回溯法适合解决的问题"><a href="#回溯法适合解决的问题" class="headerlink" title="回溯法适合解决的问题"></a>回溯法适合解决的问题</h4><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等</li></ul><p>注：组合和排列的区别是组合不强调元素顺序，排列强调元素顺序。</p><h4 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h4><p>回溯法解决的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度则构成了树的深度。</p><p>使用递归就要有中止条件，所以树的高度是有限的。</p><p>解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考三个问题。</p><ol><li>路径：也就是已经作出的选择。</li><li>选择列表：也就是你当前可以做的选择。</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java">result = []<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(路径，选择列表)</span>:<br>  <span class="hljs-keyword">if</span> (满足结束条件){<br>    result.add(路径);<br>    <span class="hljs-keyword">return</span>;<br>  }<br>  <span class="hljs-keyword">for</span> (选择 : 选择列表) {<br>     做选择 or 处理节点;<br>     backtrack(路径，选择列表); <span class="hljs-comment">// 递归</span><br>     回溯，撤销选择;<br>  }<br></code></pre></td></tr></tbody></table></figure><p>核心就是for循环里的递归，在递归调用之前做选择，在递归调用之后撤销选择。</p><p>可以看出for循环就是横向的遍历，backtracking就是纵向遍历，这样就把这棵树全遍历完了。</p><p>这个框架的奥秘在哪里呢？我们来看两道例题：</p><h3 id="1-全排列问题"><a href="#1-全排列问题" class="headerlink" title="1. 全排列问题"></a>1. 全排列问题</h3><p>高中的排列组合数学题。对于n个不同的数，全排列共有n!个。</p><p>穷举全排列的方法？[1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1]…..</p><p>可以按照这个逻辑画出一颗决策树。</p><p>只要从root遍历这棵树，记录路径上的数字，其实就是所有的全排列。</p><p>假如我们进行穷举走到了[2, x, y]的分叉，这时候2的含义就是[路径]，用于记录你已经做过的选择；</p><p>而[1]或[3]则是[选择列表]。表示你当前可以做出的选择；</p><p>[结束条件]就是遍历到树的底层，在这里就是选择列表为空的时候。</p><p>这时候可以看出，我们所定义的backtrack函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其[路径]就是一个全排列。</p><p>那么，如何遍历这棵树？</p><p>简单的二叉树遍历罢了，前序遍历 or 后序遍历。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>{<br>  <span class="hljs-keyword">for</span> (TreeNode child : root.children)<br>  <span class="hljs-comment">//前序遍历需要的操作</span><br>    <span class="hljs-built_in">traverse</span>(child);<br>  <span class="hljs-comment">//后序遍历需要的操作</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>稍微回忆一下，前序遍历的代码会在进入某一个节点之前的时间执行，而后序遍历代码会在离开某个节点之后的那个时间点执行。</p><p>而就在刚才我们所述，[路径]和[选择]是每个节点的属性，函数在树上游走要正确维护节点的属性。所以我们应当在前序和后序两个位置选择不同的操作。</p><p>前序为做出选择，而后序为撤销选择。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>  <span class="hljs-comment">#做选择</span><br>  将该选择从选择列表移除<br>  路径.add(选择) <br>  backtrack(路径，选择列表)<br>  <span class="hljs-comment">#撤销选择</span><br>  路径.remove(选择)<br>  将该选择再加入选择列表<br></code></pre></td></tr></tbody></table></figure><p>我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确的得到每个节点的选择列表与路径。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-comment">// 主函数，输入一组不重复的数字，返回他们的全排列</span><br>List&lt;List&lt;Integer&gt;&gt; <span class="hljs-built_in">permute</span>(<span class="hljs-type">int</span>[] nums) {<br>  <span class="hljs-comment">// 记录路径</span><br>  LinkedList&lt;integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-built_in">backtrack</span>(nums, track);<br>  <span class="hljs-keyword">return</span> res;<br>}<br><br><span class="hljs-comment">// 路径：记录在 track 中</span><br><span class="hljs-comment">// 选择列表：nums 中不存在于 track 的那些元素</span><br><span class="hljs-comment">// 结束条件: nums 中的元素全都在track 中出现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>{<br>  <span class="hljs-comment">// 触发结束条件</span><br>  <span class="hljs-keyword">if</span> (track.<span class="hljs-built_in">size</span>() == nums.length) {<br>    res.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedList</span>(track));<br>    <span class="hljs-keyword">return</span>;<br>  }<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; nums.length; i++) {<br>    <span class="hljs-comment">// 排除不合法的选择</span><br>    <span class="hljs-keyword">if</span> (track.<span class="hljs-built_in">contains</span>(nums[i]))<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-comment">// 做选择</span><br>    track.<span class="hljs-built_in">add</span>(nums[i]);<br>    <span class="hljs-comment">// 进入下一层决策树</span><br>    <span class="hljs-built_in">backtrack</span>(nums, track);<br>    <span class="hljs-comment">// 取消选择</span><br>    track.<span class="hljs-built_in">removeLast</span>();<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>自此，我们就通过全排列问题了解了简单的回溯算法。当然，这个算法解决全排列并不高效，<code>contains</code>方法需要O(N)的时间复杂度。有更好的方法可以follow up</p><p>但不论怎样优化，只要符合回溯框架，时间复杂度都不可能低于O(N!)，因为穷举整棵树是无法避免的。一般回溯算法时间复杂度都很高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回溯问题概述&quot;&gt;&lt;a href=&quot;#回溯问题概述&quot; class=&quot;headerlink&quot; title=&quot;回溯问题概述&quot;&gt;&lt;/a&gt;回溯问题概述&lt;/h2&gt;&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;p&gt;注2: dfs与回溯之间并不是并列的关系，dfs是一种</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Depth First Search 深度优先搜索</title>
    <link href="http://example.com/2022/04/07/Depth-First-Search-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://example.com/2022/04/07/Depth-First-Search-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2022-04-07T14:33:35.000Z</published>
    <updated>2022-04-07T14:53:44.850Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文仅为个人学习笔记，无任何版权。</p><p>深度优先算法（DFS, Depth first search），是搜索算法的一种。</p><p>基本思想：沿着树的深度来遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都已被探寻过，搜索讲回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个过程反复进行直到所有节点都被访问为止。</p><p>深度优先算法也可以解决很多经典的图论问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;p&gt;深度优先算法（DFS, Depth first search），是搜索算法的一种。&lt;/p&gt;
&lt;p&gt;基本思想：沿着树的深度来遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都已被探寻过，搜索讲回溯到发现节点v的那条边</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Scanner &amp; BufferedReader 用法详解</title>
    <link href="http://example.com/2022/04/06/Scanner-BufferReader-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/04/06/Scanner-BufferReader-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-06T01:29:31.000Z</published>
    <updated>2022-04-07T14:55:20.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scanner-amp-BufferedReader用法详解"><a href="#Scanner-amp-BufferedReader用法详解" class="headerlink" title="Scanner &amp; BufferedReader用法详解"></a>Scanner &amp; BufferedReader用法详解</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>这段时间一直没把java的输入写明白，在该记事里进行一个总结</p><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>Scanner使用分隔符模式将其输入分解为标记，默认情况下是利用空白进行分割的。之后可以使用不同的<code>next</code>方法将得到的标记转换为不同类型的值。</p><p>Scanner位于<code>java.util</code>包中，Scanner的具体用法为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">//通过new创建一个Scanner对象</span><br><span class="hljs-comment">//传入一个System.in参数来读取输入</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//输入一个Integer</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextInt(); <br><span class="hljs-comment">//读取一整行字符串（以Enter结尾进行分界）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextLine();<br><span class="hljs-comment">//读取一组字符串（以空格/Tab/Enter进行分界，只要遇到其中之一就返回下一个 //输入）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.next();<br></code></pre></td></tr></tbody></table></figure><h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>BufferedReader位于<code>java.io</code>包中，读取数据比较固定，这样格式也比较单一。只要记住就这一读取数据的方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><br><span class="hljs-comment">//BufferedReader的readLine()方法必须处理java.o.IOException异常，所以需要在Public static void main后面补充处理。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {<br>  <span class="hljs-comment">//创建BufferReader对象，从键盘读入</span><br>  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>  <span class="hljs-comment">//创建BufferReader对象，从文本文件读入</span><br>  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">"test.txt"</span>));<br><br>  <span class="hljs-comment">//读取一行数据并用空格分隔，存入字符串数组</span><br>  String[] temp = br1.readLine().split(<span class="hljs-string">""</span>);<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>BufferedReader readLine()方法可能抛出异常，比如要读的文件不存在的话就会抛异常。会抛异常的方法要么在调用的时候用try catch包围，在调用它的时候就写好处理异常的代码，要么就在当前的函数后面加throw声明可能出现的异常，交给调用当前函数的函数处理异常。</p><p>BufferedReader读取的数据都以字符串的形式存储，如果需要其他形式的数据，需要进行强制转换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Scanner-amp-BufferedReader用法详解&quot;&gt;&lt;a href=&quot;#Scanner-amp-BufferedReader用法详解&quot; class=&quot;headerlink&quot; title=&quot;Scanner &amp;amp; BufferedReader用法详解</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/2022/04/04/%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/04/04/%E9%93%BE%E8%A1%A8/</id>
    <published>2022-04-04T04:15:56.000Z</published>
    <updated>2022-04-21T14:34:41.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表题型刷题总结"><a href="#链表题型刷题总结" class="headerlink" title="链表题型刷题总结"></a>链表题型刷题总结</h1><p>注：本文仅为个人学习笔记，无任何版权。</p><h3 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h3><p>一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null</p><p>链表的头节点为head</p><h4 id="链表的类型："><a href="#链表的类型：" class="headerlink" title="链表的类型："></a>链表的类型：</h4><ol><li>单链表</li><li>双链表</li><li>循环链表</li></ol><h4 id="链表在内存中的储存方式"><a href="#链表在内存中的储存方式" class="headerlink" title="链表在内存中的储存方式"></a>链表在内存中的储存方式</h4><p>与数组不同，链表在内存中<strong>不是连续分布。</strong></p><p>链表是通过指针域的指针链接在内存的各个节点，所以链表中的节点在内存中不是连续分布的，而是三楼缘分不在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><h4 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-comment">// 结点的值</span><br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-comment">// 下一个结点</span><br>    ListNode next;<br><br>    <span class="hljs-comment">// 节点的构造函数(无参)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> {<br>    }<br><br>    <span class="hljs-comment">// 节点的构造函数(有一个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> {<br>        <span class="hljs-built_in">this</span>.val = val;<br>    }<br><br>    <span class="hljs-comment">// 节点的构造函数(有两个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> {<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    }<br>}<br><br>List&lt;&gt; xxx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></tbody></table></figure><h4 id="删除节点："><a href="#删除节点：" class="headerlink" title="删除节点："></a>删除节点：</h4><p>只要将被删除节点的前一个节点的指针，指向后一个节点就可以了。如果要删除第n个节点，可以将第n-1个节点的指针指到第n+1个节点，java会自动释放那块内存。</p><h4 id="添加节点："><a href="#添加节点：" class="headerlink" title="添加节点："></a>添加节点：</h4><p>同理，修改指针即可。</p><p>可以看出链表的增添/删除都是O(1)的操作，不会影响到其他节点。但是，如果要删除第c个节点，需要从头节点找到第c-1个节点，查找的时间复杂度为O(c)</p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>链表删除/插入：O(1)</p><p>链表查找：          O(n)</p><p>数组删除/插入：O(n)</p><p>数组查找：          O(1)</p><p>数组：数据量固定，频繁查找，较少增删</p><p>链表：数据量不固定，频繁增删，较少查找</p><h3 id="链表的经典题目"><a href="#链表的经典题目" class="headerlink" title="链表的经典题目"></a>链表的经典题目</h3><h4 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h4><p>链表操作的一大问题就是当前节点必须要找前一个节点才能操作，在这种情况下，用一个虚拟头节点可以解决这个问题。</p><p>203</p><h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><p>一道题写一个链表ListNode的class出来，非常好的题目 </p><p>707</p><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>高频题目，递归和迭代都可以解决，建议一定熟练掌握本质。</p><p>206</p><h4 id="删除倒数第N个节点"><a href="#删除倒数第N个节点" class="headerlink" title="删除倒数第N个节点"></a>删除倒数第N个节点</h4><p>虚拟头节点 + 双指针，第一个指针走n 然后第二个指针跟第一个指针一起出发。</p><p>19</p><h4 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h4><p>很trick的方法。虽然两个链表到达相交点的距离可能不一样，但我们可以加两个链表加起来。一个指针从A遍历到B，一个指针从B遍历到A。这样他们就可以同时到达交点了！</p><p>面试题 02.07</p><h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p>难点在数学证明，方法是快慢指针。很有趣的题目。</p><p>142</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表题型刷题总结&quot;&gt;&lt;a href=&quot;#链表题型刷题总结&quot; class=&quot;headerlink&quot; title=&quot;链表题型刷题总结&quot;&gt;&lt;/a&gt;链表题型刷题总结&lt;/h1&gt;&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;h3 id=&quot;什么是链表？&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://example.com/2022/04/02/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://example.com/2022/04/02/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-04-02T10:56:03.000Z</published>
    <updated>2022-04-10T06:11:35.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组题型刷题总结"><a href="#数组题型刷题总结" class="headerlink" title="数组题型刷题总结"></a>数组题型刷题总结</h1><p>注：本文仅为个人学习笔记，无任何版权。</p><p>数组：存放在连续空间的相同类型元素的集合，一般不进行删除操作。</p><p>两点注意；</p><ol><li>数组下标都是从0开始</li><li>数组内存空间地址连续（增添删除都很麻烦）</li></ol><p>二维数组在系统中的存储方式</p><p>m*n的二维数组来说，一般由一个头节点指向一个长为n的一维列数组，每个列数组又作为另一个长为m的一维行数组的头节点。</p><p>并不是连续地址空间</p><p>一般看到链表/子串/数组之类的题，直接上双指针就行</p><p>常用方法：</p><ol><li>二分法</li><li>双指针</li><li>滑动窗口</li><li>模拟行为</li></ol><h3 id="1-二分法"><a href="#1-二分法" class="headerlink" title="1. 二分法"></a>1. 二分法</h3><p>704, 35, 34, 69, 367</p><p>限制条件：<strong>有序数组</strong>  且 <strong>无重复元素</strong></p><p>Key：边界条件的设定。在二分查找过程中，每次区间变化都遵守边界条件不变。</p><p>常用区间：[lo, hi],  [lo, hi)</p><p>注：乘法溢出时用除法处理即可。</p><p>暴力解法一般时间复杂度为O(N)</p><p>二分法一般时间复杂度为O(logN)</p><h3 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2. 双指针"></a>2. 双指针</h3><p>27, 26, 283, 844, 977</p><p>双指针技巧可以分为两类：【快慢指针】和【左右指针】。前者解决链表中的问题，比如判断链表是否包含环；后者主要解决数组（字符串）中的问题，二分查找也是左右指针的一种特殊情况。</p><p>常见的双指针问题还有移除元素/移除字符串等。</p><p>快慢指针常见问题：链表操作/找中点/归并排序/链表环</p><p>左右指针常见问题：反转数组/二分搜索</p><p>暴力解法时间复杂度一般为O(N^2)</p><p>双指针法时间复杂度一般为O(N)</p><h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h3><p>209, 904, 76</p><p>实际上滑动窗口也是一种特殊的双指针。不过因为其在<strong>子串</strong>问题中的优异表现，我将其单独作为一个部分来讲。</p><p>滑动窗口算法的大致逻辑如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; s.size()) {<br>  <span class="hljs-comment">//增大窗口</span><br>  window.add(s[right]);<br>  right++;<br>  <br>  <span class="hljs-keyword">while</span> (window needs shrink) {<br>    <span class="hljs-comment">//缩小窗口</span><br>    window.remove(s[left]);<br>    left++;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度O(N)， 比一般的字符串暴力算法高效的多。</p><p>滑动窗口的关键在于各种细节问题。比如如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即使你明白了这些细节，也容易报错。</p><p>使用一套来自labuladong 的滑动窗口代码框架。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//需要的字符传入need</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) {<br>  need. put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>}<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (right &lt; s.length()) {<br>  <span class="hljs-comment">//c是移入窗口的字符</span><br>  <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>  <span class="hljs-comment">//右边界右移</span><br>  right++;<br>  <br>  <span class="hljs-comment">//进入窗口的一系列操作.....</span><br>  <br>  <span class="hljs-comment">//当满足时，进行窗口缩减</span><br>  <span class="hljs-keyword">while</span> (window needs shrink) {<br>    <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>    <span class="hljs-comment">//左边界右移</span><br>    left++;<br>    <br>    <span class="hljs-comment">//出窗口</span><br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-模拟行为"><a href="#4-模拟行为" class="headerlink" title="4. 模拟行为"></a>4. 模拟行为</h3><p>48， 54， 59</p><p>不涉及太多算法，单纯模拟，考验对代码的掌控能力。</p><p>循环不变量原则十分重要。</p><p>真正解决题目的代码都是简洁的，有原则性的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组题型刷题总结&quot;&gt;&lt;a href=&quot;#数组题型刷题总结&quot; class=&quot;headerlink&quot; title=&quot;数组题型刷题总结&quot;&gt;&lt;/a&gt;数组题型刷题总结&lt;/h1&gt;&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;p&gt;数组：存放在连续空间的相同类型元素的集</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>OnJava8-File</title>
    <link href="http://example.com/2022/03/31/OnJava8-File/"/>
    <id>http://example.com/2022/03/31/OnJava8-File/</id>
    <published>2022-03-31T01:01:41.000Z</published>
    <updated>2022-04-07T14:54:54.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Way-to-Input-x2F-Output-File-by-Java"><a href="#The-Way-to-Input-x2F-Output-File-by-Java" class="headerlink" title="The Way to Input/Output File by Java"></a>The Way to Input/Output File by Java</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>打开并读取文件对于大多数编程语言来说是非常实用的。Java8与java7新增的<code>java.nio.file</code>包以及streams与文件结合使得文件操作编程变得十分简单。</p><p>对于文件操作来说，最基本的两个组件是</p><ol><li>文件或者目录的路径；</li><li>文件本身。</li></ol><h3 id="文件和目录路径"><a href="#文件和目录路径" class="headerlink" title="文件和目录路径"></a>文件和目录路径</h3><p>一个<code>Path</code>对象表示一个文件或者目录的路径，可以跨操作系统和文件系统。</p><p><code>java.nio.file.Path</code>包含一个重载方法<code>static get()</code>，该方法接受一系列<code>String</code>字符串或一个URI作为参数，进行转换返回一个<code>Path</code>对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// files/PathInfo.java</span><br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PathInfo</span> {<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String id, Object p)</span> {<br>        System.out.println(id + <span class="hljs-string">": "</span> + p);<br>    }<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(Path p)</span> {<br>        show(<span class="hljs-string">"toString"</span>, p);<br>        show(<span class="hljs-string">"Exists"</span>, Files.exists(p));<br>        show(<span class="hljs-string">"RegularFile"</span>, Files.isRegularFile(p));<br>        show(<span class="hljs-string">"Directory"</span>, Files.isDirectory(p));<br>        show(<span class="hljs-string">"Absolute"</span>, p.isAbsolute());<br>        show(<span class="hljs-string">"FileName"</span>, p.getFileName());<br>        show(<span class="hljs-string">"Parent"</span>, p.getParent());<br>        show(<span class="hljs-string">"Root"</span>, p.getRoot());<br>        System.out.println(<span class="hljs-string">"******************"</span>);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        System.out.println(System.getProperty(<span class="hljs-string">"os.name"</span>));<br>        info(Paths.get(<span class="hljs-string">"C:"</span>, <span class="hljs-string">"path"</span>, <span class="hljs-string">"to"</span>, <span class="hljs-string">"nowhere"</span>, <span class="hljs-string">"NoFile.txt"</span>));<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"PathInfo.java"</span>);<br>        info(p);<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">ap</span> <span class="hljs-operator">=</span> p.toAbsolutePath();<br>        info(ap);<br>        info(ap.getParent());<br>        <span class="hljs-keyword">try</span> {<br>            info(p.toRealPath());<br>        } <span class="hljs-keyword">catch</span>(IOException e) {<br>           System.out.println(e);<br>        }<br>        <span class="hljs-type">URI</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> p.toUri();<br>        System.out.println(<span class="hljs-string">"URI: "</span> + u);<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">puri</span> <span class="hljs-operator">=</span> Paths.get(u);<br>        System.out.println(Files.exists(puri));<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ap.toFile(); <span class="hljs-comment">// Don't be fooled</span><br>    }<br>}<br><br><span class="hljs-comment">/* 输出:</span><br><span class="hljs-comment">Windows 10</span><br><span class="hljs-comment">toString: C:\path\to\nowhere\NoFile.txt</span><br><span class="hljs-comment">Exists: false</span><br><span class="hljs-comment">RegularFile: false</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: NoFile.txt</span><br><span class="hljs-comment">Parent: C:\path\to\nowhere</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: false</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: null</span><br><span class="hljs-comment">Root: null</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files\PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: false</span><br><span class="hljs-comment">Directory: true</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: files</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files\PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">URI: file:///C:/Users/Bruce/Documents/GitHub/onjava/</span><br><span class="hljs-comment">ExtractedExamples/files/PathInfo.java</span><br><span class="hljs-comment">true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-Way-to-Input-x2F-Output-File-by-Java&quot;&gt;&lt;a href=&quot;#The-Way-to-Input-x2F-Output-File-by-Java&quot; class=&quot;headerlink&quot; title=&quot;The Way to I</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP, UDP and Socket</title>
    <link href="http://example.com/2022/03/26/TCP-IP-UDP-and-Socket/"/>
    <id>http://example.com/2022/03/26/TCP-IP-UDP-and-Socket/</id>
    <published>2022-03-26T01:56:22.000Z</published>
    <updated>2022-04-07T14:55:29.031Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文仅为个人学习笔记，无任何版权。</p><p>本篇旨在解决如下三个问题：</p><ol><li>什么是TCP/IP、UDP？</li><li>Socket是什么？</li><li>如何使用上述的服务？</li></ol><p>让我们开始吧！</p><h2 id="1-什么是TCP-x2F-IP、UDP？"><a href="#1-什么是TCP-x2F-IP、UDP？" class="headerlink" title="1. 什么是TCP/IP、UDP？"></a>1. 什么是TCP/IP、UDP？</h2><p>TCP/IP（Transmission Control Protocol/ Internet Protocol）即传输控制协议/网间协议。是一个工业标准的protocol集，他是为广域网（WANs）设计的。</p><p>UDP（User Data Protocal，用户数据报协议）是与TCP相对应的协议。他是属于TCP/IP协议集中的一种。</p><p>![截屏2022-03-26 11.04.16](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.04.16.png)</p><p>TCP/IP协议族包括运输层、网络层、链路层。TCP与UDP都是运用在运输层上的协议。</p><h2 id="2-Socket是什么？"><a href="#2-Socket是什么？" class="headerlink" title="2. Socket是什么？"></a>2. Socket是什么？</h2><p>在上图中，我们并未看到Socket的影子。</p><p>Socket究竟在网络服务中扮演了怎样的角色呢？</p><p>实际上Socket的位置应该在应用层与运输层之间。起到了一个将应用层传输给运输层的信息进行抽象的作用。</p><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，他是一组接口。在设计模式中，Socket其实就是一个门面模式，他可以将复杂的TCP/IP协议族隐藏在后面，提供给用户一个简单的接口信息。用户只需要让Socket去组织数据，以符合制定的协议。</p><h2 id="3-如何使用上述的服务？"><a href="#3-如何使用上述的服务？" class="headerlink" title="3. 如何使用上述的服务？"></a>3. 如何使用上述的服务？</h2><h4 id="截屏2022-03-26-11-09-35-TCP-IP-UDP-and-Socket-x2F-截屏2022-03-26-11-09-35-png"><a href="#截屏2022-03-26-11-09-35-TCP-IP-UDP-and-Socket-x2F-截屏2022-03-26-11-09-35-png" class="headerlink" title="![截屏2022-03-26 11.09.35](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.09.35.png)"></a>![截屏2022-03-26 11.09.35](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.09.35.png)</h4><p>先从服务器端讲起。服务器端先初始化Socket，然后与端口绑定（bind），对端口进行监听（Listen），调用Accept阻塞，等待客户端链接。在这时候如果有客户端初始化了一个Socket，然后连接服务器（connect），如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接受请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><p><a href="https://blog.csdn.net/pashanhu6402/article/details/96428887">原文连接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;p&gt;本篇旨在解决如下三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是TCP/IP、UDP？&lt;/li&gt;
&lt;li&gt;Socket是什么？&lt;/li&gt;
&lt;li&gt;如何使用上述的服务？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们开始吧！&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="Project-Web" scheme="http://example.com/tags/Project-Web/"/>
    
  </entry>
  
  <entry>
    <title>gototp: A TOTP Library Written by Go</title>
    <link href="http://example.com/2022/03/16/gototp-A-TOTP-Library-Written-by-Go/"/>
    <id>http://example.com/2022/03/16/gototp-A-TOTP-Library-Written-by-Go/</id>
    <published>2022-03-15T23:48:50.000Z</published>
    <updated>2022-03-16T00:04:24.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gototp"><a href="#gototp" class="headerlink" title="gototp"></a>gototp</h1><p>A TOTP(Time Based One-Time Password, RFC6328) Library Written by Golang. </p><p><a href="https://xiaogeamadeus.github.io/2022/03/11/RFC6328-Time-Based-One-Time-Password/">The way to create this library</a></p><p><a href="https://github.com/xiaogeamadeus/gototp">Github of totp</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc6328">RFC6328</a></p><h2 id="How-to-Get-the-Library"><a href="#How-to-Get-the-Library" class="headerlink" title="How to Get the Library"></a>How to Get the Library</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/xiaogeamadeus/gototp<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gototp&quot;&gt;&lt;a href=&quot;#gototp&quot; class=&quot;headerlink&quot; title=&quot;gototp&quot;&gt;&lt;/a&gt;gototp&lt;/h1&gt;&lt;p&gt;A TOTP(Time Based One-Time Password, RFC6328) Library </summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>Gogee-Day3-Trie木ルータ</title>
    <link href="http://example.com/2022/03/14/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/"/>
    <id>http://example.com/2022/03/14/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/</id>
    <published>2022-03-14T00:47:07.000Z</published>
    <updated>2022-04-07T14:54:28.919Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文仅为个人学习笔记，无任何版权。</p><p>本篇主要内容：1. 使用Trie树实现动态路由(dynamic route)解析。</p><p>支持两种模式<code>:name</code>和<code>*filepath*</code></p><h2 id="Trie-Tree-Router"><a href="#Trie-Tree-Router" class="headerlink" title="Trie Tree Router"></a>Trie Tree Router</h2><p>之前，我们用了一个非常简单的map结构储存了路由表(router map)，使用map存储键值对，索引非常高效，但是有一个弊端，键值对存储的方式只适用于静态路由.</p><p>如果我们想要支持<code>/hello/:name</code>这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类而非某一条固定的路由。比如<code>/hello/:name</code>，可以匹配<code>/hello/xiaogeamadeus</code>、<code>hello/tom</code>等。</p><p>动态路由有很多种实现方式，支持的规则、性能等有很大的差异。例如开源的路由实现<code>gorouter</code>支持在路由规则中嵌入正则表达式，例如<code>/p/[0-9A-Za-z]+</code>，即路径中的参数仅匹配数字和字母；另一个开源实现<code>httprouter</code>就不支持正则表达式。<code>gin</code>在早期的版本，并没有实现自己的路由，而是直接使用了httprouter，后来放弃了，自己实现了一个版本。<img src="/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/IMG_573DEF5931EE-1.jpeg" alt="IMG_573DEF5931EE-1"></p><p>实现动态路由最常用的数据结构，被称为前缀树(Trie Tree)：每一个节点的所有子节点都拥有相同的前缀。这种结构非常适用于路由匹配。例如，我们定义了如下路由规则：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/:lang/</span>doc<br><span class="hljs-regexp">/:lang/</span>tutorial<br><span class="hljs-regexp">/:lang/i</span>ntro<br>/about<br><span class="hljs-regexp">/p/</span>blog<br><span class="hljs-regexp">/p/</span>related<br></code></pre></td></tr></tbody></table></figure><p>我们用前缀树来表示的话就会变成三颗子树/:lang、/about、/p</p><p>HTTP请求的路径恰好是由<code>/</code>分隔的多段构成的，因此，每一段可以作为前缀树的一个节点。我们通过树结构查询，如果中间某一层的节点都不满足条件，那么就说明没有匹配到的路由，查询结束。</p><p>我们接下来实现的路由具有如下两个功能。</p><ol><li>参数匹配：<code>/p/:lang/doc</code>可以匹配<code>/p/c/doc</code>或者<code>/p/go/doc</code></li><li>通配符<code>*</code>。例如<code>/static/*filepath</code>，可以匹配<code>/static/fav.ico</code>，也可以匹配<code>/static/js/jQuery.js</code>，这种模式常用于静态服务器，能够递归的匹配子路径。</li></ol><h2 id="Trie木の実現"><a href="#Trie木の実現" class="headerlink" title="Trie木の実現"></a>Trie木の実現</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ttype node <span class="hljs-keyword">struct</span> {<br>  pattern <span class="hljs-type">string</span> <span class="hljs-comment">//带匹配路由，例如/p/:lang</span><br>  part <span class="hljs-type">string</span> <span class="hljs-comment">//路由中的一部分，例如:lang</span><br>  children []*node <span class="hljs-comment">//子节点，例如[doc, tutorial,intro]</span><br>  isWild <span class="hljs-type">bool</span> <span class="hljs-comment">//是否精确匹配，part含有:或*时为true</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>与普通的树不同，为了实现动态路由匹配，加上了<code>isWild</code>这个参数。即当我们匹配到<code>/p/go/doc</code>这个路由时，第一层节点，<code>p</code>精准的匹配到了<code>p</code>，第二层节点，<code>go</code>模糊匹配到<code>:lang</code>，那么将会把<code>lang</code>这个参数赋值为<code>go</code>，继续下一层匹配。我们将匹配的逻辑包装为一个辅助函数。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//第一个匹配成功的节点，用于插入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span>matchChild(part <span class="hljs-type">string</span>) *node{<br>  <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> n.children {<br>    <span class="hljs-keyword">if</span> child.part == part || child.isWild{<br>      <span class="hljs-keyword">return</span> child<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>}<br><span class="hljs-comment">// 所有匹配成功的节点，用于查找</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> matchChildren(part <span class="hljs-type">string</span>) []*node {<br>  nodes := <span class="hljs-built_in">make</span>([]*node, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> n.children {<br>    <span class="hljs-keyword">if</span> child.part == part||child.isWild{<br>      nodes = <span class="hljs-built_in">append</span>(nodes, child)<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> nodes<br>}<br></code></pre></td></tr></tbody></table></figure><p>对于路由来说，注册和匹配是最重要的。开发服务时，注册路由规则，映射handler; 访问时，匹配路由规则，查找到对应的handler。因此，Trie树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前<code>part</code>的节点，则新建一个。有一点需要注意，<code>/p/:lang/doc</code>只有在第三层节点，即<code>doc</code>节点，pattern才会设置为<code>/p/:lang/doc</code>。</p><p><code>p</code>和<code>:lang</code>节点的<code>pattern</code>属性皆为空。因此，当匹配结束时，我们可以使用<code>n.pattern == ""</code>来判断路由规则是否匹配成功。例如，<code>/p/python</code>虽能成功匹配到<code>:lang</code>，但<code>lang</code>的<code>pattern</code>值为空，因此匹配失败。查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到了<code>*</code>，匹</p><p>配失败，或者匹配到了第<code>len(parts)</code>层节点。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Trie tree's insert</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> insert(pattern <span class="hljs-type">string</span>, parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) {<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height {<br>    n.pattern = pattern<br>    <span class="hljs-keyword">return</span><br>  }<br>  <br>  part := parts[height]<br>  child := n.matchChild(part)<br>  <span class="hljs-keyword">if</span> child == <span class="hljs-literal">nil</span> {<br>    child = &amp;node{part: part, isWild: part[<span class="hljs-number">0</span>] == <span class="hljs-string">':'</span>|| part[<span class="hljs-number">0</span>] == <span class="hljs-string">'*'</span>}<br>    n.children = <span class="hljs-built_in">append</span>(n.children, child)<br>  }<br>  child.insert(pattern, parts, height+<span class="hljs-number">1</span>)<br>}<br><br><span class="hljs-comment">//Trie tree's search</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> search(parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) *node{<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="hljs-string">'*'</span>) {<br>    <span class="hljs-keyword">if</span> n.pattern == <span class="hljs-string">""</span>{<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    }<br>    <span class="hljs-keyword">return</span> n<br>  }<br>  <br>  part := parts[height]<br>  children := n.matchChildren(part)<br>  <br>  <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> children {<br>    result := child.search(parts, height+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> result != <span class="hljs-literal">nil</span> {<br>      <span class="hljs-keyword">return</span> result<br>    }<br>  }<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Trie 树的插入和查找实现之后，就可以将Trie树应用到路由之中了。使用<code>roots</code>来储存每种请求方式的Trie树根节点。使用<code>handlers</code>存储每种请求方式的<code>HandlerFunc</code>。<code>getRoute</code>函数中，还解析了<code>:</code>和<code>*</code>两种匹配符的参数，返回一个map。例如<code>/p/go/doc</code>匹配到<code>/p/:lang/doc</code>，解析结果为：<code>{lang:"go"}</code>，<code>/static/css/xiaogeamadeus.css</code>匹配到<code>/static/*filepath</code>，解析结果为<code>{file path:"css/xiaogeamadeus.css"}</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> router <span class="hljs-keyword">struct</span>{<br>  roots    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node<br>  handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>}<br><br><span class="hljs-comment">// roots key eg, roots['GET'] roots['POST']</span><br><span class="hljs-comment">// handlers key eg, handlers['GET-/p/:lang/doc'], handlers['POST-/p/book']</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouter</span><span class="hljs-params">()</span></span> *router {<br>  <span class="hljs-keyword">return</span> &amp;router{<br>    roots:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node),<br>    handlers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc),<br>  }<br>}<br><br><span class="hljs-comment">// Only one * is allowed</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePattern</span><span class="hljs-params">(pattern stirng)</span></span> []<span class="hljs-type">string</span>{<br>  vs := strings.Split(pattern, <span class="hljs-string">"/"</span>)<br>  <br>  parts := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> vs {<br>    <span class="hljs-keyword">if</span> item != <span class="hljs-string">""</span>{<br>      parts = <span class="hljs-built_in">append</span>()(parts, item)<br>      <span class="hljs-keyword">if</span> item[<span class="hljs-number">0</span>] == <span class="hljs-string">'*'</span>{<br>        <span class="hljs-keyword">break</span><br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> parts<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc){<br>  parts := parsePattern(pattern)<br>  <br>  key := method + <span class="hljs-string">"_"</span> + pattern<br>  _, ok := r.roots[method]<br>  <span class="hljs-keyword">if</span> !ok {<br>    r.roots[method] = &amp;node{}<br>  }<br>  r.roots[method].insert(pattern, parts, <span class="hljs-number">0</span>)<br>  r.handlers[key] = handler<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> getRoute(method <span class="hljs-type">string</span>, path <span class="hljs-type">string</span>) (*node, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>){<br>  searchParts := parsePattern(path)<br>  params := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>  root, ok := r.roots[method]<br>  <br>  <span class="hljs-keyword">if</span> !ok{<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>  }<br>  <br>  n := root.search(searchParts, <span class="hljs-number">0</span>)<br>  <br>  <span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> {<br>    parts : parsePattern(n.pattern)<br>    <span class="hljs-keyword">for</span> index, part := <span class="hljs-keyword">range</span> parts {<br>      <span class="hljs-keyword">if</span> part[<span class="hljs-number">0</span>] == <span class="hljs-string">':'</span>{<br>        params[part[<span class="hljs-number">1</span>:]] = searchParts[index]<br>      }<br>      <span class="hljs-keyword">if</span> parts[<span class="hljs-number">0</span>] == <span class="hljs-string">'*'</span>&amp;&amp; <span class="hljs-built_in">len</span>(part) &gt;<span class="hljs-number">1</span>{<br>        params[part[<span class="hljs-number">1</span>:]] = strings.Join(searchParts[index:],<span class="hljs-string">"/"</span>)<br>        <span class="hljs-keyword">break</span><br>      }<br>    }<br>    <span class="hljs-keyword">return</span> n, params<br>  }<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Contextとhandleの変化"><a href="#Contextとhandleの変化" class="headerlink" title="Contextとhandleの変化"></a>Contextとhandleの変化</h2><p>在HandleFunc 中，希望能够访问到解析的参数。因此，我们需要对Context对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到<code>Params</code>中，通过<code>c/Param("lang")</code>的方式获取到对应的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;p&gt;本篇主要内容：1. 使用Trie树实现动态路由(dynamic route)解析。&lt;/p&gt;
&lt;p&gt;支持两种模式&lt;code&gt;:name&lt;/code&gt;和&lt;code&gt;*filepath*&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>RFC2617: HTTP Authentication</title>
    <link href="http://example.com/2022/03/11/RFC2617-HTTP-Authentication/"/>
    <id>http://example.com/2022/03/11/RFC2617-HTTP-Authentication/</id>
    <published>2022-03-11T01:07:06.000Z</published>
    <updated>2022-04-07T14:54:58.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-Authentication-Basic-and-Digest-Access-Authentication"><a href="#HTTP-Authentication-Basic-and-Digest-Access-Authentication" class="headerlink" title="HTTP Authentication: Basic and Digest Access Authentication"></a>HTTP Authentication: Basic and Digest Access Authentication</h2><p>在做课题的过程中需要了解RFC2617的知识，在此做一个中文总结。注：本文仅为个人学习笔记，无任何版权。</p><h3 id="Basic-Authentication-Scheme"><a href="#Basic-Authentication-Scheme" class="headerlink" title="Basic Authentication Scheme"></a>Basic Authentication Scheme</h3><p>基本认证方案(Basic Authentication Scheme)是基于这样的模型：客户必须用一个用户ID和一个密码来认证自己的每个realm，realm vakye应当被认为是一个不透明的字符串，只能与该服务器上的其他realm进行比较以确定是否相等，服务器只有在能够验证Request-URI的用户ID和密码的情况下才能为请求提供服务。</p><p>basic-credentials = base64-user-pass </p><p>base64-user-pass = &lt;base64 [4] encoding of user-pass, except not limited to 76 char/line&gt;</p><p>user-pass = userid “:” password</p><p>userid  = *&lt;TEXT excluding “:”&gt;</p><p>password = *TEXT</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP-Authentication-Basic-and-Digest-Access-Authentication&quot;&gt;&lt;a href=&quot;#HTTP-Authentication-Basic-and-Digest-Access-Authentication&quot; cl</summary>
      
    
    
    
    
    <category term="Project-Web" scheme="http://example.com/tags/Project-Web/"/>
    
  </entry>
  
  <entry>
    <title>RFC6328: Time Based One-Time Password</title>
    <link href="http://example.com/2022/03/11/RFC6328-Time-Based-One-Time-Password/"/>
    <id>http://example.com/2022/03/11/RFC6328-Time-Based-One-Time-Password/</id>
    <published>2022-03-11T00:01:02.000Z</published>
    <updated>2022-04-07T14:55:03.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RFC6328-Time-Based-One-Time-Password-TOTP"><a href="#RFC6328-Time-Based-One-Time-Password-TOTP" class="headerlink" title="RFC6328: Time Based One-Time Password (TOTP)"></a>RFC6328: Time Based One-Time Password (TOTP)</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>最近做到的课题需要我利用<a href="https://datatracker.ietf.org/doc/html/rfc6328">RFC6328</a>将自己的邮箱信息加密，作为账号密码发送给对方的服务器。中文全网对于RFC6328的文章较少，在此稍微记载下学习的过程与心得。</p><p>Go写的TOTP库 <a href="https://github.com/xiaogeamadeus/gototp">gototp</a></p><h3 id="TOTP是什么？"><a href="#TOTP是什么？" class="headerlink" title="TOTP是什么？"></a>TOTP是什么？</h3><p>TOTP指基于时间的一次性密码。TOTP是基于OTP (One-Time Password, 一次性密码)的扩展。在RFC4226中，定义了一种基于HMAC的一次性密码，被命名为HOTP。HOTP算法是基于事件的，对其来说移动因子是一个事件计数器。而在TOTP当中，移动因子建立在了一个时间值上。该算法通过利用时间值，提供了一个短命的OTP值，可以有效提高安全性。</p><h3 id="HOTP算法"><a href="#HOTP算法" class="headerlink" title="HOTP算法"></a>HOTP算法</h3><p>HOTP(HMAC-based One-Time Password, RFC4226)算法是基于HMAC-SHA-1算法的，该算法公式如下所示。</p><p>HOTP(K, C) = Truncate(HMAC-SHA-1(K, C))</p><p>其中Truncate代表可以将HMAC-SHA-1转换为HOTP值的函数，K代表共享的秘密，C代表计数器值。</p><p>换言之，想要得到HOTP密码，有如下几个先决条件：</p><ol><li>知道Truncate函数。</li><li>服务器端与客户端有共享的秘密。</li><li>用相同的计数器方法。</li></ol><h3 id="HOTP算法与TOTP算法的区别"><a href="#HOTP算法与TOTP算法的区别" class="headerlink" title="HOTP算法与TOTP算法的区别"></a>HOTP算法与TOTP算法的区别</h3><p>TOTP算法是HOTP算法基于时间的变体。在TOTP算法中，计数器值C被替换为了由时间参考和时间步长得出的值T。首先你要输入现在的Unixtime，然后减去所设置的T0。实际情况下将时间精确到每秒是无法实现的，一般会提供一个步长。</p><p>TOTP可以使用HMAC-SHA-256/512函数，不同于HOTP算法的HMAC-SHA-1函数</p><h3 id="TOTP算法要求"><a href="#TOTP算法要求" class="headerlink" title="TOTP算法要求"></a>TOTP算法要求</h3><p>R1: The prover (e.g., token, soft token) and verifier (authentication or validation server) MUST know or be able to derive the current Unix time (i.e., the number of seconds elapsed since midnight UTC of January 1, 1970) for OTP generation. See [UT] for a more detailed definition of the commonly known “Unix time”. The precision of the time used by the prover affects how often the clock synchronization should be done; see Section 6.</p><p>（服务器端与客户端均能得知现在的Unix时间）</p><p>R2: The prover and verifier MUST either share the same secret or the knowledge of a secret transformation to generate a shared secret.</p><p>（服务器端与客户端需要共享相同的秘密/共享产生共享秘密的转换的知识）</p><p>R3: The algorithm MUST use HOTP [RFC4226] as a key building block.</p><p>（算法必须使用HOTP算法来构建）</p><p>R4: The prover and verifier MUST use the same time-step value X.</p><p>（服务器端与客户端必须使用相同的步长X）</p><p>R5: There MUST be a unique secret (key) for each prover.</p><p>（每个验证者必须有一个独特的秘密（密钥））</p><p>R6: The keys SHOULD be randomly generated or derived using key derivation algorithms.</p><p>（密钥应当是随机生成/使用推导算法）</p><p>R7: The keys MAY be stored in a tamper-resistant device and SHOULD be protected against unauthorized access and usage.</p><p>（密钥应当储存在安全设备中）</p><h3 id="TOTP算法详解"><a href="#TOTP算法详解" class="headerlink" title="TOTP算法详解"></a>TOTP算法详解</h3><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>K代表服务器端与客户端共同了解的秘密。</p><p>X代表以秒为单位的时间步长（默认值X=30秒），是一个系统参数。</p><p>T0是开始计算时间步长的Unix时间（缺省值为0，即Unix epoch，1970年1月1日），也是一个系统参数。</p><h4 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h4><p>我们将TOTP定义为HOTP(K, T), T是一个整数，代表初始计数器时间T0和当前Unix时间之间的时间步数。</p><blockquote><p>TOTP(K, T0, X) = HOTP(K, T(T0, X))</p><p>T(T0, X) = (CurrentUnixTime - T0) / X</p></blockquote><h3 id="TOTP算法实装"><a href="#TOTP算法实装" class="headerlink" title="TOTP算法实装"></a>TOTP算法实装</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gototp<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TOTP</span><span class="hljs-params">(k <span class="hljs-type">string</span>, t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>{<br><span class="hljs-keyword">return</span> HOTP(k, T(T0, x))<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">T</span><span class="hljs-params">(t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> (time.Now().Unix - t0)/x<br>}<br></code></pre></td></tr></tbody></table></figure><p>上述代码中，我们可以发现HOTP函数并未被定义。所以我们还需要对于HOTP进行定义。</p><h3 id="HOTP算法实装"><a href="#HOTP算法实装" class="headerlink" title="HOTP算法实装"></a>HOTP算法实装</h3><p>想要求出HOTP，其实大体只需要三步。</p><ol><li>用Key与Count求出HMAC-SHA1的值。</li><li>生成4个字节的字符串</li><li>计算HOTP值</li></ol><p>我们来逐一分析一下</p><h4 id="1-求解HMAC-SHA1的值"><a href="#1-求解HMAC-SHA1的值" class="headerlink" title="1. 求解HMAC-SHA1的值"></a>1. 求解HMAC-SHA1的值</h4><p>HMAC是密钥相关的哈希计算消息认证码（Hash-based Message Authentication Code）在多种网络协议（如SSL）中得到了广泛使用。通过使用哈希函数，可以从Key和Message中生成认证码。</p><p>假设HMAC-SHA1的值为HS，计算公式如下所示：</p><blockquote><p>HS = HMAC-SHA-1(K, C)</p></blockquote><p>K：共同秘密key</p><p>C：Message，在HOTP函数中为count中的值</p><p>对于Golang来说，HMAC和SHA1都有标准包可以引用，HMAC为<code>crypto/hmac</code>、SHA1为<code>crypto/sha1</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HMACSHA1</span><span class="hljs-params">(k, c []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span>{<br>mac := hmac.New(sha1.New, k)<br>mac.Write(c)<br><span class="hljs-keyword">return</span> mac.Sum(<span class="hljs-literal">nil</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><p>对于Golang来说，HMAC是用<code>has.Hash</code>实装的，利用<code>hmac.New(func()has.Hash, []byte)</code>可以得到哈希函数对应的对象。这样我们就成功的计算出了HS值。</p><p>注；对于SHA1来说，存储空间最大为160bit，最大支持20文字的字符串。</p><h4 id="2-生成一个4byte的字符串"><a href="#2-生成一个4byte的字符串" class="headerlink" title="2. 生成一个4byte的字符串"></a>2. 生成一个4byte的字符串</h4><p>下一步，则是利用第一步计算出的HMAC值，制作一个4byte长度的字符串。</p><blockquote><p>Sbits = DT(HS)</p></blockquote><p>首先计算<code>offsetbits</code>，这是HS的20个字中最后的4bit。</p><p>由于Go语言处理的是字节串(Byte String)，所以当我取出20个字的最后一个字时，取出的其实是一个8bit的数字，由于我们只需要最后的4bit，所以一般情况下给到的结果是（0000xxxx）前四位bit被屏蔽了。同时，由于go没有二进制的字符，所以我们实际上表示会使用16进制。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">offsetbits := hs[<span class="hljs-number">19</span>] &amp; <span class="hljs-number">0xF</span><br><span class="hljs-comment">// 0x后面的数为16进制</span><br><span class="hljs-comment">// &amp; 位and运算 同1为1</span><br></code></pre></td></tr></tbody></table></figure><p>下一步求解<code>offset</code>。</p><p><code>offset</code>可以将<code>offsetbits</code>作为数值取出。</p><p>并没有什么特别的变换，仅仅是直接将byte列作为Integer读出。（因为<code>offsetbits</code>是4bit，所以<code>offset</code>这个值为0-15）</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">offset := <span class="hljs-type">int</span>(offsetbits)<br></code></pre></td></tr></tbody></table></figure><p>接下来，将HS的第<code>offset</code>位开始之后4个文字拿出来，赋值给<code>p</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p := hs[offset:offset + <span class="hljs-number">4</span>]<br></code></pre></td></tr></tbody></table></figure><p>然后提取<code>p</code>（32bit）末尾的31bit（0xx…..xx(31个x)）</p><p>这也是利用mask来做计算的，换句话说与7FFFFFFF做and运算就可以。</p><p>当然，由于用byte列做mask会稍微有些麻烦，所以可以先将<code>[]byte</code>变换为<code>int</code>然后做mask。</p><p>由于Go语言不支持直接变换，所以借用一个包<code>encoding/binary</code></p><p>总结一下第二步所做的工作。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Truncate 函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DT</span><span class="hljs-params">(hs []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> {<br>offsetbits := hs[<span class="hljs-number">19</span>] &amp; <span class="hljs-number">0xF</span><br>offset := <span class="hljs-type">int</span>(offsetbits)<br>p := hs[offset : offset+<span class="hljs-number">4</span>]<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(binary.BigEndian.Uint32(p)) &amp; <span class="hljs-number">0x7FFFFFFF</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="3-计算HOTP的值"><a href="#3-计算HOTP的值" class="headerlink" title="3. 计算HOTP的值"></a>3. 计算HOTP的值</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReductionModulo</span><span class="hljs-params">(snum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(<span class="hljs-type">int64</span>(snum) % <span class="hljs-type">int64</span>(math.Pow10(g.Digit)))<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="HOTP算法总结"><a href="#HOTP算法总结" class="headerlink" title="HOTP算法总结"></a>HOTP算法总结</h4><p>最后将HOTP函数构建一下，将上面的步骤套入。</p><p>再次回顾一下HOTP函数</p><blockquote><p>HOTP(K, C) = Truncate(HMAC - SHA- 1(K, C))</p></blockquote><p>Truncate函数是用上面的<code>DT</code>实现的</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HOTP</span><span class="hljs-params">(k, c []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span>{<br><span class="hljs-keyword">return</span> DT(HMACSHA1(k, c))<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="联合TOTP和HOTP"><a href="#联合TOTP和HOTP" class="headerlink" title="联合TOTP和HOTP"></a>联合TOTP和HOTP</h3><p>完成HOTP函数的构建之后，我们要想办法将其应用在TOTP之中。</p><p>之前我们构建的TOTP函数如下所示</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TOTP</span><span class="hljs-params">(k <span class="hljs-type">string</span>, t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> HOTP(k, T(T0, x))<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">T</span><span class="hljs-params">(t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> (time.Now().Unix - t0) / x<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上，<code>T(t0, x)</code>的返回值是<code>int</code>，是无法在<code>func HOTP(k, c []byte) int</code>中使用的，所以要对HOTP函数进行微调。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HOTP</span><span class="hljs-params">(k []<span class="hljs-type">byte</span>, c <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>{<br>cb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br>binary.BigEndian.PutUint64(cb, c)<br><span class="hljs-keyword">return</span> DT(HMACSHA1(k, cb))<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，我们完成了TOTP算法的基础实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RFC6328-Time-Based-One-Time-Password-TOTP&quot;&gt;&lt;a href=&quot;#RFC6328-Time-Based-One-Time-Password-TOTP&quot; class=&quot;headerlink&quot; title=&quot;RFC6328: T</summary>
      
    
    
    
    
    <category term="Project-Web" scheme="http://example.com/tags/Project-Web/"/>
    
  </entry>
  
  <entry>
    <title>Sending HTTP Request with Golang</title>
    <link href="http://example.com/2022/03/10/Sending-HTTP-Request-with-Golang/"/>
    <id>http://example.com/2022/03/10/Sending-HTTP-Request-with-Golang/</id>
    <published>2022-03-10T07:10:53.000Z</published>
    <updated>2022-04-07T14:55:25.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-way-to-send-a-HTTP-request-with-golang"><a href="#The-way-to-send-a-HTTP-request-with-golang" class="headerlink" title="The way to send a HTTP request with golang"></a>The way to send a HTTP request with golang</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"encoding/base64"</span><br><br><span class="hljs-string">"github.com/imroc/req/v3"</span><br><span class="hljs-string">"github.com/jltorresm/otpgo"</span><br><span class="hljs-string">"github.com/jltorresm/otpgo/config"</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>t := otpgo.TOTP{<br>Key: <span class="hljs-string">"wang.tianchen333@gmail.comHENNGECHALLENGE003"</span>,<br>Algorithm: config.HmacSHA512,<br>}<br>token, _ := t.Generate()<br>token1 := <span class="hljs-string">"wang.tianchen333@gmail.com"</span> +<span class="hljs-string">":"</span> + token<br>auto := <span class="hljs-string">"basic "</span> + base64.StdEncoding.EncodeToString([]<span class="hljs-type">byte</span>(token1))<br><br>user := &amp;User{github: <span class="hljs-string">"https://gist.github.com/xiaogeamadeus/ad9d74723a99a882c850eabb66c51d9d"</span>,<br>                  contact: <span class="hljs-string">"wang.tianchen333@gmail.com"</span>,<br>  solution: <span class="hljs-string">"golang"</span>}<br>client := req.C().EnableDumpAllWithoutResponse()<br>client.R().<br>    SetHeaders(<span class="hljs-string">"Authorization"</span>, auto,<br>           <span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>,).<br>    SetBody(user).<br>    Post(<span class="hljs-string">"https://api.challenge.hennge.com/challenges/003"</span>)<br><br>}<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {<br>github <span class="hljs-type">string</span> <span class="hljs-string">`json:"github_url"`</span><br>contact <span class="hljs-type">string</span> <span class="hljs-string">`json:"contact_email"`</span><br>solution <span class="hljs-type">string</span> <span class="hljs-string">`json:"solution_language"`</span><br>}<br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">2022</span>/<span class="hljs-number">03</span>/<span class="hljs-number">12</span> <span class="hljs-number">20</span><span class="hljs-punctuation">:</span><span class="hljs-number">53</span><span class="hljs-punctuation">:</span><span class="hljs-number">40.763848</span> DEBUG <span class="hljs-punctuation">[</span>req<span class="hljs-punctuation">]</span> GET https<span class="hljs-punctuation">:</span><span class="hljs-comment">//api.challenge.hennge.com/challenges/003</span><br><span class="hljs-punctuation">:</span>authority<span class="hljs-punctuation">:</span> api.challenge.hennge.com<br><span class="hljs-punctuation">:</span>method<span class="hljs-punctuation">:</span> GET<br><span class="hljs-punctuation">:</span>path<span class="hljs-punctuation">:</span> /challenges/<span class="hljs-number">003</span><br><span class="hljs-punctuation">:</span>scheme<span class="hljs-punctuation">:</span> https<br>user-agent<span class="hljs-punctuation">:</span> Mozilla/<span class="hljs-number">5.0</span> (Macintosh; Intel Mac OS X <span class="hljs-number">10</span>_15_7) AppleWebKit/<span class="hljs-number">537.36</span> (KHTML<span class="hljs-punctuation">,</span> like Gecko) Chrome/<span class="hljs-number">97.0</span><span class="hljs-number">.4692</span><span class="hljs-number">.71</span> Safari/<span class="hljs-number">537.36</span><br>accept-encoding<span class="hljs-punctuation">:</span> gzip<br><br><span class="hljs-punctuation">:</span>status<span class="hljs-punctuation">:</span> <span class="hljs-number">403</span><br>content-type<span class="hljs-punctuation">:</span> application/json<br>content-length<span class="hljs-punctuation">:</span> <span class="hljs-number">68</span><br>date<span class="hljs-punctuation">:</span> Sat<span class="hljs-punctuation">,</span> <span class="hljs-number">12</span> Mar <span class="hljs-number">2022</span> <span class="hljs-number">11</span><span class="hljs-punctuation">:</span><span class="hljs-number">53</span><span class="hljs-punctuation">:</span><span class="hljs-number">42</span> GMT<br>x-amzn-requestid<span class="hljs-punctuation">:</span> <span class="hljs-number">2492</span>fed6-b665<span class="hljs-number">-4</span>d3e-becb<span class="hljs-number">-0532</span>ed6fb218<br>access-control-allow-origin<span class="hljs-punctuation">:</span> https<span class="hljs-punctuation">:</span><span class="hljs-comment">//challenge.hennge.com</span><br>access-control-allow-headers<span class="hljs-punctuation">:</span> Content-Type<span class="hljs-punctuation">,</span>X-Amz-Date<span class="hljs-punctuation">,</span>Authorization<span class="hljs-punctuation">,</span>X-Api-Key<span class="hljs-punctuation">,</span>X-Amz-Security-Token<br>x-amzn-errortype<span class="hljs-punctuation">:</span> MissingAuthenticationTokenException<br>x-amz-apigw-id<span class="hljs-punctuation">:</span> O3p3EH04NjMFdIQ=<br>access-control-allow-methods<span class="hljs-punctuation">:</span> GET<span class="hljs-punctuation">,</span>OPTIONS<span class="hljs-punctuation">,</span>POST<span class="hljs-punctuation">,</span>PUT<br>x-cache<span class="hljs-punctuation">:</span> Error from cloudfront<br>via<span class="hljs-punctuation">:</span> <span class="hljs-number">1.1</span> e2f427863e6bdb72ad8bed72b596d81e.cloudfront.net (CloudFront)<br>x-amz-cf-pop<span class="hljs-punctuation">:</span> OSL50-P1<br>x-amz-cf-id<span class="hljs-punctuation">:</span> nLWbqmaTIGAh2btKEQOFDkk5LDTgu6DBtboJS9a-OCPfaEZ08ubPqQ==<br><br><span class="hljs-punctuation">{</span><br>     <span class="hljs-attr">"message"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"User is not authorized to access this resource"</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">"github_url"</span>: <span class="hljs-string">"https://gist.github.com/xiaogeamadeus/ad9d74723a99a882c850eabb66c51d9d"</span>,<span class="hljs-string">"contact_email"</span>: <span class="hljs-string">"wang.tianchen333@gmail.com"</span>,<span class="hljs-string">"solution_language"</span>: <span class="hljs-string">"golang"</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">{<span class="hljs-string">"github_url"</span>:<span class="hljs-string">"https://gist.github.com/hennge/b859bd12e7a7fb418141"</span>,<span class="hljs-string">"contact_email"</span>:<span class="hljs-string">"ninja@example.com"</span>,<span class="hljs-string">"solution_language"</span>:<span class="hljs-string">"golang"</span>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-way-to-send-a-HTTP-request-with-golang&quot;&gt;&lt;a href=&quot;#The-way-to-send-a-HTTP-request-with-golang&quot; class=&quot;headerlink&quot; title=&quot;The way </summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>Gogee_Day2 コンテキスト</title>
    <link href="http://example.com/2022/03/09/Gogee-Day2-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88/"/>
    <id>http://example.com/2022/03/09/Gogee-Day2-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88/</id>
    <published>2022-03-09T11:03:59.000Z</published>
    <updated>2022-04-07T14:54:21.461Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文仅为个人学习笔记，无任何版权。</p><p>本部分主要内容：</p><ol><li>将router独立出来，方便之后增强。</li><li>设计context，封装Request和Response，提供对JSON（JavaScript Object Notation）、HTML等返回类型的支持。</li></ol><h2 id="コンテキストの設計"><a href="#コンテキストの設計" class="headerlink" title="コンテキストの設計"></a>コンテキストの設計</h2><h4 id="必要がある？"><a href="#必要がある？" class="headerlink" title="必要がある？"></a>必要がある？</h4><ol><li>对于web服务来说，无非就是根据Request<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但这两个对象所提供的API太细了，比如，如果我们想要构建一个完整的Response，需要考虑Header，Body，而Header包含了状态码 (StatusCode)，消息类型(ContentType) 等几乎每次请求都要设置的信息。所以如果不进行有效的封装，使用这个框架的用户需要写大量重复且复杂的代码，还容易出错。所以说对于一个好的框架而言，能够高效的构造出HTTP响应是一个关键点。</li><li>针对使用场景来说，封装<code>*http.Request</code>和<code>http.ResponseWriter</code>的方法，简化相关port的调用只是设计Context原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态router<code>/hello/:name</code>，参数<code>:name</code>的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context可以随着每一个请求的出现而产生，也随着请求的结束而销毁。所以设计Context结构，我们可以将复杂性和扩展性留在内部，对外简化了port和router的处理函数；要实现的中间件、参数都统一使用Context实例，就像一个百宝箱，可以在其中找到任何东西。</li></ol><h4 id="具体的に実現する"><a href="#具体的に実現する" class="headerlink" title="具体的に実現する"></a>具体的に実現する</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gogee<br><br><span class="hljs-keyword">import</span>(<br><span class="hljs-string">"encoding/json"</span><br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-keyword">type</span> H <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>{}<br><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span>{<br><span class="hljs-comment">//origin objects</span><br>Writer http.ResponseWriter<br>Req    *http.Request<br><span class="hljs-comment">//request info</span><br>Path <span class="hljs-type">string</span><br>Method <span class="hljs-type">string</span><br><span class="hljs-comment">//response info</span><br>StatusCode <span class="hljs-type">int</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newContext</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> *Context{<br><span class="hljs-keyword">return</span> &amp;Context{<br>Writer: w,<br>Req:    req,<br>Path:   req.URL.Path,<br>Method: req.Method,<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> PostForm(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span>{<br><span class="hljs-keyword">return</span> c.Req.FormValue(key)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Query(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span>{<br><span class="hljs-keyword">return</span> c.Req.URL.Query().Get(key)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Status(code <span class="hljs-type">int</span>) {<br>c.StatusCode = code<br>c.Writer.WriteHeader(code)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SetHeader(key <span class="hljs-type">string</span>, value <span class="hljs-type">string</span>){<br>c.Writer.Header().Set(key, value)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> String(code <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, values ...<span class="hljs-keyword">interface</span>{}){<br>c.SetHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"text/plain"</span>)<br>c.Status(code)<br>c.Writer.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(format, values...)))<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> JSON(code <span class="hljs-type">int</span>, obj <span class="hljs-keyword">interface</span>{}){<br>c.SetHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>)<br>c.Status(code)<br>encoder := json.NewEncoder(c.Writer)<br><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span>{<br>http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Data(code <span class="hljs-type">int</span>, data []<span class="hljs-type">byte</span>){<br>c.Status(code)<br>c.Writer.Write(data)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, html <span class="hljs-type">string</span>){<br>c.SetHeader(<span class="hljs-string">"Content-Type"</span>,<span class="hljs-string">"text/html"</span>)<br>c.Status(code)<br>c.Writer.Write([]<span class="hljs-type">byte</span>(html))<br>}<br></code></pre></td></tr></tbody></table></figure><p>第一步给<code>map[string]interface{}</code>起别名<code>gogee.H</code>这样在构建JSON数据时更加简洁。</p><p><code>Context</code>结构目前只包含<code>http.ResponseWriter</code>和<code>*http.Request</code>不过同时提供了对于Method/Path等request的常用属性的直接访问。</p><p>代码提供了访问Query和PostForm参数的方法。</p><p>代码提供了快速构造String/Data/JSON/HTML响应的方法。</p><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>我们将路由相关的方法和结构提取出来，放到了一个新的文件<code>router.go</code>中，方便我们下一次对于router的功能进行增强，比如提供动态路由的支持。同时，router的handle方法做了一个细微的调整，将handler的参数变为了Context。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gogee<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-keyword">type</span> router <span class="hljs-keyword">struct</span> {<br>handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouter</span><span class="hljs-params">()</span></span> *router {<br><span class="hljs-keyword">return</span> &amp;router{handlers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc)}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>key := method + <span class="hljs-string">"_"</span> + pattern<br>r.handlers[key] = handler<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) {<br>key := c.Method + <span class="hljs-string">"_"</span> + c.Path<br><span class="hljs-keyword">if</span> handler, ok := r.handlers[key]; ok {<br>handler(c)<br>} <span class="hljs-keyword">else</span> {<br>c.String(http.StatusNotFound, <span class="hljs-string">"404 NOT FOUND: %s\n"</span>, c.Path)<br>}<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="框架入口"><a href="#框架入口" class="headerlink" title="框架入口"></a>框架入口</h4><p>在修改了router并且增加了context部分之后，我们可以大幅度缩减<code>gogee.go</code>文件的内容。因为一些复杂的东西已经被放在<code>router.go</code>和<code>Context.go</code>之中了。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gogee<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"log"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-comment">// HandlerFunc defines the request handler used by Gogee</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span><br><br><span class="hljs-comment">// Engine implement the interface of ServeHTTP</span><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> {<br>router *router<br>}<br><br><span class="hljs-comment">// New is the constructor of Gogee.Engine</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine {<br><span class="hljs-keyword">return</span> &amp;Engine{router: newRouter()}<br>}<br><br><span class="hljs-comment">// addRoute is the way to add something to route</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>log.Printf(<span class="hljs-string">"Route %4s - %s"</span>, method, pattern)<br>engine.router.addRoute(method, pattern, handler)<br>}<br><br><span class="hljs-comment">// GET defines the method to add GET request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>engine.addRoute(<span class="hljs-string">"GET"</span>, pattern, handler)<br>}<br><br><span class="hljs-comment">//POST defines the method to POST request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>engine.addRoute(<span class="hljs-string">"POST"</span>, pattern, handler)<br>}<br><br><span class="hljs-comment">//Run definesd the method to start a http server</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>) {<br><span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>}<br><br><span class="hljs-comment">// To use the ListenAndServe, we need to set a ServeHTTP struct</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) {<br>c := newContext(w, req)<br>engine.router.handle(c)<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>当然最重要的还是通过实现了ServeHTTP的接口之后，接管了所有的HTTP请求。</p><p>最后，稍微修改一下<code>main.go</code>文件。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"gogee"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>r := gogee.New()<br>r.GET(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gogee.Context)</span></span> {<br>c.HTML(http.StatusOK, <span class="hljs-string">"&lt;h1&gt;Hello Gogee&lt;/h1&gt;"</span>)<br>})<br><br>r.GET(<span class="hljs-string">"/hello"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gogee.Context)</span></span> {<br>c.String(http.StatusOK, <span class="hljs-string">"hello %s, you're at %s\n"</span>, c.Query(<span class="hljs-string">"name"</span>), c.Path)<br>})<br><br>r.POST(<span class="hljs-string">"/login"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gogee.Context)</span></span> {<br>c.JSON(http.StatusOK, gogee.H{<br><span class="hljs-string">"username"</span>: c.PostForm(<span class="hljs-string">"username"</span>),<br><span class="hljs-string">"password"</span>: c.PostForm(<span class="hljs-string">"password"</span>),<br>})<br>})<br><br>r.Run(<span class="hljs-string">":9999"</span>)<br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;p&gt;本部分主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将router独立出来，方便之后增强。&lt;/li&gt;
&lt;li&gt;设计context，封装Request和Response，提供对JSON（JavaScript Object Nota</summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>Terminal for Mac</title>
    <link href="http://example.com/2022/03/09/Terminal-for-Mac/"/>
    <id>http://example.com/2022/03/09/Terminal-for-Mac/</id>
    <published>2022-03-09T01:15:29.000Z</published>
    <updated>2022-04-17T01:01:58.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Basic-Operation-of-Shell-for-Mac"><a href="#The-Basic-Operation-of-Shell-for-Mac" class="headerlink" title="The Basic Operation of Shell for Mac"></a>The Basic Operation of Shell for Mac</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><h3 id="更改目录："><a href="#更改目录：" class="headerlink" title="更改目录："></a>更改目录：</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">cd &lt;Path&gt; //找到对应路径<br>cd .. //移动到上一级目录<br>pushd &lt;Path&gt; //记住来源的同时移动到其他目录，popd 返回来源<br></code></pre></td></tr></tbody></table></figure><h3 id="目录列举"><a href="#目录列举" class="headerlink" title="目录列举"></a>目录列举</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls //列举出当前目录下所有的文件和子目录<br>   //可以使用通配符 * 来缩小搜索范围。<br>   //例1: 列举所有以".java"结尾的文件<br>     ls *.java<br>   //例2：列举所有以"F"开头，".java"结尾的文件<br>     ls F*.java<br></code></pre></td></tr></tbody></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir //系统<br>mkdir books //示例<br></code></pre></td></tr></tbody></table></figure><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm //系统<br>rm somefile.java //示例<br></code></pre></td></tr></tbody></table></figure><h3 id="移除目录"><a href="#移除目录" class="headerlink" title="移除目录"></a>移除目录</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -r //系统<br>rm -r books //示例<br></code></pre></td></tr></tbody></table></figure><h3 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">!! //重复上条命令<br>!n //重复倒数第n条命令<br></code></pre></td></tr></tbody></table></figure><h3 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">history //系统<br></code></pre></td></tr></tbody></table></figure><h3 id="文件解压"><a href="#文件解压" class="headerlink" title="文件解压"></a>文件解压</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">//Linux/Mac 都有命令行解压程序 unzip，你可以通过互联网为 Windows 安装命令行解压程序 unzip。<br>//图形界面下（Windows 资源管理器，Mac Finder，Linux Nautilus 或其他等效软件）右键单击该文件，<br>//在 Mac 上选择“open”<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-Basic-Operation-of-Shell-for-Mac&quot;&gt;&lt;a href=&quot;#The-Basic-Operation-of-Shell-for-Mac&quot; class=&quot;headerlink&quot; title=&quot;The Basic Operation </summary>
      
    
    
    
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Git基礎</title>
    <link href="http://example.com/2022/03/09/Git%E5%9F%BA%E7%A4%8E/"/>
    <id>http://example.com/2022/03/09/Git%E5%9F%BA%E7%A4%8E/</id>
    <published>2022-03-09T01:10:22.000Z</published>
    <updated>2022-04-07T14:53:57.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gitを使って方法（Mac）"><a href="#Gitを使って方法（Mac）" class="headerlink" title="Gitを使って方法（Mac）"></a>Gitを使って方法（Mac）</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><h2 id="建立仓库，并与git连接"><a href="#建立仓库，并与git连接" class="headerlink" title="建立仓库，并与git连接"></a>建立仓库，并与git连接</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li><p>github上新建一个repository</p></li><li><p>复制repository的ssh地址</p></li><li><p>打开终端输入命令</p><p><code>cd /users/xiaogeamadeus/mygo/src</code></p></li><li><p>然后克隆项目</p><p><code>git clone ssh (copy from github)</code></p></li><li><p>在vscode新建一个工程，路径为刚克隆的文件夹</p></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li><p>本地创建一个repository</p><p><code>mkdir projectname</code></p><p><code>cd projectname</code></p></li><li><p>通过<code>git init</code>命令将这个projectname目录变为git可以管理的目录</p><p><code>git init</code></p></li></ol><h2 id="如何提交修改"><a href="#如何提交修改" class="headerlink" title="如何提交修改"></a>如何提交修改</h2><ol><li><p>切换到项目文件夹所在的路径</p><p>``cd /users/xiaogeamadeus/mygo/project(created)`</p></li><li><p>输入</p><p><code>git add .</code> 将文件添加到仓库（.代表提交所有文件）</p><p><code>git commit -m "day1"</code> 把文件提交到暂存区（””内为本次提交的说明，用于方便找到提交记录）</p><p><code>git push</code> 上传到github</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Gitを使って方法（Mac）&quot;&gt;&lt;a href=&quot;#Gitを使って方法（Mac）&quot; class=&quot;headerlink&quot; title=&quot;Gitを使って方法（Mac）&quot;&gt;&lt;/a&gt;Gitを使って方法（Mac）&lt;/h2&gt;&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p</summary>
      
    
    
    
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
  </entry>
  
</feed>
