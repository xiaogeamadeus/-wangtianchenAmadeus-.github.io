<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WANG Tianchen</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-06T01:58:32.328Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scanner &amp; BufferedReader 用法详解</title>
    <link href="http://example.com/2022/04/06/Scanner-BufferReader-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/04/06/Scanner-BufferReader-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-06T01:29:31.000Z</published>
    <updated>2022-04-06T01:58:32.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scanner-amp-BufferedReader用法详解"><a href="#Scanner-amp-BufferedReader用法详解" class="headerlink" title="Scanner &amp; BufferedReader用法详解"></a>Scanner &amp; BufferedReader用法详解</h2><p>这段时间一直没把java的输入写明白，在该记事里进行一个总结</p><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>Scanner使用分隔符模式将其输入分解为标记，默认情况下是利用空白进行分割的。之后可以使用不同的<code>next</code>方法将得到的标记转换为不同类型的值。</p><p>Scanner位于<code>java.util</code>包中，Scanner的具体用法为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">//通过new创建一个Scanner对象</span><br><span class="hljs-comment">//传入一个System.in参数来读取输入</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//输入一个Integer</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextInt(); <br><span class="hljs-comment">//读取一整行字符串（以Enter结尾进行分界）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextLine();<br><span class="hljs-comment">//读取一组字符串（以空格/Tab/Enter进行分界，只要遇到其中之一就返回下一个 //输入）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.next();<br></code></pre></td></tr></tbody></table></figure><h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>BufferedReader位于<code>java.io</code>包中，读取数据比较固定，这样格式也比较单一。只要记住就这一读取数据的方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><br><span class="hljs-comment">//BufferedReader的readLine()方法必须处理java.o.IOException异常，所以需要在Public static void main后面补充处理。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {<br>  <span class="hljs-comment">//创建BufferReader对象，从键盘读入</span><br>  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>  <span class="hljs-comment">//创建BufferReader对象，从文本文件读入</span><br>  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">"test.txt"</span>));<br><br>  <span class="hljs-comment">//读取一行数据并用空格分隔，存入字符串数组</span><br>  String[] temp = br1.readLine().split(<span class="hljs-string">""</span>);<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>BufferedReader读取的数据都以字符串的形式存储，如果需要其他形式的数据，需要进行强制转换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Scanner-amp-BufferedReader用法详解&quot;&gt;&lt;a href=&quot;#Scanner-amp-BufferedReader用法详解&quot; class=&quot;headerlink&quot; title=&quot;Scanner &amp;amp; BufferedReader用法详解</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/2022/04/04/%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/04/04/%E9%93%BE%E8%A1%A8/</id>
    <published>2022-04-04T04:15:56.000Z</published>
    <updated>2022-04-04T04:30:50.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表题型刷题总结"><a href="#链表题型刷题总结" class="headerlink" title="链表题型刷题总结"></a>链表题型刷题总结</h1><h4 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h4><p>一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null</p><p>链表的头节点为head</p><h4 id="链表的类型："><a href="#链表的类型：" class="headerlink" title="链表的类型："></a>链表的类型：</h4><ol><li>单链表</li><li>双链表</li><li>循环链表</li></ol><h4 id="链表在内存中的储存方式"><a href="#链表在内存中的储存方式" class="headerlink" title="链表在内存中的储存方式"></a>链表在内存中的储存方式</h4><p>与数组不同，链表在内存中<strong>不是连续分布。</strong></p><p>链表是通过指针域的指针链接在内存的各个节点，所以链表中的节点在内存中不是连续分布的，而是三楼缘分不在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><h4 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-comment">// 结点的值</span><br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-comment">// 下一个结点</span><br>    ListNode next;<br><br>    <span class="hljs-comment">// 节点的构造函数(无参)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> {<br>    }<br><br>    <span class="hljs-comment">// 节点的构造函数(有一个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> {<br>        <span class="hljs-built_in">this</span>.val = val;<br>    }<br><br>    <span class="hljs-comment">// 节点的构造函数(有两个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> {<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    }<br>}<br><br>List&lt;&gt; xxx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></tbody></table></figure><h4 id="删除节点："><a href="#删除节点：" class="headerlink" title="删除节点："></a>删除节点：</h4><p>只要将被删除节点的前一个节点的指针，指向后一个节点就可以了。如果要删除第n个节点，可以将第n-1个节点的指针指到第n+1个节点，java会自动释放那块内存。</p><h4 id="添加节点："><a href="#添加节点：" class="headerlink" title="添加节点："></a>添加节点：</h4><p>同理，修改指针即可。</p><p>可以看出链表的增添/删除都是O(1)的操作，不会影响到其他节点。但是，如果要删除第c个节点，需要从头节点找到第c-1个节点，查找的时间复杂度为O(c)</p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>链表删除/插入：O(1)</p><p>链表查找：          O(n)</p><p>数组删除/插入：O(n)</p><p>数组查找：          O(1)</p><p>数组：数据量固定，频繁查找，较少增删</p><p>链表：数据量不固定，频繁增删，较少查找</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表题型刷题总结&quot;&gt;&lt;a href=&quot;#链表题型刷题总结&quot; class=&quot;headerlink&quot; title=&quot;链表题型刷题总结&quot;&gt;&lt;/a&gt;链表题型刷题总结&lt;/h1&gt;&lt;h4 id=&quot;什么是链表？&quot;&gt;&lt;a href=&quot;#什么是链表？&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://example.com/2022/04/02/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://example.com/2022/04/02/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-04-02T10:56:03.000Z</published>
    <updated>2022-04-04T04:16:35.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组题型刷题总结"><a href="#数组题型刷题总结" class="headerlink" title="数组题型刷题总结"></a>数组题型刷题总结</h1><p>数组：存放在连续空间的相同类型元素的集合，一般不进行删除操作。</p><p>两点注意；</p><ol><li>数组下标都是从0开始</li><li>数组内存空间地址连续（增添删除都很麻烦）</li></ol><p>二维数组在系统中的存储方式</p><p>m*n的二维数组来说，一般由一个头节点指向一个长为n的一维列数组，每个列数组又作为另一个长为m的一维行数组的头节点。</p><p>并不是连续地址空间</p><p>一般看到链表/子串/数组之类的题，直接上双指针就行</p><p>常用方法：</p><ol><li>二分法</li><li>双指针</li><li>滑动窗口</li><li>模拟行为</li></ol><h3 id="1-二分法"><a href="#1-二分法" class="headerlink" title="1. 二分法"></a>1. 二分法</h3><p>704, 35, 34, 69, 367</p><p>限制条件：<strong>有序数组</strong>  且 <strong>无重复元素</strong></p><p>Key：边界条件的设定。在二分查找过程中，每次区间变化都遵守边界条件不变。</p><p>常用区间：[lo, hi],  [lo, hi)</p><p>注：乘法溢出时用除法处理即可。</p><p>暴力解法一般时间复杂度为O(N)</p><p>二分法一般时间复杂度为O(logN)</p><h3 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2. 双指针"></a>2. 双指针</h3><p>27, 26, 283, 844, 977</p><p>双指针技巧可以分为两类：【快慢指针】和【左右指针】。前者解决链表中的问题，比如判断链表是否包含环；后者主要解决数组（字符串）中的问题，二分查找也是左右指针的一种特殊情况。</p><p>常见的双指针问题还有移除元素/移除字符串等。</p><p>快慢指针常见问题：链表操作/找中点/归并排序/链表环</p><p>左右指针常见问题：反转数组/二分搜索</p><p>暴力解法时间复杂度一般为O(N^2)</p><p>双指针法时间复杂度一般为O(N)</p><h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h3><p>209, 904, 76</p><p>实际上滑动窗口也是一种特殊的双指针。不过因为其在<strong>子串</strong>问题中的优异表现，我将其单独作为一个部分来讲。</p><p>滑动窗口算法的大致逻辑如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; s.soze()) {<br>  <span class="hljs-comment">//增大窗口</span><br>  window.add(s[right]);<br>  right++;<br>  <br>  <span class="hljs-keyword">while</span> (window needs shrink) {<br>    <span class="hljs-comment">//缩小窗口</span><br>    window.remove(s[left]);<br>    left++;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度O(N)， 比一般的字符串暴力算法高效的多。</p><p>滑动窗口的关键在于各种细节问题。比如如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即使你明白了这些细节，也容易报错。</p><p>使用一套来自labuladong 的滑动窗口代码框架。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//需要的字符传入need</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) {<br>  need. put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>}<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (right &lt; s.length()) {<br>  <span class="hljs-comment">//c是移入窗口的字符</span><br>  <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>  <span class="hljs-comment">//右边界右移</span><br>  right++;<br>  <br>  <span class="hljs-comment">//进入窗口的一系列操作.....</span><br>  <br>  <span class="hljs-comment">//当满足时，进行窗口缩减</span><br>  <span class="hljs-keyword">while</span> (window needs shrink) {<br>    <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>    <span class="hljs-comment">//左边界右移</span><br>    left++;<br>    <br>    <span class="hljs-comment">//出窗口</span><br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-模拟行为"><a href="#4-模拟行为" class="headerlink" title="4. 模拟行为"></a>4. 模拟行为</h3><p>48， 54， 59</p><p>不涉及太多算法，单纯模拟，考验对代码的掌控能力。</p><p>循环不变量原则十分重要。</p><p>真正解决题目的代码都是简洁的，有原则性的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组题型刷题总结&quot;&gt;&lt;a href=&quot;#数组题型刷题总结&quot; class=&quot;headerlink&quot; title=&quot;数组题型刷题总结&quot;&gt;&lt;/a&gt;数组题型刷题总结&lt;/h1&gt;&lt;p&gt;数组：存放在连续空间的相同类型元素的集合，一般不进行删除操作。&lt;/p&gt;
&lt;p&gt;两点注意；&lt;/</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>OnJava8-File</title>
    <link href="http://example.com/2022/03/31/OnJava8-File/"/>
    <id>http://example.com/2022/03/31/OnJava8-File/</id>
    <published>2022-03-31T01:01:41.000Z</published>
    <updated>2022-03-31T01:26:33.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Way-to-Input-x2F-Output-File-by-Java"><a href="#The-Way-to-Input-x2F-Output-File-by-Java" class="headerlink" title="The Way to Input/Output File by Java"></a>The Way to Input/Output File by Java</h2><p>打开并读取文件对于大多数编程语言来说是非常实用的。Java8与java7新增的<code>java.nio.file</code>包以及streams与文件结合使得文件操作编程变得十分简单。</p><p>对于文件操作来说，最基本的两个组件是</p><ol><li>文件或者目录的路径；</li><li>文件本身。</li></ol><h3 id="文件和目录路径"><a href="#文件和目录路径" class="headerlink" title="文件和目录路径"></a>文件和目录路径</h3><p>一个<code>Path</code>对象表示一个文件或者目录的路径，可以跨操作系统和文件系统。</p><p><code>java.nio.file.Path</code>包含一个重载方法<code>static get()</code>，该方法接受一系列<code>String</code>字符串或一个URI作为参数，进行转换返回一个<code>Path</code>对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// files/PathInfo.java</span><br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PathInfo</span> {<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String id, Object p)</span> {<br>        System.out.println(id + <span class="hljs-string">": "</span> + p);<br>    }<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(Path p)</span> {<br>        show(<span class="hljs-string">"toString"</span>, p);<br>        show(<span class="hljs-string">"Exists"</span>, Files.exists(p));<br>        show(<span class="hljs-string">"RegularFile"</span>, Files.isRegularFile(p));<br>        show(<span class="hljs-string">"Directory"</span>, Files.isDirectory(p));<br>        show(<span class="hljs-string">"Absolute"</span>, p.isAbsolute());<br>        show(<span class="hljs-string">"FileName"</span>, p.getFileName());<br>        show(<span class="hljs-string">"Parent"</span>, p.getParent());<br>        show(<span class="hljs-string">"Root"</span>, p.getRoot());<br>        System.out.println(<span class="hljs-string">"******************"</span>);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        System.out.println(System.getProperty(<span class="hljs-string">"os.name"</span>));<br>        info(Paths.get(<span class="hljs-string">"C:"</span>, <span class="hljs-string">"path"</span>, <span class="hljs-string">"to"</span>, <span class="hljs-string">"nowhere"</span>, <span class="hljs-string">"NoFile.txt"</span>));<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"PathInfo.java"</span>);<br>        info(p);<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">ap</span> <span class="hljs-operator">=</span> p.toAbsolutePath();<br>        info(ap);<br>        info(ap.getParent());<br>        <span class="hljs-keyword">try</span> {<br>            info(p.toRealPath());<br>        } <span class="hljs-keyword">catch</span>(IOException e) {<br>           System.out.println(e);<br>        }<br>        <span class="hljs-type">URI</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> p.toUri();<br>        System.out.println(<span class="hljs-string">"URI: "</span> + u);<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">puri</span> <span class="hljs-operator">=</span> Paths.get(u);<br>        System.out.println(Files.exists(puri));<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ap.toFile(); <span class="hljs-comment">// Don't be fooled</span><br>    }<br>}<br><br><span class="hljs-comment">/* 输出:</span><br><span class="hljs-comment">Windows 10</span><br><span class="hljs-comment">toString: C:\path\to\nowhere\NoFile.txt</span><br><span class="hljs-comment">Exists: false</span><br><span class="hljs-comment">RegularFile: false</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: NoFile.txt</span><br><span class="hljs-comment">Parent: C:\path\to\nowhere</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: false</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: null</span><br><span class="hljs-comment">Root: null</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files\PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: false</span><br><span class="hljs-comment">Directory: true</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: files</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files\PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">URI: file:///C:/Users/Bruce/Documents/GitHub/onjava/</span><br><span class="hljs-comment">ExtractedExamples/files/PathInfo.java</span><br><span class="hljs-comment">true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-Way-to-Input-x2F-Output-File-by-Java&quot;&gt;&lt;a href=&quot;#The-Way-to-Input-x2F-Output-File-by-Java&quot; class=&quot;headerlink&quot; title=&quot;The Way to I</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP, UDP and Socket</title>
    <link href="http://example.com/2022/03/26/TCP-IP-UDP-and-Socket/"/>
    <id>http://example.com/2022/03/26/TCP-IP-UDP-and-Socket/</id>
    <published>2022-03-26T01:56:22.000Z</published>
    <updated>2022-03-26T02:12:39.805Z</updated>
    
    <content type="html"><![CDATA[<p>本篇旨在解决如下三个问题：</p><ol><li>什么是TCP/IP、UDP？</li><li>Socket是什么？</li><li>如何使用上述的服务？</li></ol><p>让我们开始吧！</p><h2 id="1-什么是TCP-x2F-IP、UDP？"><a href="#1-什么是TCP-x2F-IP、UDP？" class="headerlink" title="1. 什么是TCP/IP、UDP？"></a>1. 什么是TCP/IP、UDP？</h2><p>TCP/IP（Transmission Control Protocol/ Internet Protocol）即传输控制协议/网间协议。是一个工业标准的protocol集，他是为广域网（WANs）设计的。</p><p>UDP（User Data Protocal，用户数据报协议）是与TCP相对应的协议。他是属于TCP/IP协议集中的一种。</p><p>![截屏2022-03-26 11.04.16](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.04.16.png)</p><p>TCP/IP协议族包括运输层、网络层、链路层。TCP与UDP都是运用在运输层上的协议。</p><h2 id="2-Socket是什么？"><a href="#2-Socket是什么？" class="headerlink" title="2. Socket是什么？"></a>2. Socket是什么？</h2><p>在上图中，我们并未看到Socket的影子。</p><p>Socket究竟在网络服务中扮演了怎样的角色呢？</p><p>实际上Socket的位置应该在应用层与运输层之间。起到了一个将应用层传输给运输层的信息进行抽象的作用。</p><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，他是一组接口。在设计模式中，Socket其实就是一个门面模式，他可以将复杂的TCP/IP协议族隐藏在后面，提供给用户一个简单的接口信息。用户只需要让Socket去组织数据，以符合制定的协议。</p><h2 id="3-如何使用上述的服务？"><a href="#3-如何使用上述的服务？" class="headerlink" title="3. 如何使用上述的服务？"></a>3. 如何使用上述的服务？</h2><h4 id="截屏2022-03-26-11-09-35-TCP-IP-UDP-and-Socket-x2F-截屏2022-03-26-11-09-35-png"><a href="#截屏2022-03-26-11-09-35-TCP-IP-UDP-and-Socket-x2F-截屏2022-03-26-11-09-35-png" class="headerlink" title="![截屏2022-03-26 11.09.35](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.09.35.png)"></a>![截屏2022-03-26 11.09.35](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.09.35.png)</h4><p>先从服务器端讲起。服务器端先初始化Socket，然后与端口绑定（bind），对端口进行监听（Listen），调用Accept阻塞，等待客户端链接。在这时候如果有客户端初始化了一个Socket，然后连接服务器（connect），如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接受请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><p><a href="https://blog.csdn.net/pashanhu6402/article/details/96428887">原文连接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇旨在解决如下三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是TCP/IP、UDP？&lt;/li&gt;
&lt;li&gt;Socket是什么？&lt;/li&gt;
&lt;li&gt;如何使用上述的服务？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们开始吧！&lt;/p&gt;
&lt;h2 id=&quot;1-什么是TCP-x2F-IP、UDP？&quot;</summary>
      
    
    
    
    
    <category term="Project-Web" scheme="http://example.com/tags/Project-Web/"/>
    
  </entry>
  
  <entry>
    <title>gototp: A TOTP Library Written by Go</title>
    <link href="http://example.com/2022/03/16/gototp-A-TOTP-Library-Written-by-Go/"/>
    <id>http://example.com/2022/03/16/gototp-A-TOTP-Library-Written-by-Go/</id>
    <published>2022-03-15T23:48:50.000Z</published>
    <updated>2022-03-16T00:04:24.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gototp"><a href="#gototp" class="headerlink" title="gototp"></a>gototp</h1><p>A TOTP(Time Based One-Time Password, RFC6328) Library Written by Golang. </p><p><a href="https://xiaogeamadeus.github.io/2022/03/11/RFC6328-Time-Based-One-Time-Password/">The way to create this library</a></p><p><a href="https://github.com/xiaogeamadeus/gototp">Github of totp</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc6328">RFC6328</a></p><h2 id="How-to-Get-the-Library"><a href="#How-to-Get-the-Library" class="headerlink" title="How to Get the Library"></a>How to Get the Library</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/xiaogeamadeus/gototp<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gototp&quot;&gt;&lt;a href=&quot;#gototp&quot; class=&quot;headerlink&quot; title=&quot;gototp&quot;&gt;&lt;/a&gt;gototp&lt;/h1&gt;&lt;p&gt;A TOTP(Time Based One-Time Password, RFC6328) Library </summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>Gogee-Day3-Trie木ルータ</title>
    <link href="http://example.com/2022/03/14/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/"/>
    <id>http://example.com/2022/03/14/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/</id>
    <published>2022-03-14T00:47:07.000Z</published>
    <updated>2022-03-26T01:02:54.523Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要内容：1. 使用Trie树实现动态路由(dynamic route)解析。</p><p>支持两种模式<code>:name</code>和<code>*filepath*</code></p><h2 id="Trie-Tree-Router"><a href="#Trie-Tree-Router" class="headerlink" title="Trie Tree Router"></a>Trie Tree Router</h2><p>之前，我们用了一个非常简单的map结构储存了路由表(router map)，使用map存储键值对，索引非常高效，但是有一个弊端，键值对存储的方式只适用于静态路由.</p><p>如果我们想要支持<code>/hello/:name</code>这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类而非某一条固定的路由。比如<code>/hello/:name</code>，可以匹配<code>/hello/xiaogeamadeus</code>、<code>hello/tom</code>等。</p><p>动态路由有很多种实现方式，支持的规则、性能等有很大的差异。例如开源的路由实现<code>gorouter</code>支持在路由规则中嵌入正则表达式，例如<code>/p/[0-9A-Za-z]+</code>，即路径中的参数仅匹配数字和字母；另一个开源实现<code>httprouter</code>就不支持正则表达式。<code>gin</code>在早期的版本，并没有实现自己的路由，而是直接使用了httprouter，后来放弃了，自己实现了一个版本。<img src="/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/IMG_573DEF5931EE-1.jpeg" alt="IMG_573DEF5931EE-1"></p><p>实现动态路由最常用的数据结构，被称为前缀树(Trie Tree)：每一个节点的所有子节点都拥有相同的前缀。这种结构非常适用于路由匹配。例如，我们定义了如下路由规则：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/:lang/</span>doc<br><span class="hljs-regexp">/:lang/</span>tutorial<br><span class="hljs-regexp">/:lang/i</span>ntro<br>/about<br><span class="hljs-regexp">/p/</span>blog<br><span class="hljs-regexp">/p/</span>related<br></code></pre></td></tr></tbody></table></figure><p>我们用前缀树来表示的话就会变成三颗子树/:lang、/about、/p</p><p>HTTP请求的路径恰好是由<code>/</code>分隔的多段构成的，因此，每一段可以作为前缀树的一个节点。我们通过树结构查询，如果中间某一层的节点都不满足条件，那么就说明没有匹配到的路由，查询结束。</p><p>我们接下来实现的路由具有如下两个功能。</p><ol><li>参数匹配：<code>/p/:lang/doc</code>可以匹配<code>/p/c/doc</code>或者<code>/p/go/doc</code></li><li>通配符<code>*</code>。例如<code>/static/*filepath</code>，可以匹配<code>/static/fav.ico</code>，也可以匹配<code>/static/js/jQuery.js</code>，这种模式常用于静态服务器，能够递归的匹配子路径。</li></ol><h2 id="Trie木の実現"><a href="#Trie木の実現" class="headerlink" title="Trie木の実現"></a>Trie木の実現</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ttype node <span class="hljs-keyword">struct</span> {<br>  pattern <span class="hljs-type">string</span> <span class="hljs-comment">//带匹配路由，例如/p/:lang</span><br>  part <span class="hljs-type">string</span> <span class="hljs-comment">//路由中的一部分，例如:lang</span><br>  children []*node <span class="hljs-comment">//子节点，例如[doc, tutorial,intro]</span><br>  isWild <span class="hljs-type">bool</span> <span class="hljs-comment">//是否精确匹配，part含有:或*时为true</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>与普通的树不同，为了实现动态路由匹配，加上了<code>isWild</code>这个参数。即当我们匹配到<code>/p/go/doc</code>这个路由时，第一层节点，<code>p</code>精准的匹配到了<code>p</code>，第二层节点，<code>go</code>模糊匹配到<code>:lang</code>，那么将会把<code>lang</code>这个参数赋值为<code>go</code>，继续下一层匹配。我们将匹配的逻辑包装为一个辅助函数。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//第一个匹配成功的节点，用于插入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span>matchChild(part <span class="hljs-type">string</span>) *node{<br>  <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> n.children {<br>    <span class="hljs-keyword">if</span> child.part == part || child.isWild{<br>      <span class="hljs-keyword">return</span> child<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>}<br><span class="hljs-comment">// 所有匹配成功的节点，用于查找</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> matchChildren(part <span class="hljs-type">string</span>) []*node {<br>  nodes := <span class="hljs-built_in">make</span>([]*node, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> n.children {<br>    <span class="hljs-keyword">if</span> child.part == part||child.isWild{<br>      nodes = <span class="hljs-built_in">append</span>(nodes, child)<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> nodes<br>}<br></code></pre></td></tr></tbody></table></figure><p>对于路由来说，注册和匹配是最重要的。开发服务时，注册路由规则，映射handler; 访问时，匹配路由规则，查找到对应的handler。因此，Trie树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前<code>part</code>的节点，则新建一个。有一点需要注意，<code>/p/:lang/doc</code>只有在第三层节点，即<code>doc</code>节点，pattern才会设置为<code>/p/:lang/doc</code>。</p><p><code>p</code>和<code>:lang</code>节点的<code>pattern</code>属性皆为空。因此，当匹配结束时，我们可以使用<code>n.pattern == ""</code>来判断路由规则是否匹配成功。例如，<code>/p/python</code>虽能成功匹配到<code>:lang</code>，但<code>lang</code>的<code>pattern</code>值为空，因此匹配失败。查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到了<code>*</code>，匹</p><p>配失败，或者匹配到了第<code>len(parts)</code>层节点。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Trie tree's insert</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> insert(pattern <span class="hljs-type">string</span>, parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) {<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height {<br>    n.pattern = pattern<br>    <span class="hljs-keyword">return</span><br>  }<br>  <br>  part := parts[height]<br>  child := n.matchChild(part)<br>  <span class="hljs-keyword">if</span> child == <span class="hljs-literal">nil</span> {<br>    child = &amp;node{part: part, isWild: part[<span class="hljs-number">0</span>] == <span class="hljs-string">':'</span>|| part[<span class="hljs-number">0</span>] == <span class="hljs-string">'*'</span>}<br>    n.children = <span class="hljs-built_in">append</span>(n.children, child)<br>  }<br>  child.insert(pattern, parts, height+<span class="hljs-number">1</span>)<br>}<br><br><span class="hljs-comment">//Trie tree's search</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> search(parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) *node{<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="hljs-string">'*'</span>) {<br>    <span class="hljs-keyword">if</span> n.pattern == <span class="hljs-string">""</span>{<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    }<br>    <span class="hljs-keyword">return</span> n<br>  }<br>  <br>  part := parts[height]<br>  children := n.matchChildren(part)<br>  <br>  <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> children {<br>    result := child.search(parts, height+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> result != <span class="hljs-literal">nil</span> {<br>      <span class="hljs-keyword">return</span> result<br>    }<br>  }<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Trie 树的插入和查找实现之后，就可以将Trie树应用到路由之中了。使用<code>roots</code>来储存每种请求方式的Trie树根节点。使用<code>handlers</code>存储每种请求方式的<code>HandlerFunc</code>。<code>getRoute</code>函数中，还解析了<code>:</code>和<code>*</code>两种匹配符的参数，返回一个map。例如<code>/p/go/doc</code>匹配到<code>/p/:lang/doc</code>，解析结果为：<code>{lang:"go"}</code>，<code>/static/css/xiaogeamadeus.css</code>匹配到<code>/static/*filepath</code>，解析结果为<code>{file path:"css/xiaogeamadeus.css"}</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> router <span class="hljs-keyword">struct</span>{<br>  roots    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node<br>  handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>}<br><br><span class="hljs-comment">// roots key eg, roots['GET'] roots['POST']</span><br><span class="hljs-comment">// handlers key eg, handlers['GET-/p/:lang/doc'], handlers['POST-/p/book']</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouter</span><span class="hljs-params">()</span></span> *router {<br>  <span class="hljs-keyword">return</span> &amp;router{<br>    roots:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node),<br>    handlers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc),<br>  }<br>}<br><br><span class="hljs-comment">// Only one * is allowed</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePattern</span><span class="hljs-params">(pattern stirng)</span></span> []<span class="hljs-type">string</span>{<br>  vs := strings.Split(pattern, <span class="hljs-string">"/"</span>)<br>  <br>  parts := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> vs {<br>    <span class="hljs-keyword">if</span> item != <span class="hljs-string">""</span>{<br>      parts = <span class="hljs-built_in">append</span>()(parts, item)<br>      <span class="hljs-keyword">if</span> item[<span class="hljs-number">0</span>] == <span class="hljs-string">'*'</span>{<br>        <span class="hljs-keyword">break</span><br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> parts<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc){<br>  parts := parsePattern(pattern)<br>  <br>  key := method + <span class="hljs-string">"_"</span> + pattern<br>  _, ok := r.roots[method]<br>  <span class="hljs-keyword">if</span> !ok {<br>    r.roots[method] = &amp;node{}<br>  }<br>  r.roots[method].insert(pattern, parts, <span class="hljs-number">0</span>)<br>  r.handlers[key] = handler<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> getRoute(method <span class="hljs-type">string</span>, path <span class="hljs-type">string</span>) (*node, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>){<br>  searchParts := parsePattern(path)<br>  params := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>  root, ok := r.roots[method]<br>  <br>  <span class="hljs-keyword">if</span> !ok{<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>  }<br>  <br>  n := root.search(searchParts, <span class="hljs-number">0</span>)<br>  <br>  <span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> {<br>    parts : parsePattern(n.pattern)<br>    <span class="hljs-keyword">for</span> index, part := <span class="hljs-keyword">range</span> parts {<br>      <span class="hljs-keyword">if</span> part[<span class="hljs-number">0</span>] == <span class="hljs-string">':'</span>{<br>        params[part[<span class="hljs-number">1</span>:]] = searchParts[index]<br>      }<br>      <span class="hljs-keyword">if</span> parts[<span class="hljs-number">0</span>] == <span class="hljs-string">'*'</span>&amp;&amp; <span class="hljs-built_in">len</span>(part) &gt;<span class="hljs-number">1</span>{<br>        params[part[<span class="hljs-number">1</span>:]] = strings.Join(searchParts[index:],<span class="hljs-string">"/"</span>)<br>        <span class="hljs-keyword">break</span><br>      }<br>    }<br>    <span class="hljs-keyword">return</span> n, params<br>  }<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Contextとhandleの変化"><a href="#Contextとhandleの変化" class="headerlink" title="Contextとhandleの変化"></a>Contextとhandleの変化</h2><p>在HandleFunc 中，希望能够访问到解析的参数。因此，我们需要对Context对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到<code>Params</code>中，通过<code>c/Param("lang")</code>的方式获取到对应的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇主要内容：1. 使用Trie树实现动态路由(dynamic route)解析。&lt;/p&gt;
&lt;p&gt;支持两种模式&lt;code&gt;:name&lt;/code&gt;和&lt;code&gt;*filepath*&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;Trie-Tree-Router&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>RFC2617: HTTP Authentication</title>
    <link href="http://example.com/2022/03/11/RFC2617-HTTP-Authentication/"/>
    <id>http://example.com/2022/03/11/RFC2617-HTTP-Authentication/</id>
    <published>2022-03-11T01:07:06.000Z</published>
    <updated>2022-03-11T01:21:45.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-Authentication-Basic-and-Digest-Access-Authentication"><a href="#HTTP-Authentication-Basic-and-Digest-Access-Authentication" class="headerlink" title="HTTP Authentication: Basic and Digest Access Authentication"></a>HTTP Authentication: Basic and Digest Access Authentication</h2><p>在做课题的过程中需要了解RFC2617的知识，在此做一个中文总结。</p><h3 id="Basic-Authentication-Scheme"><a href="#Basic-Authentication-Scheme" class="headerlink" title="Basic Authentication Scheme"></a>Basic Authentication Scheme</h3><p>基本认证方案(Basic Authentication Scheme)是基于这样的模型：客户必须用一个用户ID和一个密码来认证自己的每个realm，realm vakye应当被认为是一个不透明的字符串，只能与该服务器上的其他realm进行比较以确定是否相等，服务器只有在能够验证Request-URI的用户ID和密码的情况下才能为请求提供服务。</p><p>basic-credentials = base64-user-pass </p><p>base64-user-pass = &lt;base64 [4] encoding of user-pass, except not limited to 76 char/line&gt;</p><p>user-pass = userid “:” password</p><p>userid  = *&lt;TEXT excluding “:”&gt;</p><p>password = *TEXT</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP-Authentication-Basic-and-Digest-Access-Authentication&quot;&gt;&lt;a href=&quot;#HTTP-Authentication-Basic-and-Digest-Access-Authentication&quot; cl</summary>
      
    
    
    
    
    <category term="Project-Web" scheme="http://example.com/tags/Project-Web/"/>
    
  </entry>
  
  <entry>
    <title>RFC6328: Time Based One-Time Password</title>
    <link href="http://example.com/2022/03/11/RFC6328-Time-Based-One-Time-Password/"/>
    <id>http://example.com/2022/03/11/RFC6328-Time-Based-One-Time-Password/</id>
    <published>2022-03-11T00:01:02.000Z</published>
    <updated>2022-03-16T02:08:44.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RFC6328-Time-Based-One-Time-Password-TOTP"><a href="#RFC6328-Time-Based-One-Time-Password-TOTP" class="headerlink" title="RFC6328: Time Based One-Time Password (TOTP)"></a>RFC6328: Time Based One-Time Password (TOTP)</h2><p>最近做到的课题需要我利用<a href="https://datatracker.ietf.org/doc/html/rfc6328">RFC6328</a>将自己的邮箱信息加密，作为账号密码发送给对方的服务器。中文全网对于RFC6328的文章较少，在此稍微记载下学习的过程与心得。</p><p>Go写的TOTP库 <a href="https://github.com/xiaogeamadeus/gototp">gototp</a></p><h3 id="TOTP是什么？"><a href="#TOTP是什么？" class="headerlink" title="TOTP是什么？"></a>TOTP是什么？</h3><p>TOTP指基于时间的一次性密码。TOTP是基于OTP (One-Time Password, 一次性密码)的扩展。在RFC4226中，定义了一种基于HMAC的一次性密码，被命名为HOTP。HOTP算法是基于事件的，对其来说移动因子是一个事件计数器。而在TOTP当中，移动因子建立在了一个时间值上。该算法通过利用时间值，提供了一个短命的OTP值，可以有效提高安全性。</p><h3 id="HOTP算法"><a href="#HOTP算法" class="headerlink" title="HOTP算法"></a>HOTP算法</h3><p>HOTP(HMAC-based One-Time Password, RFC4226)算法是基于HMAC-SHA-1算法的，该算法公式如下所示。</p><p>HOTP(K, C) = Truncate(HMAC-SHA-1(K, C))</p><p>其中Truncate代表可以将HMAC-SHA-1转换为HOTP值的函数，K代表共享的秘密，C代表计数器值。</p><p>换言之，想要得到HOTP密码，有如下几个先决条件：</p><ol><li>知道Truncate函数。</li><li>服务器端与客户端有共享的秘密。</li><li>用相同的计数器方法。</li></ol><h3 id="HOTP算法与TOTP算法的区别"><a href="#HOTP算法与TOTP算法的区别" class="headerlink" title="HOTP算法与TOTP算法的区别"></a>HOTP算法与TOTP算法的区别</h3><p>TOTP算法是HOTP算法基于时间的变体。在TOTP算法中，计数器值C被替换为了由时间参考和时间步长得出的值T。首先你要输入现在的Unixtime，然后减去所设置的T0。实际情况下将时间精确到每秒是无法实现的，一般会提供一个步长。</p><p>TOTP可以使用HMAC-SHA-256/512函数，不同于HOTP算法的HMAC-SHA-1函数</p><h3 id="TOTP算法要求"><a href="#TOTP算法要求" class="headerlink" title="TOTP算法要求"></a>TOTP算法要求</h3><p>R1: The prover (e.g., token, soft token) and verifier (authentication or validation server) MUST know or be able to derive the current Unix time (i.e., the number of seconds elapsed since midnight UTC of January 1, 1970) for OTP generation. See [UT] for a more detailed definition of the commonly known “Unix time”. The precision of the time used by the prover affects how often the clock synchronization should be done; see Section 6.</p><p>（服务器端与客户端均能得知现在的Unix时间）</p><p>R2: The prover and verifier MUST either share the same secret or the knowledge of a secret transformation to generate a shared secret.</p><p>（服务器端与客户端需要共享相同的秘密/共享产生共享秘密的转换的知识）</p><p>R3: The algorithm MUST use HOTP [RFC4226] as a key building block.</p><p>（算法必须使用HOTP算法来构建）</p><p>R4: The prover and verifier MUST use the same time-step value X.</p><p>（服务器端与客户端必须使用相同的步长X）</p><p>R5: There MUST be a unique secret (key) for each prover.</p><p>（每个验证者必须有一个独特的秘密（密钥））</p><p>R6: The keys SHOULD be randomly generated or derived using key derivation algorithms.</p><p>（密钥应当是随机生成/使用推导算法）</p><p>R7: The keys MAY be stored in a tamper-resistant device and SHOULD be protected against unauthorized access and usage.</p><p>（密钥应当储存在安全设备中）</p><h3 id="TOTP算法详解"><a href="#TOTP算法详解" class="headerlink" title="TOTP算法详解"></a>TOTP算法详解</h3><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>K代表服务器端与客户端共同了解的秘密。</p><p>X代表以秒为单位的时间步长（默认值X=30秒），是一个系统参数。</p><p>T0是开始计算时间步长的Unix时间（缺省值为0，即Unix epoch，1970年1月1日），也是一个系统参数。</p><h4 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h4><p>我们将TOTP定义为HOTP(K, T), T是一个整数，代表初始计数器时间T0和当前Unix时间之间的时间步数。</p><blockquote><p>TOTP(K, T0, X) = HOTP(K, T(T0, X))</p><p>T(T0, X) = (CurrentUnixTime - T0) / X</p></blockquote><h3 id="TOTP算法实装"><a href="#TOTP算法实装" class="headerlink" title="TOTP算法实装"></a>TOTP算法实装</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gototp<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TOTP</span><span class="hljs-params">(k <span class="hljs-type">string</span>, t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>{<br><span class="hljs-keyword">return</span> HOTP(k, T(T0, x))<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">T</span><span class="hljs-params">(t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> (time.Now().Unix - t0)/x<br>}<br></code></pre></td></tr></tbody></table></figure><p>上述代码中，我们可以发现HOTP函数并未被定义。所以我们还需要对于HOTP进行定义。</p><h3 id="HOTP算法实装"><a href="#HOTP算法实装" class="headerlink" title="HOTP算法实装"></a>HOTP算法实装</h3><p>想要求出HOTP，其实大体只需要三步。</p><ol><li>用Key与Count求出HMAC-SHA1的值。</li><li>生成4个字节的字符串</li><li>计算HOTP值</li></ol><p>我们来逐一分析一下</p><h4 id="1-求解HMAC-SHA1的值"><a href="#1-求解HMAC-SHA1的值" class="headerlink" title="1. 求解HMAC-SHA1的值"></a>1. 求解HMAC-SHA1的值</h4><p>HMAC是密钥相关的哈希计算消息认证码（Hash-based Message Authentication Code）在多种网络协议（如SSL）中得到了广泛使用。通过使用哈希函数，可以从Key和Message中生成认证码。</p><p>假设HMAC-SHA1的值为HS，计算公式如下所示：</p><blockquote><p>HS = HMAC-SHA-1(K, C)</p></blockquote><p>K：共同秘密key</p><p>C：Message，在HOTP函数中为count中的值</p><p>对于Golang来说，HMAC和SHA1都有标准包可以引用，HMAC为<code>crypto/hmac</code>、SHA1为<code>crypto/sha1</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HMACSHA1</span><span class="hljs-params">(k, c []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span>{<br>mac := hmac.New(sha1.New, k)<br>mac.Write(c)<br><span class="hljs-keyword">return</span> mac.Sum(<span class="hljs-literal">nil</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><p>对于Golang来说，HMAC是用<code>has.Hash</code>实装的，利用<code>hmac.New(func()has.Hash, []byte)</code>可以得到哈希函数对应的对象。这样我们就成功的计算出了HS值。</p><p>注；对于SHA1来说，存储空间最大为160bit，最大支持20文字的字符串。</p><h4 id="2-生成一个4byte的字符串"><a href="#2-生成一个4byte的字符串" class="headerlink" title="2. 生成一个4byte的字符串"></a>2. 生成一个4byte的字符串</h4><p>下一步，则是利用第一步计算出的HMAC值，制作一个4byte长度的字符串。</p><blockquote><p>Sbits = DT(HS)</p></blockquote><p>首先计算<code>offsetbits</code>，这是HS的20个字中最后的4bit。</p><p>由于Go语言处理的是字节串(Byte String)，所以当我取出20个字的最后一个字时，取出的其实是一个8bit的数字，由于我们只需要最后的4bit，所以一般情况下给到的结果是（0000xxxx）前四位bit被屏蔽了。同时，由于go没有二进制的字符，所以我们实际上表示会使用16进制。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">offsetbits := hs[<span class="hljs-number">19</span>] &amp; <span class="hljs-number">0xF</span><br><span class="hljs-comment">// 0x后面的数为16进制</span><br><span class="hljs-comment">// &amp; 位and运算 同1为1</span><br></code></pre></td></tr></tbody></table></figure><p>下一步求解<code>offset</code>。</p><p><code>offset</code>可以将<code>offsetbits</code>作为数值取出。</p><p>并没有什么特别的变换，仅仅是直接将byte列作为Integer读出。（因为<code>offsetbits</code>是4bit，所以<code>offset</code>这个值为0-15）</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">offset := <span class="hljs-type">int</span>(offsetbits)<br></code></pre></td></tr></tbody></table></figure><p>接下来，将HS的第<code>offset</code>位开始之后4个文字拿出来，赋值给<code>p</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p := hs[offset:offset + <span class="hljs-number">4</span>]<br></code></pre></td></tr></tbody></table></figure><p>然后提取<code>p</code>（32bit）末尾的31bit（0xx…..xx(31个x)）</p><p>这也是利用mask来做计算的，换句话说与7FFFFFFF做and运算就可以。</p><p>当然，由于用byte列做mask会稍微有些麻烦，所以可以先将<code>[]byte</code>变换为<code>int</code>然后做mask。</p><p>由于Go语言不支持直接变换，所以借用一个包<code>encoding/binary</code></p><p>总结一下第二步所做的工作。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Truncate 函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DT</span><span class="hljs-params">(hs []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> {<br>offsetbits := hs[<span class="hljs-number">19</span>] &amp; <span class="hljs-number">0xF</span><br>offset := <span class="hljs-type">int</span>(offsetbits)<br>p := hs[offset : offset+<span class="hljs-number">4</span>]<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(binary.BigEndian.Uint32(p)) &amp; <span class="hljs-number">0x7FFFFFFF</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="3-计算HOTP的值"><a href="#3-计算HOTP的值" class="headerlink" title="3. 计算HOTP的值"></a>3. 计算HOTP的值</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReductionModulo</span><span class="hljs-params">(snum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(<span class="hljs-type">int64</span>(snum) % <span class="hljs-type">int64</span>(math.Pow10(g.Digit)))<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="HOTP算法总结"><a href="#HOTP算法总结" class="headerlink" title="HOTP算法总结"></a>HOTP算法总结</h4><p>最后将HOTP函数构建一下，将上面的步骤套入。</p><p>再次回顾一下HOTP函数</p><blockquote><p>HOTP(K, C) = Truncate(HMAC - SHA- 1(K, C))</p></blockquote><p>Truncate函数是用上面的<code>DT</code>实现的</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HOTP</span><span class="hljs-params">(k, c []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span>{<br><span class="hljs-keyword">return</span> DT(HMACSHA1(k, c))<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="联合TOTP和HOTP"><a href="#联合TOTP和HOTP" class="headerlink" title="联合TOTP和HOTP"></a>联合TOTP和HOTP</h3><p>完成HOTP函数的构建之后，我们要想办法将其应用在TOTP之中。</p><p>之前我们构建的TOTP函数如下所示</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TOTP</span><span class="hljs-params">(k <span class="hljs-type">string</span>, t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> HOTP(k, T(T0, x))<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">T</span><span class="hljs-params">(t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> (time.Now().Unix - t0) / x<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上，<code>T(t0, x)</code>的返回值是<code>int</code>，是无法在<code>func HOTP(k, c []byte) int</code>中使用的，所以要对HOTP函数进行微调。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HOTP</span><span class="hljs-params">(k []<span class="hljs-type">byte</span>, c <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>{<br>cb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br>binary.BigEndian.PutUint64(cb, c)<br><span class="hljs-keyword">return</span> DT(HMACSHA1(k, cb))<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，我们完成了TOTP算法的基础实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RFC6328-Time-Based-One-Time-Password-TOTP&quot;&gt;&lt;a href=&quot;#RFC6328-Time-Based-One-Time-Password-TOTP&quot; class=&quot;headerlink&quot; title=&quot;RFC6328: T</summary>
      
    
    
    
    
    <category term="Project-Web" scheme="http://example.com/tags/Project-Web/"/>
    
  </entry>
  
  <entry>
    <title>Sending HTTP Request with Golang</title>
    <link href="http://example.com/2022/03/10/Sending-HTTP-Request-with-Golang/"/>
    <id>http://example.com/2022/03/10/Sending-HTTP-Request-with-Golang/</id>
    <published>2022-03-10T07:10:53.000Z</published>
    <updated>2022-03-12T12:12:48.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-way-to-send-a-HTTP-request-with-golang"><a href="#The-way-to-send-a-HTTP-request-with-golang" class="headerlink" title="The way to send a HTTP request with golang"></a>The way to send a HTTP request with golang</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"encoding/base64"</span><br><br><span class="hljs-string">"github.com/imroc/req/v3"</span><br><span class="hljs-string">"github.com/jltorresm/otpgo"</span><br><span class="hljs-string">"github.com/jltorresm/otpgo/config"</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>t := otpgo.TOTP{<br>Key: <span class="hljs-string">"wang.tianchen333@gmail.comHENNGECHALLENGE003"</span>,<br>Algorithm: config.HmacSHA512,<br>}<br>token, _ := t.Generate()<br>token1 := <span class="hljs-string">"wang.tianchen333@gmail.com"</span> +<span class="hljs-string">":"</span> + token<br>auto := <span class="hljs-string">"basic "</span> + base64.StdEncoding.EncodeToString([]<span class="hljs-type">byte</span>(token1))<br><br>user := &amp;User{github: <span class="hljs-string">"https://gist.github.com/xiaogeamadeus/ad9d74723a99a882c850eabb66c51d9d"</span>,<br>                  contact: <span class="hljs-string">"wang.tianchen333@gmail.com"</span>,<br>  solution: <span class="hljs-string">"golang"</span>}<br>client := req.C().EnableDumpAllWithoutResponse()<br>client.R().<br>    SetHeaders(<span class="hljs-string">"Authorization"</span>, auto,<br>           <span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>,).<br>    SetBody(user).<br>    Post(<span class="hljs-string">"https://api.challenge.hennge.com/challenges/003"</span>)<br><br>}<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {<br>github <span class="hljs-type">string</span> <span class="hljs-string">`json:"github_url"`</span><br>contact <span class="hljs-type">string</span> <span class="hljs-string">`json:"contact_email"`</span><br>solution <span class="hljs-type">string</span> <span class="hljs-string">`json:"solution_language"`</span><br>}<br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">2022</span>/<span class="hljs-number">03</span>/<span class="hljs-number">12</span> <span class="hljs-number">20</span><span class="hljs-punctuation">:</span><span class="hljs-number">53</span><span class="hljs-punctuation">:</span><span class="hljs-number">40.763848</span> DEBUG <span class="hljs-punctuation">[</span>req<span class="hljs-punctuation">]</span> GET https<span class="hljs-punctuation">:</span><span class="hljs-comment">//api.challenge.hennge.com/challenges/003</span><br><span class="hljs-punctuation">:</span>authority<span class="hljs-punctuation">:</span> api.challenge.hennge.com<br><span class="hljs-punctuation">:</span>method<span class="hljs-punctuation">:</span> GET<br><span class="hljs-punctuation">:</span>path<span class="hljs-punctuation">:</span> /challenges/<span class="hljs-number">003</span><br><span class="hljs-punctuation">:</span>scheme<span class="hljs-punctuation">:</span> https<br>user-agent<span class="hljs-punctuation">:</span> Mozilla/<span class="hljs-number">5.0</span> (Macintosh; Intel Mac OS X <span class="hljs-number">10</span>_15_7) AppleWebKit/<span class="hljs-number">537.36</span> (KHTML<span class="hljs-punctuation">,</span> like Gecko) Chrome/<span class="hljs-number">97.0</span><span class="hljs-number">.4692</span><span class="hljs-number">.71</span> Safari/<span class="hljs-number">537.36</span><br>accept-encoding<span class="hljs-punctuation">:</span> gzip<br><br><span class="hljs-punctuation">:</span>status<span class="hljs-punctuation">:</span> <span class="hljs-number">403</span><br>content-type<span class="hljs-punctuation">:</span> application/json<br>content-length<span class="hljs-punctuation">:</span> <span class="hljs-number">68</span><br>date<span class="hljs-punctuation">:</span> Sat<span class="hljs-punctuation">,</span> <span class="hljs-number">12</span> Mar <span class="hljs-number">2022</span> <span class="hljs-number">11</span><span class="hljs-punctuation">:</span><span class="hljs-number">53</span><span class="hljs-punctuation">:</span><span class="hljs-number">42</span> GMT<br>x-amzn-requestid<span class="hljs-punctuation">:</span> <span class="hljs-number">2492</span>fed6-b665<span class="hljs-number">-4</span>d3e-becb<span class="hljs-number">-0532</span>ed6fb218<br>access-control-allow-origin<span class="hljs-punctuation">:</span> https<span class="hljs-punctuation">:</span><span class="hljs-comment">//challenge.hennge.com</span><br>access-control-allow-headers<span class="hljs-punctuation">:</span> Content-Type<span class="hljs-punctuation">,</span>X-Amz-Date<span class="hljs-punctuation">,</span>Authorization<span class="hljs-punctuation">,</span>X-Api-Key<span class="hljs-punctuation">,</span>X-Amz-Security-Token<br>x-amzn-errortype<span class="hljs-punctuation">:</span> MissingAuthenticationTokenException<br>x-amz-apigw-id<span class="hljs-punctuation">:</span> O3p3EH04NjMFdIQ=<br>access-control-allow-methods<span class="hljs-punctuation">:</span> GET<span class="hljs-punctuation">,</span>OPTIONS<span class="hljs-punctuation">,</span>POST<span class="hljs-punctuation">,</span>PUT<br>x-cache<span class="hljs-punctuation">:</span> Error from cloudfront<br>via<span class="hljs-punctuation">:</span> <span class="hljs-number">1.1</span> e2f427863e6bdb72ad8bed72b596d81e.cloudfront.net (CloudFront)<br>x-amz-cf-pop<span class="hljs-punctuation">:</span> OSL50-P1<br>x-amz-cf-id<span class="hljs-punctuation">:</span> nLWbqmaTIGAh2btKEQOFDkk5LDTgu6DBtboJS9a-OCPfaEZ08ubPqQ==<br><br><span class="hljs-punctuation">{</span><br>     <span class="hljs-attr">"message"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"User is not authorized to access this resource"</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">"github_url"</span>: <span class="hljs-string">"https://gist.github.com/xiaogeamadeus/ad9d74723a99a882c850eabb66c51d9d"</span>,<span class="hljs-string">"contact_email"</span>: <span class="hljs-string">"wang.tianchen333@gmail.com"</span>,<span class="hljs-string">"solution_language"</span>: <span class="hljs-string">"golang"</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">{<span class="hljs-string">"github_url"</span>:<span class="hljs-string">"https://gist.github.com/hennge/b859bd12e7a7fb418141"</span>,<span class="hljs-string">"contact_email"</span>:<span class="hljs-string">"ninja@example.com"</span>,<span class="hljs-string">"solution_language"</span>:<span class="hljs-string">"golang"</span>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-way-to-send-a-HTTP-request-with-golang&quot;&gt;&lt;a href=&quot;#The-way-to-send-a-HTTP-request-with-golang&quot; class=&quot;headerlink&quot; title=&quot;The way </summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>Gogee_Day2 コンテキスト</title>
    <link href="http://example.com/2022/03/09/Gogee-Day2-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88/"/>
    <id>http://example.com/2022/03/09/Gogee-Day2-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88/</id>
    <published>2022-03-09T11:03:59.000Z</published>
    <updated>2022-03-14T00:59:34.460Z</updated>
    
    <content type="html"><![CDATA[<p>本部分主要内容：</p><ol><li>将router独立出来，方便之后增强。</li><li>设计context，封装Request和Response，提供对JSON（JavaScript Object Notation）、HTML等返回类型的支持。</li></ol><h2 id="コンテキストの設計"><a href="#コンテキストの設計" class="headerlink" title="コンテキストの設計"></a>コンテキストの設計</h2><h4 id="必要がある？"><a href="#必要がある？" class="headerlink" title="必要がある？"></a>必要がある？</h4><ol><li>对于web服务来说，无非就是根据Request<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但这两个对象所提供的API太细了，比如，如果我们想要构建一个完整的Response，需要考虑Header，Body，而Header包含了状态码 (StatusCode)，消息类型(ContentType) 等几乎每次请求都要设置的信息。所以如果不进行有效的封装，使用这个框架的用户需要写大量重复且复杂的代码，还容易出错。所以说对于一个好的框架而言，能够高效的构造出HTTP响应是一个关键点。</li><li>针对使用场景来说，封装<code>*http.Request</code>和<code>http.ResponseWriter</code>的方法，简化相关port的调用只是设计Context原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态router<code>/hello/:name</code>，参数<code>:name</code>的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context可以随着每一个请求的出现而产生，也随着请求的结束而销毁。所以设计Context结构，我们可以将复杂性和扩展性留在内部，对外简化了port和router的处理函数；要实现的中间件、参数都统一使用Context实例，就像一个百宝箱，可以在其中找到任何东西。</li></ol><h4 id="具体的に実現する"><a href="#具体的に実現する" class="headerlink" title="具体的に実現する"></a>具体的に実現する</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gogee<br><br><span class="hljs-keyword">import</span>(<br><span class="hljs-string">"encoding/json"</span><br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-keyword">type</span> H <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>{}<br><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span>{<br><span class="hljs-comment">//origin objects</span><br>Writer http.ResponseWriter<br>Req    *http.Request<br><span class="hljs-comment">//request info</span><br>Path <span class="hljs-type">string</span><br>Method <span class="hljs-type">string</span><br><span class="hljs-comment">//response info</span><br>StatusCode <span class="hljs-type">int</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newContext</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> *Context{<br><span class="hljs-keyword">return</span> &amp;Context{<br>Writer: w,<br>Req:    req,<br>Path:   req.URL.Path,<br>Method: req.Method,<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> PostForm(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span>{<br><span class="hljs-keyword">return</span> c.Req.FormValue(key)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Query(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span>{<br><span class="hljs-keyword">return</span> c.Req.URL.Query().Get(key)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Status(code <span class="hljs-type">int</span>) {<br>c.StatusCode = code<br>c.Writer.WriteHeader(code)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SetHeader(key <span class="hljs-type">string</span>, value <span class="hljs-type">string</span>){<br>c.Writer.Header().Set(key, value)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> String(code <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, values ...<span class="hljs-keyword">interface</span>{}){<br>c.SetHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"text/plain"</span>)<br>c.Status(code)<br>c.Writer.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(format, values...)))<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> JSON(code <span class="hljs-type">int</span>, obj <span class="hljs-keyword">interface</span>{}){<br>c.SetHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>)<br>c.Status(code)<br>encoder := json.NewEncoder(c.Writer)<br><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span>{<br>http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Data(code <span class="hljs-type">int</span>, data []<span class="hljs-type">byte</span>){<br>c.Status(code)<br>c.Writer.Write(data)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, html <span class="hljs-type">string</span>){<br>c.SetHeader(<span class="hljs-string">"Content-Type"</span>,<span class="hljs-string">"text/html"</span>)<br>c.Status(code)<br>c.Writer.Write([]<span class="hljs-type">byte</span>(html))<br>}<br></code></pre></td></tr></tbody></table></figure><p>第一步给<code>map[string]interface{}</code>起别名<code>gogee.H</code>这样在构建JSON数据时更加简洁。</p><p><code>Context</code>结构目前只包含<code>http.ResponseWriter</code>和<code>*http.Request</code>不过同时提供了对于Method/Path等request的常用属性的直接访问。</p><p>代码提供了访问Query和PostForm参数的方法。</p><p>代码提供了快速构造String/Data/JSON/HTML响应的方法。</p><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>我们将路由相关的方法和结构提取出来，放到了一个新的文件<code>router.go</code>中，方便我们下一次对于router的功能进行增强，比如提供动态路由的支持。同时，router的handle方法做了一个细微的调整，将handler的参数变为了Context。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gogee<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-keyword">type</span> router <span class="hljs-keyword">struct</span> {<br>handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouter</span><span class="hljs-params">()</span></span> *router {<br><span class="hljs-keyword">return</span> &amp;router{handlers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc)}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>key := method + <span class="hljs-string">"_"</span> + pattern<br>r.handlers[key] = handler<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) {<br>key := c.Method + <span class="hljs-string">"_"</span> + c.Path<br><span class="hljs-keyword">if</span> handler, ok := r.handlers[key]; ok {<br>handler(c)<br>} <span class="hljs-keyword">else</span> {<br>c.String(http.StatusNotFound, <span class="hljs-string">"404 NOT FOUND: %s\n"</span>, c.Path)<br>}<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="框架入口"><a href="#框架入口" class="headerlink" title="框架入口"></a>框架入口</h4><p>在修改了router并且增加了context部分之后，我们可以大幅度缩减<code>gogee.go</code>文件的内容。因为一些复杂的东西已经被放在<code>router.go</code>和<code>Context.go</code>之中了。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gogee<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"log"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-comment">// HandlerFunc defines the request handler used by Gogee</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span><br><br><span class="hljs-comment">// Engine implement the interface of ServeHTTP</span><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> {<br>router *router<br>}<br><br><span class="hljs-comment">// New is the constructor of Gogee.Engine</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine {<br><span class="hljs-keyword">return</span> &amp;Engine{router: newRouter()}<br>}<br><br><span class="hljs-comment">// addRoute is the way to add something to route</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>log.Printf(<span class="hljs-string">"Route %4s - %s"</span>, method, pattern)<br>engine.router.addRoute(method, pattern, handler)<br>}<br><br><span class="hljs-comment">// GET defines the method to add GET request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>engine.addRoute(<span class="hljs-string">"GET"</span>, pattern, handler)<br>}<br><br><span class="hljs-comment">//POST defines the method to POST request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>engine.addRoute(<span class="hljs-string">"POST"</span>, pattern, handler)<br>}<br><br><span class="hljs-comment">//Run definesd the method to start a http server</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>) {<br><span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>}<br><br><span class="hljs-comment">// To use the ListenAndServe, we need to set a ServeHTTP struct</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) {<br>c := newContext(w, req)<br>engine.router.handle(c)<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>当然最重要的还是通过实现了ServeHTTP的接口之后，接管了所有的HTTP请求。</p><p>最后，稍微修改一下<code>main.go</code>文件。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"gogee"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>r := gogee.New()<br>r.GET(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gogee.Context)</span></span> {<br>c.HTML(http.StatusOK, <span class="hljs-string">"&lt;h1&gt;Hello Gogee&lt;/h1&gt;"</span>)<br>})<br><br>r.GET(<span class="hljs-string">"/hello"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gogee.Context)</span></span> {<br>c.String(http.StatusOK, <span class="hljs-string">"hello %s, you're at %s\n"</span>, c.Query(<span class="hljs-string">"name"</span>), c.Path)<br>})<br><br>r.POST(<span class="hljs-string">"/login"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gogee.Context)</span></span> {<br>c.JSON(http.StatusOK, gogee.H{<br><span class="hljs-string">"username"</span>: c.PostForm(<span class="hljs-string">"username"</span>),<br><span class="hljs-string">"password"</span>: c.PostForm(<span class="hljs-string">"password"</span>),<br>})<br>})<br><br>r.Run(<span class="hljs-string">":9999"</span>)<br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本部分主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将router独立出来，方便之后增强。&lt;/li&gt;
&lt;li&gt;设计context，封装Request和Response，提供对JSON（JavaScript Object Notation）、HTML等返回类型的支持。&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>Terminal for Mac</title>
    <link href="http://example.com/2022/03/09/Terminal-for-Mac/"/>
    <id>http://example.com/2022/03/09/Terminal-for-Mac/</id>
    <published>2022-03-09T01:15:29.000Z</published>
    <updated>2022-03-31T00:32:52.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Basic-Operation-of-Shell-for-Mac"><a href="#The-Basic-Operation-of-Shell-for-Mac" class="headerlink" title="The Basic Operation of Shell for Mac"></a>The Basic Operation of Shell for Mac</h2><h3 id="更改目录："><a href="#更改目录：" class="headerlink" title="更改目录："></a>更改目录：</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">cd &lt;Path&gt; //找到对应路径<br>cd .. //移动到上一级目录<br>pushd &lt;Path&gt; //记住来源的同时移动到其他目录，popd 返回来源<br></code></pre></td></tr></tbody></table></figure><h3 id="目录列举"><a href="#目录列举" class="headerlink" title="目录列举"></a>目录列举</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls //列举出当前目录下所有的文件和子目录<br>   //可以使用通配符 * 来缩小搜索范围。<br>   //例1: 列举所有以".java"结尾的文件<br>     ls *.java<br>   //例2：列举所有以"F"开头，".java"结尾的文件<br>     ls F*.java<br></code></pre></td></tr></tbody></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir //系统<br>mkdir books //示例<br></code></pre></td></tr></tbody></table></figure><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm //系统<br>rm somefile.java //示例<br></code></pre></td></tr></tbody></table></figure><h3 id="移除目录"><a href="#移除目录" class="headerlink" title="移除目录"></a>移除目录</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -r //系统<br>rm -r books //示例<br></code></pre></td></tr></tbody></table></figure><h3 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">!! //重复上条命令<br>!n //重复倒数第n条命令<br></code></pre></td></tr></tbody></table></figure><h3 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">history //系统<br></code></pre></td></tr></tbody></table></figure><h3 id="文件解压"><a href="#文件解压" class="headerlink" title="文件解压"></a>文件解压</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">//Linux/Mac 都有命令行解压程序 unzip，你可以通过互联网为 Windows 安装命令行解压程序 unzip。<br>//图形界面下（Windows 资源管理器，Mac Finder，Linux Nautilus 或其他等效软件）右键单击该文件，<br>//在 Mac 上选择“open”<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-Basic-Operation-of-Shell-for-Mac&quot;&gt;&lt;a href=&quot;#The-Basic-Operation-of-Shell-for-Mac&quot; class=&quot;headerlink&quot; title=&quot;The Basic Operation </summary>
      
    
    
    
    
    <category term="Shell" scheme="http://example.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Git基礎</title>
    <link href="http://example.com/2022/03/09/Git%E5%9F%BA%E7%A4%8E/"/>
    <id>http://example.com/2022/03/09/Git%E5%9F%BA%E7%A4%8E/</id>
    <published>2022-03-09T01:10:22.000Z</published>
    <updated>2022-03-10T12:15:42.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gitを使って方法（Mac）"><a href="#Gitを使って方法（Mac）" class="headerlink" title="Gitを使って方法（Mac）"></a>Gitを使って方法（Mac）</h2><h2 id="建立仓库，并与git连接"><a href="#建立仓库，并与git连接" class="headerlink" title="建立仓库，并与git连接"></a>建立仓库，并与git连接</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li><p>github上新建一个repository</p></li><li><p>复制repository的ssh地址</p></li><li><p>打开终端输入命令</p><p><code>cd /users/xiaogeamadeus/mygo/src</code></p></li><li><p>然后克隆项目</p><p><code>git clone ssh (copy from github)</code></p></li><li><p>在vscode新建一个工程，路径为刚克隆的文件夹</p></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li><p>本地创建一个repository</p><p><code>mkdir projectname</code></p><p><code>cd projectname</code></p></li><li><p>通过<code>git init</code>命令将这个projectname目录变为git可以管理的目录</p><p><code>git init</code></p></li></ol><h2 id="如何提交修改"><a href="#如何提交修改" class="headerlink" title="如何提交修改"></a>如何提交修改</h2><ol><li><p>切换到项目文件夹所在的路径</p><p>``cd /users/xiaogeamadeus/mygo/project(created)`</p></li><li><p>输入</p><p><code>git add .</code> 将文件添加到仓库（.代表提交所有文件）</p><p><code>git commit -m "day1"</code> 把文件提交到暂存区（””内为本次提交的说明，用于方便找到提交记录）</p><p><code>git push</code> 上传到github</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Gitを使って方法（Mac）&quot;&gt;&lt;a href=&quot;#Gitを使って方法（Mac）&quot; class=&quot;headerlink&quot; title=&quot;Gitを使って方法（Mac）&quot;&gt;&lt;/a&gt;Gitを使って方法（Mac）&lt;/h2&gt;&lt;h2 id=&quot;建立仓库，并与git连接&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Go Module</title>
    <link href="http://example.com/2022/03/09/Go-Module/"/>
    <id>http://example.com/2022/03/09/Go-Module/</id>
    <published>2022-03-09T00:13:39.000Z</published>
    <updated>2022-03-09T00:30:04.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-Moduleとは"><a href="#Go-Moduleとは" class="headerlink" title="Go Moduleとは"></a>Go Moduleとは</h1><p>go在更新到1.13版本之后，由官方将其令人诟病的依赖管理进行了维护。</p><p>go module 是 go 官方自带的go依赖管理库(Dependency Management Library)</p><p>go module 可以将某个项目（文件夹）下所有的依赖整理成一个go.mod文件，里面写入了依赖的版本等。</p><p>使用了go module之后我们可以不用将代码放在src下了。</p><h2 id="Go-Module的使用方法"><a href="#Go-Module的使用方法" class="headerlink" title="Go Module的使用方法"></a>Go Module的使用方法</h2><p>初始化</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /your catalog/test(your project)<br>go mod init <span class="hljs-built_in">test</span><br></code></pre></td></tr></tbody></table></figure><p>这时候会发现项目文件夹下多出了一个go.mod文件夹</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go-Moduleとは&quot;&gt;&lt;a href=&quot;#Go-Moduleとは&quot; class=&quot;headerlink&quot; title=&quot;Go Moduleとは&quot;&gt;&lt;/a&gt;Go Moduleとは&lt;/h1&gt;&lt;p&gt;go在更新到1.13版本之后，由官方将其令人诟病的依赖管理进行了维护</summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>ウェブサービス設計基礎</title>
    <link href="http://example.com/2022/03/08/%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E8%A8%AD%E8%A8%88%E5%9F%BA%E7%A4%8E/"/>
    <id>http://example.com/2022/03/08/%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E8%A8%AD%E8%A8%88%E5%9F%BA%E7%A4%8E/</id>
    <published>2022-03-08T07:39:37.000Z</published>
    <updated>2022-03-30T05:23:25.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="How-the-Web-Works"><a href="#How-the-Web-Works" class="headerlink" title="How the Web Works?"></a>How the Web Works?</h2><p>平时在上网的时候，打开浏览器，输入网址，按下回车，显示想要的内容。这个过程电脑端与服务器端是怎样实现的呢？</p><p>对于普通的上网过程，系统是这样做的：浏览器是一个客户端(client-site)，当你输入URL时，首先浏览器会请求DNS服务器，通过DNS服务器获取域名所对应的IP，然后通过IP地址找到Ip对应的服务器，要求建立TCP链接，等浏览器发送完HTTP Request（请求）包之后，服务器(server-site)接收到请求包，处理请求包，调用自身服务，返回HTTP Response（响应）包；客户端收到来自服务器的响应后开始渲染这个Response包中的主体(body)，等收到全部的内容后端开与服务器之间的TCP链接。<img src="/%E3%82%A6%E3%82%A7%E3%83%95%E3%82%99%E3%82%B5%E3%83%BC%E3%83%92%E3%82%99%E3%82%B9%E8%A8%AD%E8%A8%88%E5%9F%BA%E7%A4%8E/3.1.web2.png" alt="3.1.web2"></p><p>一个web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。这个客户端一般指的是web浏览器。</p><p>web服务器端的功能可以被总结为以下几点</p><ol><li>客户端通过TCP/IP协议建立到服务器的TCP连接。</li><li>客户端向服务器发送HTTP协议请求包(HTTP Request)，请求服务器里的资源文档。</li><li>服务器向客户端发送HTTP协议应答包(HTTP Response)，如果请求的资源包含动态语言，服务器会调用动态语言的解释引擎处理“动态内容”，并将处理得到的数据返回给客户端。</li><li>客户端与服务器断开，由客户端解释HTML文档，在客户端屏幕上渲染图形结果。</li></ol><p><strong>注：客户端与服务器之间的通讯是非持久性的，服务器发送了应答之后就会与客户端断开连接，等待下一次请求。</strong></p><h3 id="URLとDNS"><a href="#URLとDNS" class="headerlink" title="URLとDNS"></a>URLとDNS</h3><p>略，Computer Science：an Overview讲过</p><p>注：DNS使用的是递归查询过程+迭代查询过程，最后获取IP地址</p><h3 id="HTTP-Protocol"><a href="#HTTP-Protocol" class="headerlink" title="HTTP Protocol"></a>HTTP Protocol</h3><p>HTTP协议是web工作的核心。想要了解web的工作原理，就要了解HTTP是怎么工作的。</p><p>HTTP(Hyper Text Transfer Protocol) 超文本传输协议：客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><p>HTTP是一种让web服务器与浏览器（客户端）通过互联网(Internet)发送与接收数据的协议，它建立在<strong>TCP协议</strong>之上，一般采用TCP的80端口。它是一个请求与响应的协议：客户端发出请求，服务器响应请求。服务器不能主动联系客户端，也不能给客户端发出回调链接。客户端与服务器端都可以提前中断一个连接。</p><p>HTTP协议是无状态的，同一个客户端的这次请求和上次请求没有任何对应关系。服务器并不知道这两个请求是否来自同一个客户端。为了解决这个问题，web程序引入了<strong>cookie</strong>机制来维护<strong>连接的可持续状态</strong>。</p><h4 id="HTTP-Requests-Client-Site"><a href="#HTTP-Requests-Client-Site" class="headerlink" title="HTTP Requests (Client Site)"></a>HTTP Requests (Client Site)</h4><p>对于客户端发出的HTTP请求包，其结构分为三部分。第一部分为Request line（请求行），第二部分叫request header（请求头），第三部分是body（主体）。header 和 body之间有个空行，如下所示。</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">GET <span class="hljs-regexp">/domains/</span>example<span class="hljs-regexp">/ HTTP/</span><span class="hljs-number">1.1</span><span class="hljs-regexp">//</span>请求行: 请求方法 请求URI HTTP协议/协议版本<br>Host：www.iana.org<span class="hljs-regexp">//</span>服务端的主机名<br>User-Agent：Mozilla<span class="hljs-regexp">/5.0 (Windows NT 6.1) AppleWebKit/</span><span class="hljs-number">537.4</span> (KHTML, like Gecko) Chrome<span class="hljs-regexp">/22.0.1229.94 Safari/</span><span class="hljs-number">537.4</span><span class="hljs-regexp">//</span>浏览器信息<br>Accept：text<span class="hljs-regexp">/html,application/</span>xhtml+xml,application<span class="hljs-regexp">/xml;q=0.9,*/</span>*;q=<span class="hljs-number">0.8</span><span class="hljs-regexp">//</span>客户端能接收的MIME<br>Accept-Encoding：gzip,deflate,sdch<span class="hljs-regexp">//</span>是否支持流压缩<br>Accept-Charset：UTF-<span class="hljs-number">8</span>,*;q=<span class="hljs-number">0.5</span><span class="hljs-regexp">//</span>客户端字符编码集<br><span class="hljs-regexp">//</span>空行,用于分割请求头和消息体<br><span class="hljs-regexp">//</span>消息体,请求资源参数,例如POST传递的参数<br></code></pre></td></tr></tbody></table></figure><p>HTTP协议定义了许多与服务器交互的请求方法，最基本的有4种，GET/ POST/ PUT/ DELETE。一个URL地址用于描述一个网络上的资源，而HTTP的四个基本操作对应着对这个资源的查，增，改，删。</p><p>GET一般用于获取/查询资源信息，POST一般用于更新资源信息。</p><p>GET与POST的区别如下：</p><ol><li>GET的请求body为空，而POST的body不为空</li><li>GET提交的数据会放到URL之后，以<code>?</code>分割URL和传输数据，参数之间以<code>&amp;</code>相连，如<code>EditPosts.aspx? name=test1&amp;id=123456</code>POST方法则是把提交的数据放到HTTP包的body中。</li><li>GET提交的数据大小有限制，POST无限制</li><li>GET提交数据会带来安全问题（URL会显示账号密码，类似zoom的登陆URL）</li></ol><h4 id="HTTP-Response-Server-site"><a href="#HTTP-Response-Server-site" class="headerlink" title="HTTP Response (Server site)"></a>HTTP Response (Server site)</h4><p>HTTP的response包结构如下</p><figure class="highlight sqf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sqf">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<span class="hljs-comment">//状态行</span><br>Server: nginx/<span class="hljs-number">1.0</span>.<span class="hljs-number">8</span><span class="hljs-comment">//服务器使用的WEB软件名及版本</span><br><span class="hljs-built_in">Date</span>:<span class="hljs-built_in">Date</span>: Tue, <span class="hljs-number">30</span> Oct <span class="hljs-number">2012</span> <span class="hljs-number">04</span>:<span class="hljs-number">14</span>:<span class="hljs-number">25</span> GMT<span class="hljs-comment">//发送时间</span><br>Content-<span class="hljs-built_in">Type</span>: <span class="hljs-built_in">text</span>/html<span class="hljs-comment">//服务器发送信息的类型</span><br>Transfer-Encoding: chunked<span class="hljs-comment">//表示发送HTTP包是分段发的</span><br>Connection: keep-<span class="hljs-built_in">alive</span><span class="hljs-comment">//保持连接状态</span><br>Content-Length: <span class="hljs-number">90</span><span class="hljs-comment">//主体内容长度</span><br><span class="hljs-comment">//空行 用来分割消息头和主体</span><br>&lt;!DOCTYPE html PUBLIC <span class="hljs-string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span>... <span class="hljs-comment">//消息体</span><br></code></pre></td></tr></tbody></table></figure><p>其第一行叫做<strong>状态行</strong>，由HTTP协议版本号，状态码，状态消息三部分组成</p><p>状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response。对于HTTP/1.1版本来说，状态码情况如下：</p><ul><li>1XX 提示信息 - 表示请求已被成功接收，继续处理</li><li>2XX 成功 - 表示请求已被成功接收，理解，接受</li><li>3XX 重定向 - 要完成请求必须进行更进一步的处理</li><li>4XX 客户端错误 - 请求有语法错误或请求无法实现</li><li>5XX 服务器端错误 - 服务器未能实现合法的请求</li></ul><p>本质上还是被分为Header（包含状态行）与Body。</p><h4 id="HTTP-と-Connection-keep-alive"><a href="#HTTP-と-Connection-keep-alive" class="headerlink" title="HTTP と Connection: keep-alive"></a>HTTP と Connection: keep-alive</h4><p>从HTTP/1.1起，默认开启了Keep-Alive保持连接特性，其含义是当一个网页完成打开后，客户端与服务器之间用于传输的TCP连接不会被关闭。如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。</p><p>Keep-Alive不会永久保持，有一个保持时间，可以设定。</p><h3 id="Goを使ってウェブサーバーをつくよう！"><a href="#Goを使ってウェブサーバーをつくよう！" class="headerlink" title="Goを使ってウェブサーバーをつくよう！"></a>Goを使ってウェブサーバーをつくよう！</h3><p>对于Go语言来说，其提供给了我们一个完整的<code>net/http</code>包，这样可以很方便的搭建起一个可以运行的web服务。这个使用包也能很简单的对于web的router、静态文件、模版、cookie等数据进行操作和设置。</p><h4 id="Use-net-x2F-http-Package-to-Create-a-Web-Server"><a href="#Use-net-x2F-http-Package-to-Create-a-Web-Server" class="headerlink" title="Use net/http Package to Create a Web Server"></a>Use net/http Package to Create a Web Server</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"log"</span><br><span class="hljs-string">"net/http"</span><br><span class="hljs-string">"strings"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayhelloName</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {<br>r.ParseForm()       <span class="hljs-comment">// 解析参数，default是不解析的。</span><br>fmt.Println(r.Form) <span class="hljs-comment">// 这些信息是输出到服务器端的打印信息。</span><br>fmt.Println(<span class="hljs-string">"path"</span>, r.URL.Scheme)<br>fmt.Println(<span class="hljs-string">"scheme"</span>, r.URL.Scheme)<br>fmt.Println(r.Form[<span class="hljs-string">"url_long"</span>])<br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form {<br>fmt.Println(<span class="hljs-string">"key:"</span>, k)<br>fmt.Println(<span class="hljs-string">"val:"</span>, strings.Join(v, <span class="hljs-string">""</span>))<br>}<br>fmt.Fprintf(w, <span class="hljs-string">"Hello XiaoGeAmadeus!"</span>) <span class="hljs-comment">// 将你想说的话写入w，之后会在客户端输出。</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>http.HandleFunc(<span class="hljs-string">"/"</span>, sayhelloName)       <span class="hljs-comment">//设置访问的路由</span><br>err := http.ListenAndServe(<span class="hljs-string">":9090"</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">//设置监听的端口</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br>log.Fatal(<span class="hljs-string">"ListenAndServe: "</span>, err)<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面的代码，当我们build之后，就已经在9090端口监听http链接请求了。</p><p>可以在浏览器输入<code>http://localhost:9090</code>进行实验。</p><h3 id="Goがウェブを動かすの方法"><a href="#Goがウェブを動かすの方法" class="headerlink" title="Goがウェブを動かすの方法"></a>Goがウェブを動かすの方法</h3><p>我们可以看见简单应用net/http包就可以很轻松的用Go搭建起web服务。那么go在底层是怎么做的呢？</p><h4 id="Several-concepts-of-how-the-web-works"><a href="#Several-concepts-of-how-the-web-works" class="headerlink" title="Several concepts of how the web works"></a>Several concepts of how the web works</h4><p>Request：用户请求的信息，用来解析用户的请求信息，包括POST、GET、cookie、url等信息。</p><p>Response：服务器需要反馈给客户端的信息</p><p>Conn：用户的每次请求链接</p><p>Handler：处理请求和生成返回信息的处理逻辑</p><h4 id="Analyze-the-http-package-operation-mechanism"><a href="#Analyze-the-http-package-operation-mechanism" class="headerlink" title="Analyze the http package operation mechanism"></a>Analyze the http package operation mechanism</h4><ol><li>创建Listen Socket，监听指定的端口，等待客户端请求到来。<a href="https://xiaogeamadeus.github.io/2022/03/26/TCP-IP-UDP-and-Socket/">（Socket是什么）</a></li><li>Listen Socket接受客户端的请求，得到Client Socket，接下来通过Client Socket与客户端通信。</li><li>处理客户端的请求，首先从Client Socket读取HTTP请求的协议头，如果是POST方法，还需要读取客户端提交的数据，然后交给相应的handler处理请求，handler处理完毕准备好客户端需要的数据，通过Client Socket写给客户端。</li></ol><p>在整个过程中，我们只需要了解三个问题，就可以明白Go是如何让Web运行起来的。</p><ol><li>如何监听端口？</li><li>如何接收客户端请求？</li><li>如何分配handler？</li></ol><h5 id="How-to-Listen-the-Part"><a href="#How-to-Listen-the-Part" class="headerlink" title="How to Listen the Part"></a>How to Listen the Part</h5><p>从前面小节的代码中我们可以看出，对于监听来说，<code>net/http</code>包中有一个专用的API<code>ListenAndServe</code>来进行处理。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(addr <span class="hljs-type">string</span>, handler Handler)</span></span> <span class="hljs-type">error</span> {<br>  server := &amp;Server{Addr: addr, Handler: handler}<br>  <span class="hljs-keyword">return</span> server.ListenAndServe()<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>ListenAndServe</code>会初始化一个<code>sever</code>对象，然后调用了<code>Server</code>对象的方法<code>ListenAndServe</code>。其源码如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> ListenAndServe() <span class="hljs-type">error</span>{<br>  <span class="hljs-comment">//对于Server对象的ListenAndServe方法。</span><br>  <span class="hljs-keyword">if</span> srv.shuttingDown() {<br>    <span class="hljs-keyword">return</span> ErrServerClosed<br>  }<br>  addr := srv.Addr<br>  <span class="hljs-keyword">if</span> addr == <span class="hljs-string">""</span> {<br>    addr = <span class="hljs-string">":http"</span><br>  }<br>  ln, err := net.Listen(<span class="hljs-string">"tcp"</span>, addr)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {  <br>    <span class="hljs-comment">//若err值不为空（出现了错误值）</span><br>    <span class="hljs-keyword">return</span> err<br>    <span class="hljs-comment">//返回错误值</span><br>  }<br>  <span class="hljs-keyword">return</span> srv.Serve(ln)<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>ListenAndServe</code>调用了<code>net.Listen("tcp, addr")</code>，也就是底层用TCP协议搭建了一个服务，最后调用<code>src.Serve</code>监控我们设置的端口。监控之后如何接受客户端的请求呢？</p><h5 id="How-to-Accept-the-Request-from-client-side"><a href="#How-to-Accept-the-Request-from-client-side" class="headerlink" title="How to Accept the Request from client-side"></a>How to Accept the Request from client-side</h5><p><code>Serve</code>的具体实现如下（仅包括关键代码），通过下面的分析源码我们可以看到客户端请求的具体处理过程：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> {<br>  ...<br>  <br>  ctx := context.WithValue(baseCtx, ServerContextKey, srv)<br>  <span class="hljs-keyword">for</span> {<br>    rw, err := l.Accept()<br>    ...<br>    connCtx := ctx<br>    <span class="hljs-keyword">if</span> cc := srv.ConnContext; cc != <span class="hljs-literal">nil</span> {<br>      connCtx = cc(connCtx, rw)<br>      <span class="hljs-keyword">if</span> connCtx == <span class="hljs-literal">nil</span> {<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"ConnContext returned nil"</span>)<br>      }<br>    }<br>    tempDelay = <span class="hljs-number">0</span><br>    c := srv.newConn(rw)<br>    c.setState(c.rwc, stateNew, runHooks) <span class="hljs-comment">//before Serve can return </span><br>    <span class="hljs-keyword">go</span> c.serve(connCtx)<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这个函数利用了for循环，首先通过Listener接受请求<code>l.Accept()</code>，其次创建一个Conn：<code>c := srv.newConn(rw)</code> ，最后单独开了一个goroutine，把这个请求的数据当成参数扔给这个conn去服务：<code>go c.serve(connCtx)</code>。这个就是对于高并发的体现。用户的每一次请求都是在一个新的goroutine去服务，相互不影响。</p><h5 id="How-to-distribute-the-function-to-solve-request"><a href="#How-to-distribute-the-function-to-solve-request" class="headerlink" title="How to distribute the function to solve request."></a>How to distribute the function to solve request.</h5><p>那么如何分配具体的函数来处理请求呢？我们继续分析conn的<code>serve</code>方法，其源码如下（仅展示关键代码）：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> serve(ctx context.Context) {<br>  ...<br>  <br>  ctx, cancelCtx := context.WithCancel(ctx)<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;How-the-Web-Works&quot;&gt;&lt;a href=&quot;#How-the-Web-Works&quot; class=&quot;headerlink&quot; title=&quot;How the Web Works?&quot;&gt;&lt;/a&gt;How the Web Works?&lt;/h2&gt;&lt;p&gt;平时在上网的时候</summary>
      
    
    
    
    
    <category term="Project-Web" scheme="http://example.com/tags/Project-Web/"/>
    
  </entry>
  
  <entry>
    <title>Routing for Web Developer</title>
    <link href="http://example.com/2022/03/08/Routing-for-Web-Developer/"/>
    <id>http://example.com/2022/03/08/Routing-for-Web-Developer/</id>
    <published>2022-03-08T01:38:20.000Z</published>
    <updated>2022-03-14T09:26:51.349Z</updated>
    
    <content type="html"><![CDATA[<p>在web开发过程中，经常会遇到“路由”（Routing）的概念。路由到底是什么？简单来说，路由就是URL到函数的映射。是用来跟后端服务器进行交互的一种方式，通过不同的路径来请求不同的资源，请求不同的页面。ネットワーク上でデータを転送する際、その経路を導き出すことを<em>ルーティング</em>と呼びます。</p><h3 id="The-Flow-Path-of-Routing"><a href="#The-Flow-Path-of-Routing" class="headerlink" title="The Flow Path of Routing"></a>The Flow Path of Routing</h3><ol><li>服务器发出请求。</li><li>服务器端监听到80端口（http）或者443端口（https）有请求，并且解析URL路径。</li><li>根据服务器的路由配置，返回相应信息（html / json / image）。</li><li>浏览器根据数据包的content-type来决定如何解析数据。</li></ol><h3 id="The-Difference-between-Router-and-Route"><a href="#The-Difference-between-Router-and-Route" class="headerlink" title="The Difference between Router and Route"></a>The Difference between Router and Route</h3><p>route 就是一条路由，将一条URL路径与一个函数进行映射，例如</p><p><code> /users -&gt; getAlUsers()</code> </p><p><code>/users/count -&gt; getUsersCount()</code></p><p>这就是两条路由，访问users时，将会执行getAllUsers()函数；当访问 /users/count时，会执行getUsersCount()函数</p><p>而router（路由器）可以理解为一个容器，或者说一种机制，他管理了一组route。route执行的过程是由router来处理的。”The router routes you to a route.”</p><h3 id="The-Route-of-Server"><a href="#The-Route-of-Server" class="headerlink" title="The Route of Server"></a>The Route of Server</h3><p>对于服务器来说，当接收到客户端发来的http请求，会根据请求的URL，来找到相应的映射函数，并且执行，将返回值发回客户端。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">app.<span class="hljs-built_in">get</span>(<span class="hljs-string">'/'</span>, (req, res)=&gt;{undefined<br><br>res.<span class="hljs-built_in">sendFile</span>(<span class="hljs-string">'index'</span>)<br><br>})<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">app.<span class="hljs-built_in">get</span>(<span class="hljs-string">'/users'</span>, (req,res)=&gt;{undefined<br>db.<span class="hljs-built_in">queryAllUsers</span>()<br>.<span class="hljs-built_in">then</span>(data =&gt; res,<span class="hljs-built_in">send</span>(data))<br>})<br></code></pre></td></tr></tbody></table></figure><p>这里定义了两条路由，访问<code>/</code>时，会返回index界面；访问<code>/users</code>时，会从数据库中读取所有的用户数据并返回。</p><h3 id="Dynamic-Router-と-Static-Router"><a href="#Dynamic-Router-と-Static-Router" class="headerlink" title="Dynamic Router と Static Router"></a>Dynamic Router と Static Router</h3><h4 id="Static-Router"><a href="#Static-Router" class="headerlink" title="Static Router"></a>Static Router</h4><p>静态路由是由管理员手工配置的，简单直接，是什么就是什么。但缺点在于如果网络拓扑发生变化/故障时静态路由也得由管理员亲手修改。</p><p>举个例子来说，就像公交车一样，路线与停靠站都是决定好的，就算有近路或者路线被堵了也只能按照规定好的路线走。</p><p>对于家用路由器来说每个家用路由中都有一条设定好的默认路由。默认添加了一条指向wan口的默认路由。因为没有第二条路走所以大丈夫。</p><h4 id="Dynamic-Router"><a href="#Dynamic-Router" class="headerlink" title="Dynamic Router"></a>Dynamic Router</h4><p>现在我们来到一座陌生的城市，我们用google map进行导航。这里面，googlemap其实分了两步操作。第一步手机会自动下载我们周围的道路信息，第二步是根据算法计算出一条最好的路径去目的地。</p><p>动态路由适合大型网络，不需要手动添加路由条目，方便管理。</p><p>就好比出租车，会抄近路，也可以看路况抄近路，出租车司机的路由表是随时更新的。动态路由的最大特点是路由器上运行路由协议，使路由器可以自动根据网络拓扑的变化调整路由条目。</p><p>动态路由的工作方式：第一步，路由器获得全网的拓扑，包含了所有路由器和路由器之间的链路信息，拓扑就是地图。</p><p>第二步，路由器在拓扑中计算出到达目的地网址的最优路径。</p><h4 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h4><p>优点：静态路由：简单、高效、可靠、网络安全、转发效率高。</p><p>​            动态路由：灵活，能够适应网络结构的变化，无需管理员手工维护，减轻了管理员的工作负担。</p><p>缺点：静态路由：不能灵活的适应网络动态变化</p><p>​            动态路由：占用网络带宽。（用于传输路由更新信息）</p><p>使用场景：静态路由：网络规模不大，拓扑结构固定的网络中。</p><p>​                     动态路由：网络规模大，网络拓扑机构复杂的网络。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在web开发过程中，经常会遇到“路由”（Routing）的概念。路由到底是什么？简单来说，路由就是URL到函数的映射。是用来跟后端服务器进行交互的一种方式，通过不同的路径来请求不同的资源，请求不同的页面。ネットワーク上でデータを転送する際、その経路を導き出すことを&lt;em&gt;ル</summary>
      
    
    
    
    
    <category term="Web_Developer" scheme="http://example.com/tags/Web-Developer/"/>
    
  </entry>
  
  <entry>
    <title>Gogee_Day1 HTTP基礎・APIの構築</title>
    <link href="http://example.com/2022/03/08/Gogee-Day1-HTTP%E5%9F%BA%E7%A4%8E%E3%83%BBAPI%E3%81%AE%E6%A7%8B%E7%AF%89/"/>
    <id>http://example.com/2022/03/08/Gogee-Day1-HTTP%E5%9F%BA%E7%A4%8E%E3%83%BBAPI%E3%81%AE%E6%A7%8B%E7%AF%89/</id>
    <published>2022-03-08T01:24:28.000Z</published>
    <updated>2022-03-09T02:53:42.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Goでウェブサービスを動かす"><a href="#Goでウェブサービスを動かす" class="headerlink" title="Goでウェブサービスを動かす"></a>Goでウェブサービスを動かす</h3><p>Go语言内置了<code>net/http</code>库，并且封装了http网络编程的基础接口。这样我们可以很便利的实现web接入。Gogee也是基于<code>net/http</code>的框架。举个例子：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"log"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br><span class="hljs-comment">// set 2 route- "/" and "/hello"</span><br>http.HandleFunc(<span class="hljs-string">"/"</span>, indexHandler)<br>http.HandleFunc(<span class="hljs-string">"/hello"</span>, helloHandler)<br><span class="hljs-comment">// launch web service</span><br><span class="hljs-comment">// :9999 : address AT 9999 port</span><br><span class="hljs-comment">// nil : solve instance by Standard library</span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">":9999"</span>, <span class="hljs-literal">nil</span>))<br>}<br><br><span class="hljs-comment">//handler echoes r.URL.Path</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">indexHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {<br>fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)<br>}<br><br><span class="hljs-comment">//handler echoes r.URL.Header</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header {<br>fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p>![截屏2022-03-08 11.44.50](Gogee-Day1-HTTP基礎・APIの構築/截屏2022-03-08 11.44.50.png)</p><h3 id="http-handler-API-の実現"><a href="#http-handler-API-の実現" class="headerlink" title="http.handler API の実現"></a>http.handler API の実現</h3><p>handler是什么呢？查看一下<code>net/http</code>的源码。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> http<br><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> {<br>  ServeHTTP(w ResponseWriter, r *Request)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-type">string</span>, h Handler)</span></span><span class="hljs-type">error</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Handler```是一个API，要求需要实现方法ServeHTTP，只要传入任何实现了ServeHTTP接口的实例，所有的HTTP请求就都交给该实例处理了。"><br>#### ServeHTTPとは<br><br>在Golang中，你要构建一个web服务，必然要用到```http.ListenAndServe```<br><br>对于```ListenAndServe```来说，他的方法签名为```http.ListenAndServe(address, handler)```<br><br>所以，如果想要用```ListenAndServe``` 两种方式。<br><br>1. 自己定一个struct，并在上面实现```ServeHTTP```方法。<br><br>   ```go<br>   type myhandler int<br>   <br>   func(m myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request){<br>     -, err := fmt.Fprintln(w, "hello this is golang ServeHTTP")<br>     if err != nil{<br>       fmt.Println("the error occured:", err)<br>     }else{<br>       fmt.Println("someone is accessing:" r.Method)<br>     }<br>   }<br>   <br>   func main(){<br>     var hello myHandler<br>     fmt.println("begin to listen")<br>     http.ListenAndServe(":9999", hello)<br>   }<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><p>使用nil作为handler。</p><p>nil在golang的http包下的server.go文件中有过定义。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span>{<br>handler = DefaultServeMux<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到在ListenAndServe中传入nil，本质上就是在调用DefaultServeMux</p></li></ol><p>所以，利用ListenAndServe的第一个特点，我们可以构建自己的struct<code>engine</code>，并在上面实现<code>Serve HTTP</code>。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"log"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-comment">// Engine is the uni handler for all requests</span><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span>{}<br><br><span class="hljs-comment">// ResponseWriter: create the response of this HTTP request.</span><br><span class="hljs-comment">// http.Request: all the information of this HTTP request. For example, the address, Header and Body</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request){<br><span class="hljs-keyword">switch</span> req.URL.Path{<br><span class="hljs-keyword">case</span> <span class="hljs-string">"/"</span>:<br>fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)<br><span class="hljs-keyword">case</span> <span class="hljs-string">"/hello"</span>:<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header{<br>fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)<br>}<br><span class="hljs-keyword">default</span>:<br>fmt.Fprintf(w, <span class="hljs-string">"404 NOT FOUND: %s\n"</span>, req.URL)<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br><br><span class="hljs-comment">// Transfer all the request to our own solution.</span><br>engine := <span class="hljs-built_in">new</span>(Engine)<br><span class="hljs-comment">// launch web service</span><br><span class="hljs-comment">// :9999 : address AT 9999 port</span><br><span class="hljs-comment">// </span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">":9999"</span>, engine))<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>在实现了engine之后，我们拦截了所有的HTTP请求，拥有了统一的控制入口，并且可以自由定义这些请求的路由映射的规则，或者统一处理他们。到这里我们就可以发现我们走出了实现web框架的第一步。</p><h3 id="Gogeeフレームワークの骨組み"><a href="#Gogeeフレームワークの骨組み" class="headerlink" title="Gogeeフレームワークの骨組み"></a>Gogeeフレームワークの骨組み</h3><p>我们所设想的框架目录结构是这样的。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">Gogee/<br>   |--Gogee.<span class="hljs-keyword">go</span><br>   |--<span class="hljs-keyword">go</span>.mod<br>main.<span class="hljs-keyword">go</span><br><span class="hljs-keyword">go</span>.mod<br></code></pre></td></tr></tbody></table></figure><p>把Gogee与main分开放两个文件夹的原因是 Go语言的package对于每个文件夹有且只能有一个，所以Gogee的package和main的package重复了</p><h4 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h4><p>借用go module来管理依赖</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">module Gogee<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.17</span><br><br>require Gogee v0<span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><br><span class="hljs-comment">// Reference relative path</span><br>replace Gogee =&gt; ./Gogee<br></code></pre></td></tr></tbody></table></figure><p>用<code>replace</code>将Gogee指向 <code>./Gogee</code></p><h4 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"net/http"</span><br><br><span class="hljs-string">"Gogee"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>r := Gogee.New()<br>r.GET(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {<br>fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)<br>})<br><br>r.GET(<span class="hljs-string">"/hello"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header {<br>fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)<br>}<br>})<br><br>r.Run(<span class="hljs-string">":9999"</span>)<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>使用<code>New()</code>创建Gogee的实例，使用<code>GET()</code>添加路由，最后使用<code>Run()</code>启动Web服务。（目前只是静态路由）</p><h4 id="Gogee-go"><a href="#Gogee-go" class="headerlink" title="Gogee.go"></a>Gogee.go</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> Gogee<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-comment">// HandlerFunc defines the request handler used by Gogee</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span><br><br><span class="hljs-comment">// Engine implement the interface of ServeHTTP</span><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span>{<br>router <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>}<br><br><span class="hljs-comment">// New is the constructor of Gogee.Engine</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine{<br><span class="hljs-keyword">return</span> &amp;Engine{router: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc)}<br>}<br><br><span class="hljs-comment">// addRoute is the way to add something to route</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc){<br>key := method + <span class="hljs-string">"-"</span> + pattern<br>engine.router[key] = handler<br>}<br><br><span class="hljs-comment">// GET defines the method to add GET request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc){<br>engine.addRoute(<span class="hljs-string">"GET"</span>, pattern, handler)<br>}<br><br><span class="hljs-comment">//POST defines the method to POST request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc){<br>engine.addRoute(<span class="hljs-string">"POST"</span>, pattern, handler)<br>}<br><br><span class="hljs-comment">//Run definesd the method to start a http server</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>){<br><span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>}<br><br><span class="hljs-comment">// To use the ListenAndServe, we need to set a ServeHTTP struct</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) {<br>key := req.Method + <span class="hljs-string">"-"</span> + req.URL.Path<br><span class="hljs-keyword">if</span> handler, ok := engine.router[key]; ok {<br>handler(w, req)<br>} <span class="hljs-keyword">else</span> {<br>w.WriteHeader(http.StatusNotFound)<br>fmt.Fprintf(w, <span class="hljs-string">"404 MOT FOUND: %s\n"</span>, req.URL)<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p>首先定义了type <code>HandlerFunc</code>，这是提供给框架用户的，用来定义路由映射的处理方法。</p><p>我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>， key由请求方法与静态路由地址构成，比如<code>GET-/</code>、<code>GET-/hello</code>、<code>POST-/hello</code>，这样针对相同的路由，如果请求的方式不同，可以映射不同的Handler</p><p>当用户调用<code>(*Engine).GET()</code>方法时，会将路由和处理方法注册到router中（addroute方法）。<code>(*Engine).Run()</code>方法，是ListenAndServe的封装。</p><p><code>Engine</code>实现的ServeHTTP方法的作用是解析请求的路径，查找router，如果查到，执行注册的处理方法，如果查不到，返回404 NOT FOUND。</p><p>执行<code>go run main.go</code>再用<code>curl</code>访问即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Goでウェブサービスを動かす&quot;&gt;&lt;a href=&quot;#Goでウェブサービスを動かす&quot; class=&quot;headerlink&quot; title=&quot;Goでウェブサービスを動かす&quot;&gt;&lt;/a&gt;Goでウェブサービスを動かす&lt;/h3&gt;&lt;p&gt;Go语言内置了&lt;code&gt;net/http&lt;</summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>GoでWebフレームワークを書く</title>
    <link href="http://example.com/2022/03/08/Go%E3%81%A7Web%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%92%E6%9B%B8%E3%81%8F/"/>
    <id>http://example.com/2022/03/08/Go%E3%81%A7Web%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%92%E6%9B%B8%E3%81%8F/</id>
    <published>2022-03-08T01:09:47.000Z</published>
    <updated>2022-03-16T00:07:09.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Goを使ってWebフレームワークを作りましょう"><a href="#Goを使ってWebフレームワークを作りましょう" class="headerlink" title="Goを使ってWebフレームワークを作りましょう"></a>Goを使ってWebフレームワークを作りましょう</h1><p>最近Go言語には興味があり、GoでWebサービスを構築できるようになるために、GinのWebフレームワークを学んでいます。Ginの特性は深く理解できるのため、Goで自分のWebフレームワークを作ってみようと思います。「Gogee」と言います。GogeeのコードはGinのソースコードを研究して得たもので、あくまで学習用として使用しています。</p><h2 id="カタログ"><a href="#カタログ" class="headerlink" title="カタログ"></a>カタログ</h2><p><a href="https://xiaogeamadeus.github.io/2022/03/08/Gogee-Day1-HTTP%E5%9F%BA%E7%A4%8E%E3%83%BBAPI%E3%81%AE%E6%A7%8B%E7%AF%89/">DAY 1：HTTP基礎・APIの構築</a></p><p><a href="https://xiaogeamadeus.github.io/2022/03/09/Gogee-Day2-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88/">DAY 2：コンテキスト</a></p><p><a href="https://xiaogeamadeus.github.io/2022/03/14/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/">DAY 3：Trie木ルータ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Goを使ってWebフレームワークを作りましょう&quot;&gt;&lt;a href=&quot;#Goを使ってWebフレームワークを作りましょう&quot; class=&quot;headerlink&quot; title=&quot;Goを使ってWebフレームワークを作りましょう&quot;&gt;&lt;/a&gt;Goを使ってWebフレームワークを</summary>
      
    
    
    
    
    <category term="Project-Go" scheme="http://example.com/tags/Project-Go/"/>
    
  </entry>
  
  <entry>
    <title>Map &amp; Collection</title>
    <link href="http://example.com/2022/03/01/Map-Collection/"/>
    <id>http://example.com/2022/03/01/Map-Collection/</id>
    <published>2022-03-01T07:53:50.000Z</published>
    <updated>2022-03-01T08:14:20.554Z</updated>
    
    <content type="html"><![CDATA[<p>　この記事は、日本語やプログラミングスキルを向上するために書きました。著者は中国出身ですから、言語、文法のミスがいっぱいあるかもしれない…</p><h1 id="Map-と-Collection-のまとめ（自分用）"><a href="#Map-と-Collection-のまとめ（自分用）" class="headerlink" title="Map と Collection のまとめ（自分用）"></a>Map と Collection のまとめ（自分用）</h1><p>一种优化查询时间的常用方法 ——Map。</p><p>预处理线性，查询时间为对数。</p><p>Map：成对的元素，每个元素由键与值构成。</p><p><code>&lt;index, value&gt;</code></p><p>Collection：孤立的元素，只包含元素的值。</p><p><code>&lt;value&gt;</code></p><p><strong>注意： Map中的值可以重复，但键不允许重复。</strong></p><p>常用的Map集合：HashMap/ LinkedHashMap</p><h4 id="HashMap-方法"><a href="#HashMap-方法" class="headerlink" title="HashMap 方法"></a>HashMap 方法</h4><p>HashMap&lt;k, v&gt; 采用哈希表结构存储数据，元素的存取顺序不能保证是一致的</p><h4 id="LinkedHashMap-方法"><a href="#LinkedHashMap-方法" class="headerlink" title="LinkedHashMap 方法"></a>LinkedHashMap 方法</h4><p>LinkedHashMap&lt;k, v&gt; 采用哈希表+链表结构存储数据，可以保证元素的存取顺序一致</p><h2 id="Map结构的API"><a href="#Map结构的API" class="headerlink" title="Map结构的API"></a>Map结构的API</h2><p>get(Object k)：返回指定键所映射的值</p><p>put(key k, value v)：将值与映射中的键关联</p><p>remove(Object k)：如果存在一个键为k的映射关系，将其删除</p><p>clear()：删除Map中所有键/值对</p><h2 id="Map集合遍历键找值方式"><a href="#Map集合遍历键找值方式" class="headerlink" title="Map集合遍历键找值方式"></a>Map集合遍历键找值方式</h2><h2 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a>Map集合遍历键值对方式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;　この記事は、日本語やプログラミングスキルを向上するために書きました。著者は中国出身ですから、言語、文法のミスがいっぱいあるかもしれない…&lt;/p&gt;
&lt;h1 id=&quot;Map-と-Collection-のまとめ（自分用）&quot;&gt;&lt;a href=&quot;#Map-と-Collection-</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>AWS Solutions Architect Associate C02</title>
    <link href="http://example.com/2022/02/26/AWS-Solutions-Architect-Associate-C02/"/>
    <id>http://example.com/2022/02/26/AWS-Solutions-Architect-Associate-C02/</id>
    <published>2022-02-26T04:21:45.000Z</published>
    <updated>2022-02-26T05:06:03.708Z</updated>
    
    <content type="html"><![CDATA[<p>　この記事は、AWS-SAAC02に関連するレビューの概要を記録しました。 英語試験を選択したため、英語/中国語で書きました。</p><h1 id="AWS-Solutions-Architect-Associate-C02"><a href="#AWS-Solutions-Architect-Associate-C02" class="headerlink" title="AWS Solutions Architect Associate C02"></a>AWS Solutions Architect Associate C02</h1><p>At the beginning, please remember that you’re a architect associate. So you just need to know how to construct <strong>scalable, highly available, cost-effective, secure, performant, resilient</strong> AWS structure. </p><h2 id="About-test"><a href="#About-test" class="headerlink" title="About test"></a>About test</h2><p><strong>170 min</strong> (If you aren’t a native speaker of English, the AWS will offer you extra time)</p><p><strong>65 questions</strong> (15 questions without points)</p><p><strong>1000 points</strong> (you need to gain more than 720 points to pass the exam)</p><p>From the exam guide, we can find that there is <strong>4 domains</strong> of AWS-SAA:</p><p>​      <strong>Domain 1:</strong> Design Resilient Architectures                              30%</p><p>​      <strong>Domain 2:</strong> Design High-performing Architectures               28%</p><p>​      <strong>Domain 3:</strong> Design Secure Applications and Architectures  24%</p><p>​      <strong>Domain 4:</strong> Design Cost-Optimized Architectures                 18%</p><h2 id="Overviews"><a href="#Overviews" class="headerlink" title="Overviews"></a>Overviews</h2><p>I divided the AWS for some parts: Compute, Storage, Network, Database, Security, Tools, Contains and Others.</p><p>​    <strong>Compute:</strong>   EC2, Elastic Beanstalk, Lambda</p><p>​    <strong>Storage:</strong>      EBS, EFS, S3, FsX, instance store, Glacier, Storage gateway</p><p>​    <strong>Network:</strong>     VPC, Route53, ELB</p><p>​    <strong>Database:</strong>   RDS, DynamoDB, Redshift, Elastic Cache, Aurora, Athena</p><p>​    <strong>Security:</strong>      IAM, plenty of Security Groups</p><p>​    <strong>Tools:</strong>          Cloud Watch</p><p>​    <strong>Contains:</strong>    ECS/EKS</p><p>​    <strong>Others:</strong>  </p><h3 id="Compute"><a href="#Compute" class="headerlink" title="Compute"></a>Compute</h3><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><h3 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h3><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;　この記事は、AWS-SAAC02に関連するレビューの概要を記録しました。 英語試験を選択したため、英語/中国語で書きました。&lt;/p&gt;
&lt;h1 id=&quot;AWS-Solutions-Architect-Associate-C02&quot;&gt;&lt;a href=&quot;#AWS-Solution</summary>
      
    
    
    
    
    <category term="AWS-SAAC02" scheme="http://example.com/tags/AWS-SAAC02/"/>
    
  </entry>
  
</feed>
