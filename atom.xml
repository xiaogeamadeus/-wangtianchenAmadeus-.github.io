<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WANG Tianchen</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-01T04:30:11.327Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Create Line Bot Endpoint</title>
    <link href="http://example.com/2022/07/01/Create-Line-Bot-Endpoint/"/>
    <id>http://example.com/2022/07/01/Create-Line-Bot-Endpoint/</id>
    <published>2022-07-01T04:22:12.000Z</published>
    <updated>2022-07-01T04:30:11.327Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developers.line.biz/en/docs/messaging-api/getting-started/">The Document of Line</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developers.line.biz/en/docs/messaging-api/getting-started/&quot;&gt;The Document of Line&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Develop" scheme="http://example.com/tags/Develop/"/>
    
  </entry>
  
  <entry>
    <title>Use Django to Develop Web Application</title>
    <link href="http://example.com/2022/05/24/Use-Django-to-Develop-Web-Application/"/>
    <id>http://example.com/2022/05/24/Use-Django-to-Develop-Web-Application/</id>
    <published>2022-05-24T08:56:53.000Z</published>
    <updated>2022-05-24T08:57:31.823Z</updated>
    
    
    
    
    
    <category term="Project-web" scheme="http://example.com/tags/Project-web/"/>
    
  </entry>
  
  <entry>
    <title>Breadth First Search-广度优先搜索</title>
    <link href="http://example.com/2022/05/16/Breadth-First-Search-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://example.com/2022/05/16/Breadth-First-Search-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2022-05-15T15:32:37.000Z</published>
    <updated>2022-06-03T13:52:13.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Breadth-First-Search-广度优先搜索"><a href="#Breadth-First-Search-广度优先搜索" class="headerlink" title="Breadth First Search - 广度优先搜索"></a>Breadth First Search - 广度优先搜索</h1><h3 id="BFS的核心思想"><a href="#BFS的核心思想" class="headerlink" title="BFS的核心思想"></a>BFS的核心思想</h3><p>把一些问题抽象成图，从一个点开始，向四周开始扩散。所以一般来说我们写BFS都是用队列这种数据结构，每次将一个节点周围的所有节点加入队列。</p><h3 id="BFS与DFS的区别"><a href="#BFS与DFS的区别" class="headerlink" title="BFS与DFS的区别"></a>BFS与DFS的区别</h3><p>BFS找到的路径一定是最短的，但代价就是空间复杂度很高。</p><h4 id="为什么BFS可以找到最短路径，DFS不行吗？"><a href="#为什么BFS可以找到最短路径，DFS不行吗？" class="headerlink" title="为什么BFS可以找到最短路径，DFS不行吗？"></a>为什么BFS可以找到最短路径，DFS不行吗？</h4><p>DFS实际上是靠递归的对栈记录走过的路径，你要找到最短路径就得把二叉树中所有树杈都探索完，才能对比出来。时间复杂度会很高。但BFS可以借助队列做到一次一步，齐头并进，是可以在不遍历完整树的条件下找到最短距离的。</p><h4 id="既然BFS那么好，为啥DFS还存在？"><a href="#既然BFS那么好，为啥DFS还存在？" class="headerlink" title="既然BFS那么好，为啥DFS还存在？"></a>既然BFS那么好，为啥DFS还存在？</h4><p>DFS的空间复杂度较低。</p><p>处理二叉树的例子，假如是个满二叉树，节点数为<code>N</code>，对于DFS算法来说，空间复杂度无非就是递归对栈，最坏情况树的高度<code>O(logN)</code></p><p>但对于BFS算法，队列中每次都会储存着二叉树一层的节点，这样最坏情况下空间复杂度应该是树的最底层节点的数量<code>N/2</code>，那就是<code>O(N)</code></p><p>由此观之，一般在找最短路径用BFS，其他时候DFS多一些。</p><h3 id="BFS出现的常见场景"><a href="#BFS出现的常见场景" class="headerlink" title="BFS出现的常见场景"></a>BFS出现的常见场景</h3><p>问题的本质就是让你在一幅「图」中找到从起点<code>start</code>到终点<code>target</code>的最短距离。</p><h3 id="BFS的基础框架"><a href="#BFS的基础框架" class="headerlink" title="BFS的基础框架"></a>BFS的基础框架</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Node start, Node target)</span> {<br>    Queue&lt;Node&gt; q; <span class="hljs-comment">// 核心数据结构</span><br>    Set&lt;Node&gt; visited; <span class="hljs-comment">// 避免走回头路</span><br>    <br>    q.offer(start); <span class="hljs-comment">// 将起点加入队列</span><br>    visited.add(start);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录扩散的步数</span><br><br>    <span class="hljs-keyword">while</span> (q not empty) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>        <span class="hljs-comment">/* 将当前队列中的所有节点向四周扩散 */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) {<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>            <span class="hljs-comment">/* 划重点：这里判断是否到达终点 */</span><br>            <span class="hljs-keyword">if</span> (cur is target)<br>                <span class="hljs-keyword">return</span> step;<br>            <span class="hljs-comment">/* 将 cur 的相邻节点加入队列 */</span><br>            <span class="hljs-keyword">for</span> (Node x : cur.adj()) {<br>                <span class="hljs-keyword">if</span> (x not in visited) {<br>                    q.offer(x);<br>                    visited.add(x);<br>                }<br>            }<br>        }<br>        <span class="hljs-comment">/* 划重点：更新步数在这里 */</span><br>        step++;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="BFS的基础思路"><a href="#BFS的基础思路" class="headerlink" title="BFS的基础思路"></a>BFS的基础思路</h3><p>用<code>Queue</code>储存每次的路径。</p><p>用<code>HashSet</code>储存访问过的节点（命名为<code>visited</code>）以防走回头路。</p><p>注：遍历二叉树等不存在回头路的情况时，不需要考虑<code>visited</code>储存的方式。</p><p>注2: 遍历二叉树时，一般可以用while控制深度，用for控制广度。for完一层，while下一层，这样的逻辑。</p><h3 id="BFS刷题清单"><a href="#BFS刷题清单" class="headerlink" title="BFS刷题清单"></a>BFS刷题清单</h3><p><a href="https://github.com/xiaogeamadeus/Leetcode_Answer/blob/main/112Path%20Sum">LC112</a></p><p>在基础的bfs上，用一个队列记录每个节点的累加值，这样就避免了值的过度累计（因为每层只需要一个 但遍历了所有，不好实现）</p><p><a href="https://github.com/xiaogeamadeus/Leetcode_Answer/blob/main/117Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II">LC117</a></p><p>大致思路依旧是在bfs框架上做操作。节点操作思路是先设置一个前置节点，让前置节点连接cur，然后再将他所连接的cur变成后置节点。</p><p><a href="https://github.com/xiaogeamadeus/Leetcode_Answer/blob/main/200_Number%20of%20Islands">LC200</a></p><p>不能死板的卡在原有的bfs模版上，说白了bfs就是一种暴力的遍历罢了。对于这道题来说，先遍历所有的1，然后找到1之后对其做有限界的bfs，然后修改数组/用一个boolean数组记录。直到遍历所有的。</p><p>顺带学到了一种对于二维数组的bfs框架方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; neighbors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">// 用r*n+c进行记录 r是row c是column。然后求除/或者取余就行。</span><br>neighbors.offer(r * n + c);<br><span class="hljs-keyword">while</span> (!neighbors.isEmpty()) {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> neighbors.poll();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> id / n;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> id % n;<br>    <span class="hljs-keyword">if</span> (row - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row-<span class="hljs-number">1</span>][col] == <span class="hljs-string">'1'</span>) {<br>       neighbors.offer((row-<span class="hljs-number">1</span>)*n + col);<br>       grid[row-<span class="hljs-number">1</span>][col] = <span class="hljs-string">'0'</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (row + <span class="hljs-number">1</span> &lt; m &amp;&amp; grid[row+<span class="hljs-number">1</span>][col] == <span class="hljs-string">'1'</span>) {<br>       neighbors.offer((row+<span class="hljs-number">1</span>)*n + col);<br>       grid[row+<span class="hljs-number">1</span>][col] = <span class="hljs-string">'0'</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (col - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row][col-<span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>) {<br>       neighbors.offer(row*n + col - <span class="hljs-number">1</span>);<br>       grid[row][col-<span class="hljs-number">1</span>] = <span class="hljs-string">'0'</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (col + <span class="hljs-number">1</span> &lt; n &amp;&amp; grid[row][col+<span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>) {<br>       neighbors.offer(row*n + col + <span class="hljs-number">1</span>);<br>       grid[row][col+<span class="hljs-number">1</span>] = <span class="hljs-string">'0'</span>;<br>    }<br></code></pre></td></tr></tbody></table></figure><p><a href="https://github.com/xiaogeamadeus/Leetcode_Answer/tree/main">LC207</a></p><p>拓扑排序(Topological ordering)：一个有向无环图(DAG, Directed Acyclic Graph)的所有顶点的线性序列。且该序列满足：</p><ol><li>每个顶点出现且只出现一次</li><li>若存在一条从顶点A到顶点B的路径，那么在序列中顶点A出现在顶点B的前面。</li></ol><p>注：只要这个图是DAG，那么他至少有一条拓扑排序。相反，我们也可以利用他是否有拓扑排序来验证该图是否有环。</p><p>这个题蛮有意思，可以用BFS也可以用DFS。我先用BFS做一下。</p><p>思路很重要。我们只要能够证明遍历完整张图我都无法找到一条拓扑排序，就能代表这张图不是DAG。反之，只要能够找到任意一条，就能证明这张图是DAG。</p><p>那么遍历方式可以利用BFS。</p><ol><li>首先，将所有初始入度为0的节点放入队列中（若没有的话直接false，因为有环）。</li><li>然后取出队列中的节点，逐一消除掉与他相关的边（即将与这个节点相连的节点的入度-1）</li><li>在这个过程中如果有新的节点的度数为0，则将新的节点加入队列当中。循环直到队列中没有节点，并且在这个过程中计算节点数。</li><li>判断遍历过的节点数。如果所有节点都被遍历完成，代表我们找到了一条拓扑排序。</li></ol><p>时间复杂度：<code>O(N+M)</code>最坏情况就是遍历完所有节点和所有边，然后节点数为N，边数为M。</p><p>空间复杂度：利用了一个<code>ArrayList&lt;ArrayList&lt;Integer&gt;&gt;</code>结构，外层的arraylist是N个节点，里层的是M条边。所以依旧是<code>O(N+M)</code></p><p><a href="https://github.com/xiaogeamadeus/Leetcode_Answer/blob/main/301Remove%20Invalid%20Parentheses">LC301</a></p><p>很有意思的题，虽然是道hard，但本质其实就是一道easy+一道medium。首先你要会判断一个包含括号的字符串是否valid，然后可以利用BFS/回溯+剪枝完成一个遍历。</p><p>遍历方式是每轮删除一个括号，然后存到set中。之后遍历Set判断，合法的就存，不合法的就扔。删除字符串的方式也蛮有趣，选择了子字符串+子字符串。</p><p><a href="">LC399</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Breadth-First-Search-广度优先搜索&quot;&gt;&lt;a href=&quot;#Breadth-First-Search-广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;Breadth First Search - 广度优先搜索&quot;&gt;&lt;/a&gt;Bre</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode备考计划</title>
    <link href="http://example.com/2022/05/14/Leetcode%E5%A4%87%E8%80%83%E8%AE%A1%E5%88%92/"/>
    <id>http://example.com/2022/05/14/Leetcode%E5%A4%87%E8%80%83%E8%AE%A1%E5%88%92/</id>
    <published>2022-05-14T00:49:57.000Z</published>
    <updated>2022-05-14T06:04:22.434Z</updated>
    
    <content type="html"><![CDATA[<p>背景：代码基础为学校授课水平，刷题量近乎为0。</p><p>目标：2023年招聘时能够达到通过外企代码要求水平。</p><p>时间长度：2022年2月 - 2023年3月</p><h2 id="“归纳流”方法论概要"><a href="#“归纳流”方法论概要" class="headerlink" title="“归纳流”方法论概要"></a>“归纳流”方法论概要</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>始终保持<strong>匀速前进</strong>，即不松懈倦怠，亦不急于求成。</li><li>定时<strong>归纳</strong>总结，按类训练。</li><li>按照记忆<strong>高频率高效复习</strong>。</li><li><strong>拥抱孤独</strong>，过滤杂音，放平心态。</li></ol><h3 id="1-始终保持匀速前进"><a href="#1-始终保持匀速前进" class="headerlink" title="1 始终保持匀速前进"></a>1 始终保持匀速前进</h3><p>对于lc来说题海流不可取，一天刷20道也并不会让你再次面对面试/OA的时候能够有思路熟练的解决，保证刷题质量是关键，这一点得到了多位上岸前辈的确认。当然这并不代表刷100道就能过了…总而言之是牢记追求的不是刷了一千道一万道，而是通过OA和面试。</p><p>匀速前进也是最关键的事情。Greedy在这件事上不可取，动态规划追求最好的整体效果才是关键，目光要放长远。每个人每天的精力是有限且平均的。今天的事超标了，看似赚了，实际上是在透支明天自己的精力，透支一次就会打乱一次结构，整体来看对于大目标的实现毫无疑问是副作用。这一招只适合在 最后冲刺前/ ddl前/ final前 的终结技。一周一小停，一月一大停非常之效率低。</p><p>目前看上去对我个人来说，工作日2道+复习，休息日4道+复习可能是极限了。</p><p>注1：归纳法的参考结构： 早上两题，写完休息；下午两题，复习早上的，写完休息。晚上复习归纳一整天做的题。</p><p>注2：自己的时间规划还可以进行调整，实习面试比较多，确实有点难办。</p><p>注3：暂定时间规划如下：</p><p>workday：早起床1；下午1+复习早上； 晚复习全天</p><p>weekend：早起床2；下午2+复习早上；晚复习全天+周赛</p><h3 id="2-定时归纳总结，按类训练"><a href="#2-定时归纳总结，按类训练" class="headerlink" title="2 定时归纳总结，按类训练"></a>2 定时归纳总结，按类训练</h3><p>尝试在同类事物中挖掘普遍规律，并利用该规律高效地解决更多同类问题。</p><p>刷题一定要同类型一起刷，在进行了大量针对性的同类型训练后，隐藏在事物深层的普遍规律往往会自然而然浮出表面。这时候进行总结归纳是最好的正反馈。</p><p>注：定期归纳的参考结构：一段时间内（5-7天）只做该类型题目，结合其他高质量题解以及labuladong/代码随想录等，加上自身的见解总结出自己的框架。</p><h3 id="3-高频率高效复习"><a href="#3-高频率高效复习" class="headerlink" title="3  高频率高效复习"></a>3  高频率高效复习</h3><p>为了将做题的记忆转化为长期记忆，频繁且有效的重复刺激即可。所以复习旧题的重要性要远大于做新题。</p><p>每一区段刷少量题+复习上一区段</p><p>把自己想象成一个正在运行机器学习的机器。只会背诵训练集的劣质模型没有意义，尝试理解和归纳你手中的“数据”。</p><h3 id="4-拥抱孤独，过滤杂音"><a href="#4-拥抱孤独，过滤杂音" class="headerlink" title="4 拥抱孤独，过滤杂音"></a>4 拥抱孤独，过滤杂音</h3><p>减少无效信息的获取。</p><p>减少无意义社交与社交媒体的使用。</p><p>倾听内心的声音。</p><p><strong>你不需要任何庇护，倘若能够利用好资源，不断强大自身的毅力和内心，再配合正确的方法，你已具备进入谷歌的一切潜质。</strong></p><p>长期的保持一个节奏，贯彻一个方案，不因取得的阶段性成就而大喜，亦不因遭受阶段性挫折而大悲，当进入这个状态之后，那么离你的目标就真的不再遥远了。</p><p>高考我惨败，修考小负，但具有了堂堂正正跟他们站在同一个擂台的入场券。</p><p>这第三场，让我们来看看我这个混凝土出身的双非小子有没有办法跟你们站在同一个高度吧。</p><h2 id="时间规划记录"><a href="#时间规划记录" class="headerlink" title="时间规划记录"></a>时间规划记录</h2><h4 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h4><p>2月 - 3月中旬：方向走错，刷题量 &lt; 50，AtCoder AB秒C做不出来水平</p><p>3月下旬 - 5月：想明白要全力刷题了，开学+搬家+打疫苗事情太多，刷题量80</p><p>5月：计划 完成所有tag一轮，包括dp和greedy、backtracking之类的，同时每日一题完成。注：按照归纳流的方法，除去满课的周二之外争取工作日每天刷两道+复习，周末4道+复习+周赛。</p><p>6月：准备Amazon实习，AmazonHot 100+面经+题库</p><p>7月：同上，刷题内容未定+final</p><p>8月-9月：有实习的日子同上，没实习的日子按休息日进行。内容暂定是tag复习+剑指之类的</p><p>10月：Nintendo实习选考，准备乐天正选考</p><p>…</p><h4 id="2023年"><a href="#2023年" class="headerlink" title="2023年"></a>2023年</h4><p>2月-3月 旧题巩固，tag三轮，每日一题，面经+题库</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>主要Tag清单：</p><ul><li>排序（merge，快排，快选）</li><li>二分</li><li>前缀和</li><li>差分（一维和二维）</li><li>双指针（滑动窗口）</li><li>区间合并</li><li>单调栈</li><li>单调队列</li><li>并查集</li><li>KMP</li><li>堆</li><li>哈希表（set/map）红黑树</li><li>图论（最短路径、生成树）</li><li>DP、Greedy、Backtracking</li><li>数论</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;背景：代码基础为学校授课水平，刷题量近乎为0。&lt;/p&gt;
&lt;p&gt;目标：2023年招聘时能够达到通过外企代码要求水平。&lt;/p&gt;
&lt;p&gt;时间长度：2022年2月 - 2023年3月&lt;/p&gt;
&lt;h2 id=&quot;“归纳流”方法论概要&quot;&gt;&lt;a href=&quot;#“归纳流”方法论概要&quot; cla</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://example.com/2022/05/10/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2022/05/10/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2022-05-10T14:32:07.000Z</published>
    <updated>2022-05-14T06:22:30.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈和队列总结"><a href="#栈和队列总结" class="headerlink" title="栈和队列总结"></a>栈和队列总结</h1><p>栈和队列的原理很清晰，队列先进先出，栈后进先出。</p><p>这两种数据结构底层其实都是数组/链表实现的，只是API限制了他们的特性。</p><h2 id="栈的经典题目"><a href="#栈的经典题目" class="headerlink" title="栈的经典题目"></a>栈的经典题目</h2><p>注：栈内元素在内存中并不是连续分布。</p><p>232 225 是处理学习栈和队列底层实现的好题目。一个是用栈来实现队列，一个是用队列来实现栈。</p><h3 id="栈在系统中的应用"><a href="#栈在系统中的应用" class="headerlink" title="栈在系统中的应用"></a>栈在系统中的应用</h3><ol><li><p>LC20 系统是如何处理括号、花括号的。写代码前分析好有哪几种不匹配的情况。第一种：字符串中左方向的括号多余了，bupipei；第二种，括号没有多余，但类型不匹配；第三种，字符串中右括号多余了，所以不匹配。</p></li><li><p>LC71 linux系统又是如何利用cd进入目录的</p></li></ol><p>初次之外，递归的实现是栈 ：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中。然后递归返回的时候，从栈顶弹出上一次递归的各项参数。这就是为什么递归可以返回上一层位置的原因。</p><h3 id="字符串去重问题"><a href="#字符串去重问题" class="headerlink" title="字符串去重问题"></a>字符串去重问题</h3><p>LC1047 把字符串顺序放到一个栈中，相同的话栈就弹出，最后栈里剩下的元素就是相邻不相同的了。</p><h3 id="逆波兰表达式问题"><a href="#逆波兰表达式问题" class="headerlink" title="逆波兰表达式问题"></a>逆波兰表达式问题</h3><p>计算的公式，将数字放在前，符号放在后，这样的字符串用对栈计算效率最高。</p><h2 id="队列的经典题目"><a href="#队列的经典题目" class="headerlink" title="队列的经典题目"></a>队列的经典题目</h2><h3 id="滑动窗口最大值问题"><a href="#滑动窗口最大值问题" class="headerlink" title="滑动窗口最大值问题"></a>滑动窗口最大值问题</h3><p>LC239 单调队列</p><p>队列没有必要维护窗口里的所有元素，只要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</p><p>那么这个维护元素单调递减的队列就叫做单调队列，即单调递减或单调递增的队列。</p><h3 id="求前k个高频元素"><a href="#求前k个高频元素" class="headerlink" title="求前k个高频元素"></a>求前k个高频元素</h3><p>LC347 优先级队列</p><p>什么是优先级队列呢？</p><p>就是一个披着外皮的堆，因为优先级队列的对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，所以看起来就像一个队列。</p><p>优先级队列内部是按照元素的权值排列，权值可以自己定义。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈和队列总结&quot;&gt;&lt;a href=&quot;#栈和队列总结&quot; class=&quot;headerlink&quot; title=&quot;栈和队列总结&quot;&gt;&lt;/a&gt;栈和队列总结&lt;/h1&gt;&lt;p&gt;栈和队列的原理很清晰，队列先进先出，栈后进先出。&lt;/p&gt;
&lt;p&gt;这两种数据结构底层其实都是数组/链表实现的，</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>字符串总结</title>
    <link href="http://example.com/2022/05/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/05/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-05T07:13:45.000Z</published>
    <updated>2022-05-05T07:14:07.059Z</updated>
    
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Create API by Python</title>
    <link href="http://example.com/2022/05/03/Create-API-by-Python/"/>
    <id>http://example.com/2022/05/03/Create-API-by-Python/</id>
    <published>2022-05-02T23:52:08.000Z</published>
    <updated>2022-07-05T06:32:10.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Framework：Django"><a href="#Framework：Django" class="headerlink" title="Framework：Django"></a>Framework：Django</h2><p>The Description of Django: </p><p>Django is a open-source web application framework writted by Python.</p><p>Django is based on <strong>MVC model</strong> (MVC = Model + View + Controller)</p><p>The merits of Django:</p><ol><li>Powerful database functions </li><li>Powerful backend functions</li><li>Elegant URL</li></ol><h3 id="MVC-model"><a href="#MVC-model" class="headerlink" title="MVC model"></a>MVC model</h3><p>The diagram of MVC model.</p><p>![截屏2022-05-03 09.06.44](Create-API-by-Python/截屏2022-05-03 09.06.44.png)</p><p>The merits of MVC model:</p><ol><li>low coupling</li><li>Fast development</li><li>Easy to deploy</li><li>High reusability</li><li>Low maintenance cost</li></ol><h3 id="Install-django-for-mac-with-anaconda-environment"><a href="#Install-django-for-mac-with-anaconda-environment" class="headerlink" title="Install django for mac with anaconda environment"></a>Install django for mac with anaconda environment</h3><p>Open the terminal of Pycharm and write:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shall">pip install Django<br><br>pip install djangorestframework<br></code></pre></td></tr></tbody></table></figure><p> Then we are ready to finish the installation.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Framework：Django&quot;&gt;&lt;a href=&quot;#Framework：Django&quot; class=&quot;headerlink&quot; title=&quot;Framework：Django&quot;&gt;&lt;/a&gt;Framework：Django&lt;/h2&gt;&lt;p&gt;The Descriptio</summary>
      
    
    
    
    
    <category term="Project-Python" scheme="http://example.com/tags/Project-Python/"/>
    
  </entry>
  
  <entry>
    <title>算法基础模版</title>
    <link href="http://example.com/2022/05/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A8%A1%E7%89%88/"/>
    <id>http://example.com/2022/05/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A8%A1%E7%89%88/</id>
    <published>2022-05-02T10:16:41.000Z</published>
    <updated>2022-05-04T14:47:49.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法基础模版"><a href="#算法基础模版" class="headerlink" title="算法基础模版"></a>算法基础模版</h2><p>个人学习总结所用，无版权，来自于Yjy佬个人总结。</p><h3 id="前缀和（Prefix-sum）"><a href="#前缀和（Prefix-sum）" class="headerlink" title="前缀和（Prefix sum）"></a>前缀和（Prefix sum）</h3><p>前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和。</p><h4 id="一维数组中的前缀和"><a href="#一维数组中的前缀和" class="headerlink" title="一维数组中的前缀和"></a>一维数组中的前缀和</h4><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">LeetCode 303</a></p><p>一维数组前缀和模版：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prefixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>{<br>  <span class="hljs-type">int</span>[] B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[A.length + <span class="hljs-number">1</span>];<br>  <br>  B[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; B.length; i++) {<br>    B[i] = B[i - <span class="hljs-number">1</span>] + A[i - <span class="hljs-number">1</span>];<br>  }<br>  <span class="hljs-keyword">return</span> B[right + <span class="hljs-number">1</span>] - B[left]<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="二维数组中的前缀和"><a href="#二维数组中的前缀和" class="headerlink" title="二维数组中的前缀和"></a>二维数组中的前缀和</h4><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">LeetCode304</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prefixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] A, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> {<br>  <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> A.length;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> A[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-type">int</span>[][] B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) {<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>      B[i][j] = B[i-<span class="hljs-number">1</span>][j] + B[i][j-<span class="hljs-number">1</span>] + A[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] - B[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>    }<br>  }<br>  <br>  <span class="hljs-keyword">return</span> B[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] - B[x2+<span class="hljs-number">1</span>][y1] - B[x1][y2+<span class="hljs-number">1</span>] + B[x1][y1];<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="和为K的字数组"><a href="#和为K的字数组" class="headerlink" title="和为K的字数组"></a>和为K的字数组</h4><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">LeetCode560</a></p><p>两数之和+前缀和</p><p>两数之和就是哈希表存值出现的次数，然后加入，然后再加上前缀和可以实现O(n)的时间复杂度。</p><p>如果不加哈希表，用双循环+前缀和就是O(n^2)，不是很理想</p><h2 id="差分数组-Difference-Array"><a href="#差分数组-Difference-Array" class="headerlink" title="差分数组(Difference Array)"></a>差分数组(Difference Array)</h2><p>差分数组的思想是基于前缀和的，主要适用于频繁对原始数组的某个区间的元素进行增减。</p><p><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">Leetcode1109</a></p><p><a href="https://leetcode-cn.com/problems/car-pooling/">Leetcode1094</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] difference(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> val) {<br>  <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>  diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-comment">// 差分数组初始化</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) {<br>    diff[i] = nums[i] - nums[i-<span class="hljs-number">1</span>];<br>  }<br>  <br>  <span class="hljs-comment">// 加减值</span><br>  diff[x1] += val;<br>  <span class="hljs-keyword">if</span>(x2 + <span class="hljs-number">1</span> &lt; diff.length)<br>    diff[x2 + <span class="hljs-number">1</span>] -= val;<br>  <br>  <span class="hljs-comment">// 输出数组为差分数组的和</span><br>  <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[diff.length];<br>  res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; diff.length; i++) {<br>    res[i] = res[i - <span class="hljs-number">1</span>] + diff[i];<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="快速排序、归并排序、快速选择"><a href="#快速排序、归并排序、快速选择" class="headerlink" title="快速排序、归并排序、快速选择"></a>快速排序、归并排序、快速选择</h2><p><a href="https://leetcode-cn.com/problems/sort-an-array/">Leetcode912</a></p><h4 id="快速排序模版："><a href="#快速排序模版：" class="headerlink" title="快速排序模版："></a>快速排序模版：</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">quickSort</span>{<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) {<br>    <span class="hljs-comment">// Shuffle the array.</span><br>    shuffle(nums);<br>    sort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>  }<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> {<br>    <span class="hljs-keyword">if</span> (lo &gt; hi) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(nums, lo, hi);<br>    sort(nums, lo, p-<span class="hljs-number">1</span>);<br>    sort(nums, p+<span class="hljs-number">1</span>, hi);<br>  }<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[lo];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lo + <span class="hljs-number">1</span>, j = hi;<br>    <br>    <span class="hljs-keyword">while</span> (i&lt;=j) {<br>      <span class="hljs-keyword">while</span>(i &lt; hi &amp;&amp; nums[i] &lt;= pivot){<br>        i++;<br>      }<br>      <br>      <span class="hljs-keyword">while</span>(j &gt; lo &amp;&amp; nums[j] &gt; pivot) {<br>        j--;<br>      }<br>      <br>      <span class="hljs-keyword">if</span>(i&gt;=j) {<br>        <span class="hljs-keyword">break</span>;<br>      }<br>      swap(nums, i, j);<br>    }<br>    swap(nums, lo, j);<br>    <span class="hljs-keyword">return</span> j;<br>  }<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;n; i++) {<br>      <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i + rand.nextInt(n - i);<br>      swap(nums, i, r);<br>    }<br>    <br>  }<br>  <span class="hljs-comment">// Swap the two element of array.</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>  }<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="归并排序模版"><a href="#归并排序模版" class="headerlink" title="归并排序模版"></a>归并排序模版</h4><p><a href="https://leetcode-cn.com/problems/sort-an-array/">Leetcode912</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">mergeSort</span>{<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] temp;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>{<br>    temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <br>    sort(nums, <span class="hljs-number">0</span>, nums.length-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span>;<br>  }<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span>{<br>    <span class="hljs-keyword">if</span>(lo == hi) {<br>      <span class="hljs-keyword">return</span>;<br>    }<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lo + (hi-lo)/<span class="hljs-number">2</span>;<br>    sort(nums, lo, mid);<br>    sort(nums, mid+<span class="hljs-number">1</span>, hi);<br>    merge(nums, lo, mid, hi);<br>  }<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> hi)</span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lo; i &lt;= hi; i++){<br>      temp[i] = nums[i];<br>    }<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lo, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> lo; p &lt; hi; p++){<br>      <span class="hljs-keyword">if</span>(i == mid + <span class="hljs-number">1</span>) {<br>        nums[p] = temp[i++];<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == hi + <span class="hljs-number">1</span>){<br>        nums[p] = temp[j++];<br>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp[i] &gt; temp[j]){<br>        nums[p] = nums[j++];<br>      } <span class="hljs-keyword">else</span> {<br>        nums[p] = nums[i++];<br>      }<br>    }<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="快速选择模版"><a href="#快速选择模版" class="headerlink" title="快速选择模版"></a>快速选择模版</h4><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指Offer40</a></p><p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Leetcode215</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">topK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> {<br>        shuffle(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hi = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span>  partition(nums, lo, hi);<br>        <span class="hljs-keyword">while</span>(lo &lt;= hi){<br>            <span class="hljs-keyword">if</span>(p&lt;k){<br>                hi = p-<span class="hljs-number">1</span>;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p&gt;k){<br>                lo = p+<span class="hljs-number">1</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">return</span> nums[p];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[lo];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>  lo + <span class="hljs-number">1</span>, j = hi;<br><br>        <span class="hljs-keyword">while</span>(i&lt;=j) {<br>            <span class="hljs-keyword">while</span>(i &lt; hi &amp;&amp; nums[i] &lt;= pivot){<br>                i++;<br>            }<br>            <span class="hljs-keyword">while</span> (j &gt; lo &amp;&amp; nums[j] &gt; pivot) {<br>                j--;<br>            }<br><br>            <span class="hljs-keyword">if</span>(i&gt;=j) <span class="hljs-keyword">break</span>;<br><br>            swap(nums, i, j);<br>        }<br>        swap(nums, j, lo);<br>        <span class="hljs-keyword">return</span> j;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>{<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;nums.length; i++) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i + rand.nextInt(nums.length - i);<br>            swap(nums, i, r);<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>{<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="逆序对-Reverse-pairs"><a href="#逆序对-Reverse-pairs" class="headerlink" title="逆序对(Reverse pairs)"></a>逆序对(Reverse pairs)</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/">剑指offer51</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法基础模版&quot;&gt;&lt;a href=&quot;#算法基础模版&quot; class=&quot;headerlink&quot; title=&quot;算法基础模版&quot;&gt;&lt;/a&gt;算法基础模版&lt;/h2&gt;&lt;p&gt;个人学习总结所用，无版权，来自于Yjy佬个人总结。&lt;/p&gt;
&lt;h3 id=&quot;前缀和（Prefix-sum）&quot;</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Groulette</title>
    <link href="http://example.com/2022/04/26/Groulette/"/>
    <id>http://example.com/2022/04/26/Groulette/</id>
    <published>2022-04-26T13:14:44.000Z</published>
    <updated>2022-04-26T13:15:46.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Groulette"><a href="#Groulette" class="headerlink" title="Groulette"></a>Groulette</h2><p>京都大学の5人のチームの一員として、現在、Grouletteの開発が進められています。</p><p><a href="https://github.com/xiaogeamadeus/groulette_backend">Github_Backend</a></p><h3 id="ごはんやさんルーレット（ぐるーれっと）"><a href="#ごはんやさんルーレット（ぐるーれっと）" class="headerlink" title="ごはんやさんルーレット（ぐるーれっと）"></a>ごはんやさんルーレット（ぐるーれっと）</h3><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>・ご飯を食べに行く店をルーレットで決定してくれるwebアプリ</p><p>・ジャンル、値段、評価選択⇨ルーレット作成⇨回す⇨その店を表示</p><p>・条件に合ったレストランの中から、ランダムに１０個程度を選択肢、ルーレットを作成する。</p><p>・営業時間外のお店を除外する</p><p>・追加機能、「Dangerous」「Normal」「Recommend」3種類のリストを選択する。</p><p>・追加機能、好きではない店はバツする。</p><p>・ユーザーログイン機能も追加する。お客様過去の記録によって、ルーレットは別々だ。 </p><p>3種類の推薦アルゴリズムの実装、店のデータベースの構築、フロントエンドから送られてくるrequestを受け付けるAPIの作成、Google Map APIへの地図データのrequests送信など、バックエンドの開発は私に担当しています。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Groulette&quot;&gt;&lt;a href=&quot;#Groulette&quot; class=&quot;headerlink&quot; title=&quot;Groulette&quot;&gt;&lt;/a&gt;Groulette&lt;/h2&gt;&lt;p&gt;京都大学の5人のチームの一員として、現在、Grouletteの開発が進められています</summary>
      
    
    
    
    
    <category term="Project-Python" scheme="http://example.com/tags/Project-Python/"/>
    
  </entry>
  
  <entry>
    <title>Formal Language Theory</title>
    <link href="http://example.com/2022/04/22/Formal-Language-Theory/"/>
    <id>http://example.com/2022/04/22/Formal-Language-Theory/</id>
    <published>2022-04-22T13:08:38.000Z</published>
    <updated>2022-04-24T06:44:32.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Formal-Language-Theory-形式语言理论"><a href="#Formal-Language-Theory-形式语言理论" class="headerlink" title="Formal Language Theory 形式语言理论"></a>Formal Language Theory 形式语言理论</h1><h3 id="什么是形式语言？-x2F-语言的形式定义"><a href="#什么是形式语言？-x2F-语言的形式定义" class="headerlink" title="什么是形式语言？/ 语言的形式定义"></a>什么是形式语言？/ 语言的形式定义</h3><p> 形式语言（Formal Language）是用精确的数学/及其可处理的公式定义的语言。一般作为一个集合出现。</p><p>语言定义在某一个特定的字母表上，字母表可以为任意有限集合（一般由$\Sigma$表示）。例如集合${a, b, c…, z}$就表示所有小写字母构成的字母表。</p><p>而字符串就是字母表中元素构成的有穷序列。</p><p>所以直觉上，一个语言是字母表所能构成的所有串的集合的一个子集。</p><h3 id="语言的表示方法"><a href="#语言的表示方法" class="headerlink" title="语言的表示方法"></a>语言的表示方法</h3><p>不像自然语言，一个形式语言作为一个集合，需要有某种明确的标准来定义一个字符串是否是他的元素。定义方法主要有如下几种。</p><ul><li>枚举法</li><li>形式文法（Formal Grammars，也叫做Phrase Structure Grammars）</li><li>正则文法（Regular Grammars）</li><li>自动机（图灵机、有限状态自动机）（Automata）</li></ul><!--注：在NLP中，S表示句子；NP/VP/PP是名词短语、动词短语、介词短语（短语级别）；N/V/P分别是名词、动词、介词--><h2 id="Formal-Grammars-（形式文法）"><a href="#Formal-Grammars-（形式文法）" class="headerlink" title="Formal Grammars （形式文法）"></a>Formal Grammars （形式文法）</h2><p>在形式语言理论中，形式文法是形式语言中字符串的一套产生式规则(Production Rules)。这些规则描述了如何用语言的字母表生成复合语法的有效字符串。</p><p>文法不描述字符串的含义，也不描述任何上下文中可以用他们做什么，只描述他们的形式。</p><p>![截屏2022-04-22 22.35.39](Formal-Language-Theory/截屏2022-04-22 22.35.39.png)</p><h3 id="Phrase-Structure-Grammar（句子结构语法）"><a href="#Phrase-Structure-Grammar（句子结构语法）" class="headerlink" title="Phrase Structure Grammar（句子结构语法）"></a>Phrase Structure Grammar（句子结构语法）</h3><p>$G = &lt;N, T, P, S&gt;$</p><p>G：一个有限语法集合</p><p>N： 一个非终端标记(Nonterminal Symbol)的有限集合</p><p>T：一个终端标记(Terminal Symbol)的有限集合</p><p>P：一个生成规则的有限集合</p><p>$\alpha\to\beta$     $\alpha\in(N\cup T)$     $\beta\in(N\cup T)$</p><p>S：启动标记</p><h2 id="有限自动机（Finite-Automata）与正则文法"><a href="#有限自动机（Finite-Automata）与正则文法" class="headerlink" title="有限自动机（Finite Automata）与正则文法"></a>有限自动机（Finite Automata）与正则文法</h2><h3 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h3><p>有限自动机分为两种：确定的有限自动机(Definite Automata, DFA)和不确定的有限自动机(Non-definite Automata, NFA)</p><h4 id="DFA（确定的有限自动机）"><a href="#DFA（确定的有限自动机）" class="headerlink" title="DFA（确定的有限自动机）"></a>DFA（确定的有限自动机）</h4><p>确定的有限自动机$M$是一个五元组：</p><p>$M=(\Sigma, Q, \delta,q_0,F)$</p><ul><li>$\Sigma$是输入符号的有穷集合；</li><li>$Q$是状态的有限集合；</li><li>$q_0\in Q$是初始状态；</li><li>$F$是终止状态集合，$F\subseteq Q$；</li><li>$\delta$是$Q$ 与$\Sigma$的直积$Q\times E$到$Q$（下一个状态）的映射。它支配着有限状态控制的行为，有时也被称为状态转移函数。</li></ul><p>![截屏2022-04-23 09.23.00](Formal-Language-Theory/截屏2022-04-23 09.23.00.png)</p><p>DFA如上图所示。</p><p>处在状态$q\in Q$中的有限控制器从左到右依次从输入带上读入字符。开始时有限控制器处在状态$q_0$，并注视$\Sigma$中一个链的最左符号。</p><p>映射$\delta(q,a)=q^1(q,q^1\in Q, a\in \Sigma)$表示在状态$q$时，若输入符号为$a$，则自动机进入状态$q^1$并且将输入头向右移动一个字符。</p><p>如下所示的状态转移符</p><p>![截屏2022-04-23 09.32.56](Formal-Language-Theory/截屏2022-04-23 09.33.05.png)</p><p>![截屏2022-04-23 09.33.25](Formal-Language-Theory/截屏2022-04-23 09.33.25.png)</p><p>为了明确起见，开始用箭头，终止用双圈。</p><p><strong>DFA定义的语言：</strong>如果一个句子$x$使得有限自动机$M$有$\delta(q_0,a)=p,p\in F$则称句子$x$被$M$接受。由$M$定义的语言$T(M)$就是被$M$接受的句子的全集。即：</p><p>$T(M) ={x|\delta(q_0,x)\in F}$</p><p>对于上面的图来说，链$x=aaa$或$x = bbb$都可以被$M$接受</p><h4 id="NFA（不确定的有限自动机）"><a href="#NFA（不确定的有限自动机）" class="headerlink" title="NFA（不确定的有限自动机）"></a>NFA（不确定的有限自动机）</h4><p>不确定的有限自动机$M$是一个五元组：</p><p>$M=(\Sigma, Q, \delta,q_0,F)$</p><ul><li>$\Sigma$是输入符号的有穷集合；</li><li>$Q$是状态的有限集合；</li><li>$q_0\in Q$是初始状态；</li><li>$F$是终止状态集合，$F\subseteq Q$；</li><li>$\delta$是$Q$ 与$\Sigma$的直积$Q\times E$到$Q$（下一个状态）的<strong>幂集</strong>$2^Q$的映射。</li></ul><p>NFA和DFA的唯一区别是：在NFA中$\delta(q,a)$是一个状态集合，而在DFA中$\delta(q,a)$是一个状态。</p><h3 id="正则文法-regular-Grammars"><a href="#正则文法-regular-Grammars" class="headerlink" title="正则文法(regular Grammars)"></a>正则文法(regular Grammars)</h3><p>正则文法分为两种类型。</p><p>第一类要求生成式的形式必须是$A\to \omega B$或$A\to \omega$。其中$A, B$都是变元，$\omega$是Terminal Symbol（可以为空）这种特殊的正则文法被称为右线形（右正则）文法。</p><p>第二类则形式相反，要求必须是$A\to B\omega $或$A\to \omega$的形式被称为左线形（左正则文法）</p><p>由正则文法生成的语言被称为正则语言，是有穷自动机所识别的语言类型。</p><p>$A\to aB$, $A\to a$    $A,B\in N$, $a\in T$ (Right-regular grammar)</p><p>$G:S\to aA$    $S\to bB$</p><p>​       $A\to aA$   $A\to a$</p><p>​       $B\to bB$    $B\to b$  </p><p>最后一定会等于$a^nb^n$</p><h3 id="正则文法与有限自动机的关系"><a href="#正则文法与有限自动机的关系" class="headerlink" title="正则文法与有限自动机的关系"></a>正则文法与有限自动机的关系</h3><h4 id="1-正则文法—-gt-自动机"><a href="#1-正则文法—-gt-自动机" class="headerlink" title="1. 正则文法—>自动机"></a>1. 正则文法—&gt;自动机</h4><p>定理：</p><p>若$G=(V_N,V_T,P,S)$是一个正则文法，则存在一个有限自动机$M=(\Sigma,Q,\delta,q_0,F)$，使得：$T(M)=L(G)$。</p><h4 id="2-自动机—-gt-正则文法"><a href="#2-自动机—-gt-正则文法" class="headerlink" title="2. 自动机—>正则文法"></a>2. 自动机—&gt;正则文法</h4><p>若$M=(\Sigma,Q,\delta,q_0,F)$是一个有限自动机，则存在一个正则文法$G=(V_N,V_T,P,S)$，使得：$L(G)=T(M)$。</p><h2 id="文法的分类系统：乔姆斯基谱系-Chomsky-Hierarchy"><a href="#文法的分类系统：乔姆斯基谱系-Chomsky-Hierarchy" class="headerlink" title="文法的分类系统：乔姆斯基谱系(Chomsky Hierarchy)"></a>文法的分类系统：乔姆斯基谱系(Chomsky Hierarchy)</h2><p>乔姆斯基谱系将所有的文法分成四种类型：</p><ul><li>无限制文法(No Restriction)</li><li>上下文相关文法(Context-sensitive)</li><li>上下文无关文法(Context-free)</li><li>正则文法(Regular)</li></ul><h3 id="上下文无关文法-Context-free-Grammars-CFG"><a href="#上下文无关文法-Context-free-Grammars-CFG" class="headerlink" title="上下文无关文法(Context-free Grammars, CFG)"></a>上下文无关文法(Context-free Grammars, CFG)</h3><p>若一个形式文法$G = (N,\Sigma,P,S)$的产生式规则都取如下的形式：</p><p>$V\to w(V\in N, w\in (N\cup\Sigma)^*)$</p><p>则被称为上下文无关。</p><p>解决如下几个问题：</p><ol><li>上下文是什么？</li></ol><p>在应用一个产生式进行推导时，前后已经推导出的部分结果就是上下文。</p><ol start="2"><li>什么是上下文无关？</li></ol><p>只要文法的定义中有某个产生式，不管一个非终结符前后的串是什么，都可以应用相应的产生式进行推导。从形式上看，就是产生式的左边都是单独一个非终结符，即形如$S\to …,$而不是非终结符左右还有点别的东西，例如$aSb\to…$</p><p>举个例子：</p><p>$S\to aSb$</p><p>$S\to ab$</p><p>这个文法有两个产生式，每个产生式左边都只有一个非终结符$S$，这就是上下文无关文法。因为你只要找到符合产生式右边的串，就可以把它归为对应的非终结符。</p><p>再举一个例子：</p><p>$aSb\to aaSbb$</p><p>$S\to ab$</p><p>这就是上下文相关文法，因为它的第一个产生式左边不止一个符号。所以你在匹配这个产生式中的S的时候需要考虑他的“上下文”。</p><h4 id="CFG的范式"><a href="#CFG的范式" class="headerlink" title="CFG的范式"></a>CFG的范式</h4><p>每一个不生成空串的上下文无关文法都可以转化为等价的Chomsk y范式或者Greibach范式。（注：两个文法等价指它们能够生成相同的语言。）</p><p>Chomsky Normal Form (CNF)</p><p>A CFG in Chomsky Normal Form (CNF) allows only two kinds of right-hand sides;</p><p>$A\to BC | a$</p><p>$A\to x$</p><p>$A\to \epsilon$</p><p>其中大写字母为非终结符，小写字母为终结符，$\epsilon$为空串(Empty productions)，$S$是开始符号。因为空串可以被随意删除，一般情况下我们假设语法中不包含空串。</p><p>Greibach Normal Form (GNF)</p><p>$A\to a\alpha,\alpha\in N^*$</p><h4 id="CFG的分类"><a href="#CFG的分类" class="headerlink" title="CFG的分类"></a>CFG的分类</h4><p>含糊不清的语法(Ambiguous Grammar)</p><ul><li>可以利用naive parsing</li></ul><p>无歧义的语法(Unambiguous Grammar)</p><ul><li><p>确定性的CFG(Deterministic CFG)</p><p>​         LL语法，LR语法</p></li><li><p>非决定性的CFG(Non-deterministic CFG)</p></li></ul><h2 id="CYK算法"><a href="#CYK算法" class="headerlink" title="CYK算法"></a>CYK算法</h2><p>是一个用来判定任意给定的字符串是否属于一个上下文无关文法的算法。/是用来对上下文无关文法进行句法分析(Parsing)的算法。</p><p>（句法分析是自然语言处理中的关键技术之一，其基本任务是确定句子的句法结构(Syntatic Structure)或句子中词汇之间的依存关系。）</p><p>普通的回溯法(Backtracking)在最坏的情况下需要指数时间才能解决这样的问题，而CYK算法只需要多项式时间就够了$O(n^3)$（$n$为字符串$w$的长度）。CYK算法采用了动态规划的思想。</p><p>对于一个任意给定的上下文无关文法，都可以使用CYK算法来计算上述问题，但首先要将该文法转换为乔姆斯基范式。</p><h3 id="CFG转化为CNF"><a href="#CFG转化为CNF" class="headerlink" title="CFG转化为CNF"></a>CFG转化为CNF</h3><p>Change grammar so all rules of form $A\to BC$ or $A\to a$</p><ul><li>Step 1: Convert $A\to Bc$ to $A\to BC, C\to c$ </li><li>Step 2: Convert $A\to BCD$ to $A\to BX, X\to CD$</li></ul><h3 id="CKY算法特点"><a href="#CKY算法特点" class="headerlink" title="CKY算法特点"></a>CKY算法特点</h3><ol><li><p>Bottom-up parsing：（注，自底而上的含义为从单词开始，朝$S$（句子）工作）</p><p>​     start with the words</p></li><li><p>Dynamic Programming:</p><p>​    save the result in a table/chart</p><p>​    re-use these results in finding larger constituents</p></li><li><p>Complexity: $O(n^3|G|)$</p><p>​    $n$: length of string, $|G|$: size of grammar</p></li><li><p>Presumes a CFG in CHomsky Normal Form:</p><p>​    Rules are all either $A\to BC$ or $A\to a$</p><p>with $A,B,C$ nonterminals and $a$ terminal</p></li></ol><h3 id="CKY算法流程"><a href="#CKY算法流程" class="headerlink" title="CKY算法流程"></a>CKY算法流程</h3><ol><li><p><strong>Create the chart</strong></p><p>(an $n\times n$ upper triangular matrix for an sentence with $n$ words)</p><p>Each cell $chart[i][j]$ corresponds to the substring$w^{(i)}…w^{(j)}$</p></li><li><p><strong>Initialize the chart</strong> (fill the diagonal cells $chart[i][i]$):</p><p>For all rules $X\to w^{(i)}$, add an entry $X$ to $chart[i][j]$</p></li><li><p><strong>Fill in the chart:</strong></p><p>Fill in all cells $chart[i][i+1]$, then $chart[i][i+2],…., $</p><p>until you reach $chart[1][n]$ (the top right corner of the chart)</p><ul><li>To fill $chart[i][j]$ consider all binary splits$w^{(i)}…w^{(k)}|w^{(k+1)}…w^{(j)}$</li><li>If the grammar has a rule $X\to YZ$, $chart[i][k]$ contains a $Y$ and $chart[k+1][j]$ contains a $Z$, add an $X$ to $chart[i][j]$ with two backpointers to the $Y$ in $chart[i][k]$ and the $Z$ in $chart[k+1][j]$</li></ul></li><li><p><strong>Extract the parse trees</strong> from the $S$ in $chart[1][n]$</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Formal-Language-Theory-形式语言理论&quot;&gt;&lt;a href=&quot;#Formal-Language-Theory-形式语言理论&quot; class=&quot;headerlink&quot; title=&quot;Formal Language Theory 形式语言理论&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="NLP" scheme="http://example.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>哈希表_总结</title>
    <link href="http://example.com/2022/04/21/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/04/21/%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-21T14:38:56.000Z</published>
    <updated>2022-06-03T14:25:27.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表-Hash-Table"><a href="#哈希表-Hash-Table" class="headerlink" title="哈希表(Hash Table)"></a>哈希表(Hash Table)</h2><h3 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h3><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p><p>简单来讲，数组就是一种哈希表。哈希表中关键码就是数组的索引下标，通过下标直接访问数组中的元素。</p><h3 id="哈希表一般用于解决什么问题？"><a href="#哈希表一般用于解决什么问题？" class="headerlink" title="哈希表一般用于解决什么问题？"></a>哈希表一般用于解决什么问题？</h3><p>用来快速判断一个元素是否出现在集合里。O(1)就可以做到，无需遍历。但需要额外空间。</p><h3 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h3><p>当我们想用哈希法解决问题的时候，一般会选择如下三种关系结构。</p><ul><li>数组</li><li>set 集合</li><li>map 映射</li></ul><p>set只能储存一种值，但map可以储存一个<code>&lt;key, value&gt;</code>的键值对</p><h3 id="哈希表经典题目"><a href="#哈希表经典题目" class="headerlink" title="哈希表经典题目"></a>哈希表经典题目</h3><h4 id="数组作为哈希表"><a href="#数组作为哈希表" class="headerlink" title="数组作为哈希表"></a>数组作为哈希表</h4><p>242， 383</p><p>一些应用场景就是为数组量身定做的，比如要求只有小写字母。</p><p>虽然这两道题用Map也可以解决，但map消耗空间更大。</p><h4 id="Set作为哈希表"><a href="#Set作为哈希表" class="headerlink" title="Set作为哈希表"></a>Set作为哈希表</h4><p>349, 202</p><p>当数组大小没有被限制的时候，就无法使用数组做哈希表了。</p><p>主要原因有如下两点：</p><ul><li>数组的大小受限，受到系统栈空间的限制</li><li>如果数组空间足够大，但哈希值比较少，比较分散，跨度非常大，使用数组会造成空间的极大浪费。</li></ul><h4 id="Map作为哈希表"><a href="#Map作为哈希表" class="headerlink" title="Map作为哈希表"></a>Map作为哈希表</h4><p>1, 454, 18, 15</p><p>使用数组和哈希set也有自身的局限。</p><ul><li>数组的大小受限值，如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>Set是一个集合，里面放的元素只能是一个key。而两数之和不仅要判断y是否存在，还要记录y的下标并返回，所以无法用set。</li></ul><p>map是一种&lt;key, value&gt;的结构，本题可以用key保存数值，并用value来保存数值所在的下标。</p><p>但面对三数之和，四数之和的时候，虽然哈希表依旧可以解决，但非常麻烦，代码效率很低。</p><p>所以在18， 15两道题中推荐使用双指针。</p><h4 id="刷题清单-题解"><a href="#刷题清单-题解" class="headerlink" title="刷题清单+题解"></a>刷题清单+题解</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;哈希表-Hash-Table&quot;&gt;&lt;a href=&quot;#哈希表-Hash-Table&quot; class=&quot;headerlink&quot; title=&quot;哈希表(Hash Table)&quot;&gt;&lt;/a&gt;哈希表(Hash Table)&lt;/h2&gt;&lt;h3 id=&quot;什么是哈希表&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Git for PyCharm</title>
    <link href="http://example.com/2022/04/18/Git-for-PyCharm/"/>
    <id>http://example.com/2022/04/18/Git-for-PyCharm/</id>
    <published>2022-04-18T00:33:53.000Z</published>
    <updated>2022-04-18T00:44:19.549Z</updated>
    
    <content type="html"><![CDATA[<p>在利用<code>Python</code>进行日常开发中，经常会使用<code>Git</code>来管理项目，IDE使用<code>PyCharm</code>，<code>PyCharm</code>中的<code>Git</code>操作可以节约我们用shell打代码的时间。</p><p>IDE: PyCharm</p><p>OS: MacOS</p><h2 id="拉取仓库"><a href="#拉取仓库" class="headerlink" title="拉取仓库"></a>拉取仓库</h2><p>利用PyCharm使用<code>Git clone</code>的方法：</p><p>直接选择左上角<code>Git</code>，然后克隆，输入克隆地址即可。</p><h2 id="Git-commit"><a href="#Git-commit" class="headerlink" title="Git commit"></a>Git commit</h2><p>修改好文件之后需要<code>commit</code>操作。</p><p>打开<code>commit</code>窗口</p><h3 id="添加到-gitignore"><a href="#添加到-gitignore" class="headerlink" title="添加到.gitignore"></a>添加到.gitignore</h3><p>选中需要添加到<code>.gitignore</code>的文件，鼠标右键选择<code>add to .gitignore</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在利用&lt;code&gt;Python&lt;/code&gt;进行日常开发中，经常会使用&lt;code&gt;Git&lt;/code&gt;来管理项目，IDE使用&lt;code&gt;PyCharm&lt;/code&gt;，&lt;code&gt;PyCharm&lt;/code&gt;中的&lt;code&gt;Git&lt;/code&gt;操作可以节约我们用shell打代</summary>
      
    
    
    
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Numpy &amp; Matplotlib for Python</title>
    <link href="http://example.com/2022/04/17/Numpy-Matplotlib-for-Python/"/>
    <id>http://example.com/2022/04/17/Numpy-Matplotlib-for-Python/</id>
    <published>2022-04-17T01:00:30.000Z</published>
    <updated>2022-04-17T01:47:37.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NumPy-amp-Matplotlib-for-Python"><a href="#NumPy-amp-Matplotlib-for-Python" class="headerlink" title="NumPy &amp; Matplotlib for Python"></a>NumPy &amp; Matplotlib for Python</h2><p>写在前面：</p><p>本篇文章为个人学习总结所用。</p><p>使用环境：Anaconda + Python3.7 + Jupyter notebook + Tensorflow</p><p><strong>NumPy 与 Matplotlib一同创造了一个MATLAB的完全替代品。配合Jupiter-notebook一同使用可以在数据处理上达到令人满意的效果。</strong></p><h3 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h3><p>NumPy最重要的一个特点是其N维数组对象ndarray，是一系列同类型数据的集合。</p><p>创建一个ndarray只需要调用NumPy的array函数即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 一维数组</span><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span> (a)<br><span class="hljs-comment"># 输出结果：[1 2 3]</span><br><br><span class="hljs-comment"># 多于一个维度</span><br>a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])<br><span class="hljs-comment"># 输出结果：[[1 2]</span><br><span class="hljs-comment">#           [3 4]]</span><br><br><span class="hljs-comment"># 最小维度</span><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], ndmin = <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> (a)<br><span class="hljs-comment"># 输出结果：[[1 2 3 4 5]]（这是一个二维数组，但是第二行没有赋值）</span><br><br><span class="hljs-comment"># dtype参数</span><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype = <span class="hljs-built_in">complex</span>)<br><span class="hljs-built_in">print</span> (a)<br><span class="hljs-comment"># 输出结果：[1.+0.j 2.+0.j 3.+0.j]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>Matplotlib 是 Python 的绘图库。通常和NumPy共同进行使用。</p><p>Pyplot是Matplotlib的子库，提供了和Matlab类似的绘图API</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># plot()方法绘制二维图形</span><br>xpoints = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">6</span>])<br>ypoints = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">100</span>])<br><br>plt.plot(xpoints, ypoints)<br>plt.show()<br><span class="hljs-comment"># 得到一个(0,0) 到 (6,100) 的直线</span><br></code></pre></td></tr></tbody></table></figure><p>plot函数可以绘制点和线，语法格式如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画单条线</span><br>plt.plot([x], y, [fmt], *, data=<span class="hljs-literal">None</span>, **kwargs)<br><span class="hljs-comment"># 画多条线</span><br>plt.plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)<br></code></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li>x, y：点或线的节点。x为x轴数据，y为y轴数据，数据可以列表或数组。</li><li>fmt：可选，定义基本格式（颜色，标记和线条样式）</li><li>**kwargs：可选，用在二维平面图上，设置指定属性，如标签和线的宽度。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>plot(x, y)        <span class="hljs-comment"># 创建 y 中数据与 x 中对应值的二维线图，使用默认样式</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>plot(x, y, <span class="hljs-string">'bo'</span>)  <span class="hljs-comment"># 创建 y 中数据与 x 中对应值的二维线图，使用蓝色实心圈绘制</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>plot(y)           <span class="hljs-comment"># x 的值为 0..N-1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>plot(y, <span class="hljs-string">'r+'</span>)     <span class="hljs-comment"># 使用红色 + 号</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NumPy-amp-Matplotlib-for-Python&quot;&gt;&lt;a href=&quot;#NumPy-amp-Matplotlib-for-Python&quot; class=&quot;headerlink&quot; title=&quot;NumPy &amp;amp; Matplotlib for Pyt</summary>
      
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda for Mac</title>
    <link href="http://example.com/2022/04/16/Anaconda-for-Mac/"/>
    <id>http://example.com/2022/04/16/Anaconda-for-Mac/</id>
    <published>2022-04-16T13:53:57.000Z</published>
    <updated>2022-04-16T14:40:43.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anaconda-使用教程"><a href="#Anaconda-使用教程" class="headerlink" title="Anaconda 使用教程"></a>Anaconda 使用教程</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">查看anaconda的版本</span><br>conda -V<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">查看已安装的envs</span><br>conda info -e<br></code></pre></td></tr></tbody></table></figure><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">1. 创建一个环境，指定python版本</span><br>conda create --prefix=./machinelearning python=3.9<br><span class="hljs-meta"># </span><span class="language-bash">或者</span><br>conda create --name machinelearning python=3.9<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">2. 启动该环境</span><br>conda activate machinelearning<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">3. 验证环境是否被选中</span><br>conda info --envs<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">4. 验证python版本</span><br>python --version<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">5. 禁用环境</span><br>conda deactive<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">6. 删除虚拟环境</span><br>conda env remove -n ENV_NAME<br></code></pre></td></tr></tbody></table></figure><h3 id="管理Python包"><a href="#管理Python包" class="headerlink" title="管理Python包"></a>管理Python包</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">查看当前环境下的包</span><br>conda list<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">包查询</span><br>conda search 'setup' # 替换为自己的包名<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">安装一个包</span><br>conda install [package1]<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">安装多个安装包</span><br>conda install [package1] [package2]<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">删除包</span><br>conda remove [package1]<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">升级安装包</span><br>conda upgrade [package1]<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Anaconda-使用教程&quot;&gt;&lt;a href=&quot;#Anaconda-使用教程&quot; class=&quot;headerlink&quot; title=&quot;Anaconda 使用教程&quot;&gt;&lt;/a&gt;Anaconda 使用教程&lt;/h2&gt;&lt;h3 id=&quot;验证&quot;&gt;&lt;a href=&quot;#验证&quot; cla</summary>
      
    
    
    
    
    <category term="Tools" scheme="http://example.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法详解</title>
    <link href="http://example.com/2022/04/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/04/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-07T14:44:26.000Z</published>
    <updated>2022-04-09T06:27:07.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯问题概述"><a href="#回溯问题概述" class="headerlink" title="回溯问题概述"></a>回溯问题概述</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>注2: dfs与回溯之间并不是并列的关系，dfs是一种深度优先的遍历方法，而回溯是一种解决问题的手段。dfs可以有回溯，回溯也可以用dfs。</p><h4 id="什么是回溯算法？"><a href="#什么是回溯算法？" class="headerlink" title="什么是回溯算法？"></a>什么是回溯算法？</h4><p>回溯法也可以叫做回溯搜索法，是一种搜索的方式。回溯是递归的副产品，有递归就会有回溯。</p><h4 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="回溯法的效率"></a>回溯法的效率</h4><p>回溯法的性能如何呢？实际上不是什么高效的算法。因为本质是穷举。如果想要回溯法高效，可以增加一些剪枝的操作。但效率仍然一般，因为其本质就是穷举。</p><h4 id="回溯法适合解决的问题"><a href="#回溯法适合解决的问题" class="headerlink" title="回溯法适合解决的问题"></a>回溯法适合解决的问题</h4><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等</li></ul><p>注：组合和排列的区别是组合不强调元素顺序，排列强调元素顺序。</p><h4 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h4><p>回溯法解决的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度则构成了树的深度。</p><p>使用递归就要有中止条件，所以树的高度是有限的。</p><p>解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考三个问题。</p><ol><li>路径：也就是已经作出的选择。</li><li>选择列表：也就是你当前可以做的选择。</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java">result = []<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(路径，选择列表)</span>:<br>  <span class="hljs-keyword">if</span> (满足结束条件){<br>    result.add(路径);<br>    <span class="hljs-keyword">return</span>;<br>  }<br>  <span class="hljs-keyword">for</span> (选择 : 选择列表) {<br>     做选择 or 处理节点;<br>     backtrack(路径，选择列表); <span class="hljs-comment">// 递归</span><br>     回溯，撤销选择;<br>  }<br></code></pre></td></tr></tbody></table></figure><p>核心就是for循环里的递归，在递归调用之前做选择，在递归调用之后撤销选择。</p><p>可以看出for循环就是横向的遍历，backtracking就是纵向遍历，这样就把这棵树全遍历完了。</p><p>这个框架的奥秘在哪里呢？我们来看两道例题：</p><h3 id="1-全排列问题"><a href="#1-全排列问题" class="headerlink" title="1. 全排列问题"></a>1. 全排列问题</h3><p>高中的排列组合数学题。对于n个不同的数，全排列共有n!个。</p><p>穷举全排列的方法？[1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1]…..</p><p>可以按照这个逻辑画出一颗决策树。</p><p>只要从root遍历这棵树，记录路径上的数字，其实就是所有的全排列。</p><p>假如我们进行穷举走到了[2, x, y]的分叉，这时候2的含义就是[路径]，用于记录你已经做过的选择；</p><p>而[1]或[3]则是[选择列表]。表示你当前可以做出的选择；</p><p>[结束条件]就是遍历到树的底层，在这里就是选择列表为空的时候。</p><p>这时候可以看出，我们所定义的backtrack函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其[路径]就是一个全排列。</p><p>那么，如何遍历这棵树？</p><p>简单的二叉树遍历罢了，前序遍历 or 后序遍历。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>{<br>  <span class="hljs-keyword">for</span> (TreeNode child : root.children)<br>  <span class="hljs-comment">//前序遍历需要的操作</span><br>    <span class="hljs-built_in">traverse</span>(child);<br>  <span class="hljs-comment">//后序遍历需要的操作</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>稍微回忆一下，前序遍历的代码会在进入某一个节点之前的时间执行，而后序遍历代码会在离开某个节点之后的那个时间点执行。</p><p>而就在刚才我们所述，[路径]和[选择]是每个节点的属性，函数在树上游走要正确维护节点的属性。所以我们应当在前序和后序两个位置选择不同的操作。</p><p>前序为做出选择，而后序为撤销选择。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>  <span class="hljs-comment">#做选择</span><br>  将该选择从选择列表移除<br>  路径.add(选择) <br>  backtrack(路径，选择列表)<br>  <span class="hljs-comment">#撤销选择</span><br>  路径.remove(选择)<br>  将该选择再加入选择列表<br></code></pre></td></tr></tbody></table></figure><p>我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确的得到每个节点的选择列表与路径。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-comment">// 主函数，输入一组不重复的数字，返回他们的全排列</span><br>List&lt;List&lt;Integer&gt;&gt; <span class="hljs-built_in">permute</span>(<span class="hljs-type">int</span>[] nums) {<br>  <span class="hljs-comment">// 记录路径</span><br>  LinkedList&lt;integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-built_in">backtrack</span>(nums, track);<br>  <span class="hljs-keyword">return</span> res;<br>}<br><br><span class="hljs-comment">// 路径：记录在 track 中</span><br><span class="hljs-comment">// 选择列表：nums 中不存在于 track 的那些元素</span><br><span class="hljs-comment">// 结束条件: nums 中的元素全都在track 中出现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>{<br>  <span class="hljs-comment">// 触发结束条件</span><br>  <span class="hljs-keyword">if</span> (track.<span class="hljs-built_in">size</span>() == nums.length) {<br>    res.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedList</span>(track));<br>    <span class="hljs-keyword">return</span>;<br>  }<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; nums.length; i++) {<br>    <span class="hljs-comment">// 排除不合法的选择</span><br>    <span class="hljs-keyword">if</span> (track.<span class="hljs-built_in">contains</span>(nums[i]))<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-comment">// 做选择</span><br>    track.<span class="hljs-built_in">add</span>(nums[i]);<br>    <span class="hljs-comment">// 进入下一层决策树</span><br>    <span class="hljs-built_in">backtrack</span>(nums, track);<br>    <span class="hljs-comment">// 取消选择</span><br>    track.<span class="hljs-built_in">removeLast</span>();<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>自此，我们就通过全排列问题了解了简单的回溯算法。当然，这个算法解决全排列并不高效，<code>contains</code>方法需要O(N)的时间复杂度。有更好的方法可以follow up</p><p>但不论怎样优化，只要符合回溯框架，时间复杂度都不可能低于O(N!)，因为穷举整棵树是无法避免的。一般回溯算法时间复杂度都很高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回溯问题概述&quot;&gt;&lt;a href=&quot;#回溯问题概述&quot; class=&quot;headerlink&quot; title=&quot;回溯问题概述&quot;&gt;&lt;/a&gt;回溯问题概述&lt;/h2&gt;&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;p&gt;注2: dfs与回溯之间并不是并列的关系，dfs是一种</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Depth First Search 深度优先搜索</title>
    <link href="http://example.com/2022/04/07/Depth-First-Search-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://example.com/2022/04/07/Depth-First-Search-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2022-04-07T14:33:35.000Z</published>
    <updated>2022-04-07T14:53:44.850Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文仅为个人学习笔记，无任何版权。</p><p>深度优先算法（DFS, Depth first search），是搜索算法的一种。</p><p>基本思想：沿着树的深度来遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都已被探寻过，搜索讲回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个过程反复进行直到所有节点都被访问为止。</p><p>深度优先算法也可以解决很多经典的图论问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;p&gt;深度优先算法（DFS, Depth first search），是搜索算法的一种。&lt;/p&gt;
&lt;p&gt;基本思想：沿着树的深度来遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都已被探寻过，搜索讲回溯到发现节点v的那条边</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Scanner &amp; BufferedReader 用法详解</title>
    <link href="http://example.com/2022/04/06/Scanner-BufferReader-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/04/06/Scanner-BufferReader-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-06T01:29:31.000Z</published>
    <updated>2022-04-07T14:55:20.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scanner-amp-BufferedReader用法详解"><a href="#Scanner-amp-BufferedReader用法详解" class="headerlink" title="Scanner &amp; BufferedReader用法详解"></a>Scanner &amp; BufferedReader用法详解</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>这段时间一直没把java的输入写明白，在该记事里进行一个总结</p><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>Scanner使用分隔符模式将其输入分解为标记，默认情况下是利用空白进行分割的。之后可以使用不同的<code>next</code>方法将得到的标记转换为不同类型的值。</p><p>Scanner位于<code>java.util</code>包中，Scanner的具体用法为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">//通过new创建一个Scanner对象</span><br><span class="hljs-comment">//传入一个System.in参数来读取输入</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//输入一个Integer</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextInt(); <br><span class="hljs-comment">//读取一整行字符串（以Enter结尾进行分界）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextLine();<br><span class="hljs-comment">//读取一组字符串（以空格/Tab/Enter进行分界，只要遇到其中之一就返回下一个 //输入）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.next();<br></code></pre></td></tr></tbody></table></figure><h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>BufferedReader位于<code>java.io</code>包中，读取数据比较固定，这样格式也比较单一。只要记住就这一读取数据的方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><br><span class="hljs-comment">//BufferedReader的readLine()方法必须处理java.o.IOException异常，所以需要在Public static void main后面补充处理。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {<br>  <span class="hljs-comment">//创建BufferReader对象，从键盘读入</span><br>  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>  <span class="hljs-comment">//创建BufferReader对象，从文本文件读入</span><br>  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">"test.txt"</span>));<br><br>  <span class="hljs-comment">//读取一行数据并用空格分隔，存入字符串数组</span><br>  String[] temp = br1.readLine().split(<span class="hljs-string">""</span>);<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>BufferedReader readLine()方法可能抛出异常，比如要读的文件不存在的话就会抛异常。会抛异常的方法要么在调用的时候用try catch包围，在调用它的时候就写好处理异常的代码，要么就在当前的函数后面加throw声明可能出现的异常，交给调用当前函数的函数处理异常。</p><p>BufferedReader读取的数据都以字符串的形式存储，如果需要其他形式的数据，需要进行强制转换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Scanner-amp-BufferedReader用法详解&quot;&gt;&lt;a href=&quot;#Scanner-amp-BufferedReader用法详解&quot; class=&quot;headerlink&quot; title=&quot;Scanner &amp;amp; BufferedReader用法详解</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/2022/04/04/%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/04/04/%E9%93%BE%E8%A1%A8/</id>
    <published>2022-04-04T04:15:56.000Z</published>
    <updated>2022-04-21T14:34:41.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表题型刷题总结"><a href="#链表题型刷题总结" class="headerlink" title="链表题型刷题总结"></a>链表题型刷题总结</h1><p>注：本文仅为个人学习笔记，无任何版权。</p><h3 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h3><p>一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null</p><p>链表的头节点为head</p><h4 id="链表的类型："><a href="#链表的类型：" class="headerlink" title="链表的类型："></a>链表的类型：</h4><ol><li>单链表</li><li>双链表</li><li>循环链表</li></ol><h4 id="链表在内存中的储存方式"><a href="#链表在内存中的储存方式" class="headerlink" title="链表在内存中的储存方式"></a>链表在内存中的储存方式</h4><p>与数组不同，链表在内存中<strong>不是连续分布。</strong></p><p>链表是通过指针域的指针链接在内存的各个节点，所以链表中的节点在内存中不是连续分布的，而是三楼缘分不在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><h4 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-comment">// 结点的值</span><br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-comment">// 下一个结点</span><br>    ListNode next;<br><br>    <span class="hljs-comment">// 节点的构造函数(无参)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> {<br>    }<br><br>    <span class="hljs-comment">// 节点的构造函数(有一个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> {<br>        <span class="hljs-built_in">this</span>.val = val;<br>    }<br><br>    <span class="hljs-comment">// 节点的构造函数(有两个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> {<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    }<br>}<br><br>List&lt;&gt; xxx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></tbody></table></figure><h4 id="删除节点："><a href="#删除节点：" class="headerlink" title="删除节点："></a>删除节点：</h4><p>只要将被删除节点的前一个节点的指针，指向后一个节点就可以了。如果要删除第n个节点，可以将第n-1个节点的指针指到第n+1个节点，java会自动释放那块内存。</p><h4 id="添加节点："><a href="#添加节点：" class="headerlink" title="添加节点："></a>添加节点：</h4><p>同理，修改指针即可。</p><p>可以看出链表的增添/删除都是O(1)的操作，不会影响到其他节点。但是，如果要删除第c个节点，需要从头节点找到第c-1个节点，查找的时间复杂度为O(c)</p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>链表删除/插入：O(1)</p><p>链表查找：          O(n)</p><p>数组删除/插入：O(n)</p><p>数组查找：          O(1)</p><p>数组：数据量固定，频繁查找，较少增删</p><p>链表：数据量不固定，频繁增删，较少查找</p><h3 id="链表的经典题目"><a href="#链表的经典题目" class="headerlink" title="链表的经典题目"></a>链表的经典题目</h3><h4 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h4><p>链表操作的一大问题就是当前节点必须要找前一个节点才能操作，在这种情况下，用一个虚拟头节点可以解决这个问题。</p><p>203</p><h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><p>一道题写一个链表ListNode的class出来，非常好的题目 </p><p>707</p><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>高频题目，递归和迭代都可以解决，建议一定熟练掌握本质。</p><p>206</p><h4 id="删除倒数第N个节点"><a href="#删除倒数第N个节点" class="headerlink" title="删除倒数第N个节点"></a>删除倒数第N个节点</h4><p>虚拟头节点 + 双指针，第一个指针走n 然后第二个指针跟第一个指针一起出发。</p><p>19</p><h4 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h4><p>很trick的方法。虽然两个链表到达相交点的距离可能不一样，但我们可以加两个链表加起来。一个指针从A遍历到B，一个指针从B遍历到A。这样他们就可以同时到达交点了！</p><p>面试题 02.07</p><h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p>难点在数学证明，方法是快慢指针。很有趣的题目。</p><p>142</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表题型刷题总结&quot;&gt;&lt;a href=&quot;#链表题型刷题总结&quot; class=&quot;headerlink&quot; title=&quot;链表题型刷题总结&quot;&gt;&lt;/a&gt;链表题型刷题总结&lt;/h1&gt;&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;h3 id=&quot;什么是链表？&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://example.com/2022/04/02/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://example.com/2022/04/02/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-04-02T10:56:03.000Z</published>
    <updated>2022-06-03T14:26:43.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组题型刷题总结"><a href="#数组题型刷题总结" class="headerlink" title="数组题型刷题总结"></a>数组题型刷题总结</h1><p>注：本文仅为个人学习笔记，无任何版权。</p><p>数组：存放在连续空间的相同类型元素的集合，一般不进行删除操作。</p><p>两点注意；</p><ol><li>数组下标都是从0开始</li><li>数组内存空间地址连续（增添删除都很麻烦）</li></ol><p>二维数组在系统中的存储方式</p><p>m*n的二维数组来说，一般由一个头节点指向一个长为n的一维列数组，每个列数组又作为另一个长为m的一维行数组的头节点。</p><p>并不是连续地址空间</p><p>一般看到链表/子串/数组之类的题，直接上双指针就行</p><p>常用方法：</p><ol><li>二分法</li><li>双指针</li><li>滑动窗口</li><li>模拟行为</li></ol><h3 id="1-二分法"><a href="#1-二分法" class="headerlink" title="1. 二分法"></a>1. 二分法</h3><p>704, 35, 34, 69, 367</p><p>限制条件：<strong>有序数组</strong>  且 <strong>无重复元素</strong></p><p>Key：边界条件的设定。在二分查找过程中，每次区间变化都遵守边界条件不变。</p><p>常用区间：[lo, hi],  [lo, hi)</p><p>注：乘法溢出时用除法处理即可。</p><p>暴力解法一般时间复杂度为O(N)</p><p>二分法一般时间复杂度为O(logN)</p><h3 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2. 双指针"></a>2. 双指针</h3><p>27, 26, 283, 844, 977</p><p>双指针技巧可以分为两类：【快慢指针】和【左右指针】。前者解决链表中的问题，比如判断链表是否包含环；后者主要解决数组（字符串）中的问题，二分查找也是左右指针的一种特殊情况。</p><p>常见的双指针问题还有移除元素/移除字符串等。</p><p>快慢指针常见问题：链表操作/找中点/归并排序/链表环</p><p>左右指针常见问题：反转数组/二分搜索</p><p>暴力解法时间复杂度一般为O(N^2)</p><p>双指针法时间复杂度一般为O(N)</p><h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h3><p>209, 904, 76</p><p>实际上滑动窗口也是一种特殊的双指针。不过因为其在<strong>子串</strong>问题中的优异表现，我将其单独作为一个部分来讲。</p><p>滑动窗口算法的大致逻辑如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; s.size()) {<br>  <span class="hljs-comment">//增大窗口</span><br>  window.add(s[right]);<br>  right++;<br>  <br>  <span class="hljs-keyword">while</span> (window needs shrink) {<br>    <span class="hljs-comment">//缩小窗口</span><br>    window.remove(s[left]);<br>    left++;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度O(N)， 比一般的字符串暴力算法高效的多。</p><p>滑动窗口的关键在于各种细节问题。比如如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即使你明白了这些细节，也容易报错。</p><p>使用一套来自labuladong 的滑动窗口代码框架。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//需要的字符传入need</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) {<br>  need. put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>}<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (right &lt; s.length()) {<br>  <span class="hljs-comment">//c是移入窗口的字符</span><br>  <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>  <span class="hljs-comment">//右边界右移</span><br>  right++;<br>  <br>  <span class="hljs-comment">//进入窗口的一系列操作.....</span><br>  <br>  <span class="hljs-comment">//当满足时，进行窗口缩减</span><br>  <span class="hljs-keyword">while</span> (window needs shrink) {<br>    <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>    <span class="hljs-comment">//左边界右移</span><br>    left++;<br>    <br>    <span class="hljs-comment">//出窗口</span><br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-模拟行为"><a href="#4-模拟行为" class="headerlink" title="4. 模拟行为"></a>4. 模拟行为</h3><p>48， 54， 59</p><p>不涉及太多算法，单纯模拟，考验对代码的掌控能力。</p><p>循环不变量原则十分重要。</p><p>真正解决题目的代码都是简洁的，有原则性的。</p><h3 id="刷题记录-题解"><a href="#刷题记录-题解" class="headerlink" title="刷题记录+题解"></a>刷题记录+题解</h3><p><a href="">LC3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组题型刷题总结&quot;&gt;&lt;a href=&quot;#数组题型刷题总结&quot; class=&quot;headerlink&quot; title=&quot;数组题型刷题总结&quot;&gt;&lt;/a&gt;数组题型刷题总结&lt;/h1&gt;&lt;p&gt;注：本文仅为个人学习笔记，无任何版权。&lt;/p&gt;
&lt;p&gt;数组：存放在连续空间的相同类型元素的集</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>OnJava8-File</title>
    <link href="http://example.com/2022/03/31/OnJava8-File/"/>
    <id>http://example.com/2022/03/31/OnJava8-File/</id>
    <published>2022-03-31T01:01:41.000Z</published>
    <updated>2022-04-07T14:54:54.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Way-to-Input-x2F-Output-File-by-Java"><a href="#The-Way-to-Input-x2F-Output-File-by-Java" class="headerlink" title="The Way to Input/Output File by Java"></a>The Way to Input/Output File by Java</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>打开并读取文件对于大多数编程语言来说是非常实用的。Java8与java7新增的<code>java.nio.file</code>包以及streams与文件结合使得文件操作编程变得十分简单。</p><p>对于文件操作来说，最基本的两个组件是</p><ol><li>文件或者目录的路径；</li><li>文件本身。</li></ol><h3 id="文件和目录路径"><a href="#文件和目录路径" class="headerlink" title="文件和目录路径"></a>文件和目录路径</h3><p>一个<code>Path</code>对象表示一个文件或者目录的路径，可以跨操作系统和文件系统。</p><p><code>java.nio.file.Path</code>包含一个重载方法<code>static get()</code>，该方法接受一系列<code>String</code>字符串或一个URI作为参数，进行转换返回一个<code>Path</code>对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// files/PathInfo.java</span><br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PathInfo</span> {<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String id, Object p)</span> {<br>        System.out.println(id + <span class="hljs-string">": "</span> + p);<br>    }<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(Path p)</span> {<br>        show(<span class="hljs-string">"toString"</span>, p);<br>        show(<span class="hljs-string">"Exists"</span>, Files.exists(p));<br>        show(<span class="hljs-string">"RegularFile"</span>, Files.isRegularFile(p));<br>        show(<span class="hljs-string">"Directory"</span>, Files.isDirectory(p));<br>        show(<span class="hljs-string">"Absolute"</span>, p.isAbsolute());<br>        show(<span class="hljs-string">"FileName"</span>, p.getFileName());<br>        show(<span class="hljs-string">"Parent"</span>, p.getParent());<br>        show(<span class="hljs-string">"Root"</span>, p.getRoot());<br>        System.out.println(<span class="hljs-string">"******************"</span>);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        System.out.println(System.getProperty(<span class="hljs-string">"os.name"</span>));<br>        info(Paths.get(<span class="hljs-string">"C:"</span>, <span class="hljs-string">"path"</span>, <span class="hljs-string">"to"</span>, <span class="hljs-string">"nowhere"</span>, <span class="hljs-string">"NoFile.txt"</span>));<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"PathInfo.java"</span>);<br>        info(p);<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">ap</span> <span class="hljs-operator">=</span> p.toAbsolutePath();<br>        info(ap);<br>        info(ap.getParent());<br>        <span class="hljs-keyword">try</span> {<br>            info(p.toRealPath());<br>        } <span class="hljs-keyword">catch</span>(IOException e) {<br>           System.out.println(e);<br>        }<br>        <span class="hljs-type">URI</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> p.toUri();<br>        System.out.println(<span class="hljs-string">"URI: "</span> + u);<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">puri</span> <span class="hljs-operator">=</span> Paths.get(u);<br>        System.out.println(Files.exists(puri));<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ap.toFile(); <span class="hljs-comment">// Don't be fooled</span><br>    }<br>}<br><br><span class="hljs-comment">/* 输出:</span><br><span class="hljs-comment">Windows 10</span><br><span class="hljs-comment">toString: C:\path\to\nowhere\NoFile.txt</span><br><span class="hljs-comment">Exists: false</span><br><span class="hljs-comment">RegularFile: false</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: NoFile.txt</span><br><span class="hljs-comment">Parent: C:\path\to\nowhere</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: false</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: null</span><br><span class="hljs-comment">Root: null</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files\PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: false</span><br><span class="hljs-comment">Directory: true</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: files</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files\PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">URI: file:///C:/Users/Bruce/Documents/GitHub/onjava/</span><br><span class="hljs-comment">ExtractedExamples/files/PathInfo.java</span><br><span class="hljs-comment">true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-Way-to-Input-x2F-Output-File-by-Java&quot;&gt;&lt;a href=&quot;#The-Way-to-Input-x2F-Output-File-by-Java&quot; class=&quot;headerlink&quot; title=&quot;The Way to I</summary>
      
    
    
    
    
    <category term="Programming" scheme="http://example.com/tags/Programming/"/>
    
  </entry>
  
</feed>
