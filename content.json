{"meta":{"title":"WANG Tianchen","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-02-24T11:46:46.000Z","updated":"2022-03-26T02:24:56.330Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Prefaceこのブログをご覧いただきありがとうございます！ 現在、ソフトウェアエンジニアのサマーインターン（2022）を探しています。 Now I’m looking for summer internships (2022) of software developer engineer(SDE) in Japan or remote. If you would like to offer me some opportunities, please feel free to cantact me at anytimes. Mail Address: wang.tianchen333@gmail.com This blog included some interesting projects and articles. Created by Hexo + GihubPages. About Me 中国出身、京都大学大学院情報学研究科社会情報学専攻１年（22年4月時点、24年3月卒業予定）伊藤孝行研究室に所属しています。自然言語処理関連の研究に対して興味を持っているけど、研究内容はまだ決めていません。 学部は機械や制御を専攻しましたので、常に情報学の実務経験や基礎知識は足りないを感じました。他の優秀のエンジニアに追いつくためには、何倍の努力をしなければならない。とりあえずバックアンドエンジニアを目指す、インフラやフロントアンドのことも勉強しています。 最近はAtCoderに興味を持って参加しています。 I’m a M1 student at Kyoto University, graduate school of informatics, Takayuki Ito LAB. I expect to graduate at Mar.2024. I’m a native speaker of Simplified Chinese, and can work in the English or Japanese environments. My resume is here. Projects Gogee: A web framework made using golang , which is made to imitate Gin . Gototp: A TOTP(time-based one time password) library, which is written by Go. Technical SkillsGo, Java, Python, AWS, MATLAB, C, HTML Git, MySQL Certificate2021.4 TOEIC 810 2021.12 JLPT N2 The Other Side of MeI owned 30,000 fans in Zhihu (similiar to a Chinese verson Quora). I was the captain of the school of Automation’s soccer team in college (Position: GK/DF). I had participated in more than 20 conferences of the Model United Nation and had chaired Model United Nation conferences such as the FAO. ContactIf you are interested in me, please feel free to contact me at any time. Mail Address: wang.tianchen333@gmail.com Tel: +81 080-9525-1185 You can find the link of my Github/ Linkedin/ Twitter/ Zhihu/ Wechat at the top of this page."}],"posts":[{"title":"Scanner & BufferedReader 用法详解","slug":"Scanner-BufferReader-用法详解","date":"2022-04-06T01:29:31.000Z","updated":"2022-04-06T02:00:17.245Z","comments":true,"path":"2022/04/06/Scanner-BufferReader-用法详解/","link":"","permalink":"http://example.com/2022/04/06/Scanner-BufferReader-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Scanner &amp; BufferedReader用法详解这段时间一直没把java的输入写明白，在该记事里进行一个总结 ScannerScanner使用分隔符模式将其输入分解为标记，默认情况下是利用空白进行分割的。之后可以使用不同的next方法将得到的标记转换为不同类型的值。 Scanner位于java.util包中，Scanner的具体用法为 1234567891011import java.util.*;//通过new创建一个Scanner对象//传入一个System.in参数来读取输入Scanner sc = new Scanner(System.in);//输入一个Integerint a = sc.nextInt(); //读取一整行字符串（以Enter结尾进行分界）String a = sc.nextLine();//读取一组字符串（以空格/Tab/Enter进行分界，只要遇到其中之一就返回下一个 //输入）String a = sc.next(); BufferedReaderBufferedReader位于java.io包中，读取数据比较固定，这样格式也比较单一。只要记住就这一读取数据的方法。 1234567891011121314import java.io.*;//BufferedReader的readLine()方法必须处理java.o.IOException异常，所以需要在Public static void main后面补充处理。public static void main(String[] args) throws IOException { //创建BufferReader对象，从键盘读入 BufferedReader br1 = new BufferedReader(new InputStreamReader(System.in)); //创建BufferReader对象，从文本文件读入 BufferedReader br2 = new BufferedReader(new FileReader(\"test.txt\")); //读取一行数据并用空格分隔，存入字符串数组 String[] temp = br1.readLine().split(\"\");} BufferedReader readLine()方法可能抛出异常，比如要读的文件不存在的话就会抛异常。会抛异常的方法要么在调用的时候用try catch包围，在调用它的时候就写好处理异常的代码，要么就在当前的函数后面加throw声明可能出现的异常，交给调用当前函数的函数处理异常。 BufferedReader读取的数据都以字符串的形式存储，如果需要其他形式的数据，需要进行强制转换。","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://example.com/tags/Programming/"}]},{"title":"链表","slug":"链表","date":"2022-04-04T04:15:56.000Z","updated":"2022-04-04T04:30:50.271Z","comments":true,"path":"2022/04/04/链表/","link":"","permalink":"http://example.com/2022/04/04/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表题型刷题总结什么是链表？一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null 链表的头节点为head 链表的类型： 单链表 双链表 循环链表 链表在内存中的储存方式与数组不同，链表在内存中不是连续分布。 链表是通过指针域的指针链接在内存的各个节点，所以链表中的节点在内存中不是连续分布的，而是三楼缘分不在内存中的某地址上，分配机制取决于操作系统的内存管理。 链表的定义123456789101112131415161718192021222324public class ListNode { // 结点的值 int val; // 下一个结点 ListNode next; // 节点的构造函数(无参) public ListNode() { } // 节点的构造函数(有一个参数) public ListNode(int val) { this.val = val; } // 节点的构造函数(有两个参数) public ListNode(int val, ListNode next) { this.val = val; this.next = next; }}List&lt;&gt; xxx = new LinkedList&lt;&gt;(); 删除节点：只要将被删除节点的前一个节点的指针，指向后一个节点就可以了。如果要删除第n个节点，可以将第n-1个节点的指针指到第n+1个节点，java会自动释放那块内存。 添加节点：同理，修改指针即可。 可以看出链表的增添/删除都是O(1)的操作，不会影响到其他节点。但是，如果要删除第c个节点，需要从头节点找到第c-1个节点，查找的时间复杂度为O(c) 性能分析链表删除/插入：O(1) 链表查找： O(n) 数组删除/插入：O(n) 数组查找： O(1) 数组：数据量固定，频繁查找，较少增删 链表：数据量不固定，频繁增删，较少查找","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://example.com/tags/Programming/"}]},{"title":"数组","slug":"数组-滑动窗口","date":"2022-04-02T10:56:03.000Z","updated":"2022-04-04T04:16:35.962Z","comments":true,"path":"2022/04/02/数组-滑动窗口/","link":"","permalink":"http://example.com/2022/04/02/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"数组题型刷题总结数组：存放在连续空间的相同类型元素的集合，一般不进行删除操作。 两点注意； 数组下标都是从0开始 数组内存空间地址连续（增添删除都很麻烦） 二维数组在系统中的存储方式 m*n的二维数组来说，一般由一个头节点指向一个长为n的一维列数组，每个列数组又作为另一个长为m的一维行数组的头节点。 并不是连续地址空间 一般看到链表/子串/数组之类的题，直接上双指针就行 常用方法： 二分法 双指针 滑动窗口 模拟行为 1. 二分法704, 35, 34, 69, 367 限制条件：有序数组 且 无重复元素 Key：边界条件的设定。在二分查找过程中，每次区间变化都遵守边界条件不变。 常用区间：[lo, hi], [lo, hi) 注：乘法溢出时用除法处理即可。 暴力解法一般时间复杂度为O(N) 二分法一般时间复杂度为O(logN) 2. 双指针27, 26, 283, 844, 977 双指针技巧可以分为两类：【快慢指针】和【左右指针】。前者解决链表中的问题，比如判断链表是否包含环；后者主要解决数组（字符串）中的问题，二分查找也是左右指针的一种特殊情况。 常见的双指针问题还有移除元素/移除字符串等。 快慢指针常见问题：链表操作/找中点/归并排序/链表环 左右指针常见问题：反转数组/二分搜索 暴力解法时间复杂度一般为O(N^2) 双指针法时间复杂度一般为O(N) 3. 滑动窗口209, 904, 76 实际上滑动窗口也是一种特殊的双指针。不过因为其在子串问题中的优异表现，我将其单独作为一个部分来讲。 滑动窗口算法的大致逻辑如下： 12345678910111213int left = 0, right = 0;while (right &lt; s.soze()) { //增大窗口 window.add(s[right]); right++; while (window needs shrink) { //缩小窗口 window.remove(s[left]); left++; }} 时间复杂度O(N)， 比一般的字符串暴力算法高效的多。 滑动窗口的关键在于各种细节问题。比如如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即使你明白了这些细节，也容易报错。 使用一套来自labuladong 的滑动窗口代码框架。 123456789101112131415161718192021222324Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();Map&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();//需要的字符传入needfor (char c : t.toCharArray()) { need. put(c, need.getOrDefault(c, 0) + 1);}int left = 0, right = 0;while (right &lt; s.length()) { //c是移入窗口的字符 char c = s.charAt(right); //右边界右移 right++; //进入窗口的一系列操作..... //当满足时，进行窗口缩减 while (window needs shrink) { char d = s.charAt(left); //左边界右移 left++; //出窗口 }} 4. 模拟行为48， 54， 59 不涉及太多算法，单纯模拟，考验对代码的掌控能力。 循环不变量原则十分重要。 真正解决题目的代码都是简洁的，有原则性的。","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://example.com/tags/Programming/"}]},{"title":"OnJava8-File","slug":"OnJava8-File","date":"2022-03-31T01:01:41.000Z","updated":"2022-03-31T01:26:33.934Z","comments":true,"path":"2022/03/31/OnJava8-File/","link":"","permalink":"http://example.com/2022/03/31/OnJava8-File/","excerpt":"","text":"The Way to Input/Output File by Java打开并读取文件对于大多数编程语言来说是非常实用的。Java8与java7新增的java.nio.file包以及streams与文件结合使得文件操作编程变得十分简单。 对于文件操作来说，最基本的两个组件是 文件或者目录的路径； 文件本身。 文件和目录路径一个Path对象表示一个文件或者目录的路径，可以跨操作系统和文件系统。 java.nio.file.Path包含一个重载方法static get()，该方法接受一系列String字符串或一个URI作为参数，进行转换返回一个Path对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// files/PathInfo.javaimport java.nio.file.*;import java.net.URI;import java.io.File;import java.io.IOException;public class PathInfo { static void show(String id, Object p) { System.out.println(id + \": \" + p); } static void info(Path p) { show(\"toString\", p); show(\"Exists\", Files.exists(p)); show(\"RegularFile\", Files.isRegularFile(p)); show(\"Directory\", Files.isDirectory(p)); show(\"Absolute\", p.isAbsolute()); show(\"FileName\", p.getFileName()); show(\"Parent\", p.getParent()); show(\"Root\", p.getRoot()); System.out.println(\"******************\"); } public static void main(String[] args) { System.out.println(System.getProperty(\"os.name\")); info(Paths.get(\"C:\", \"path\", \"to\", \"nowhere\", \"NoFile.txt\")); Path p = Paths.get(\"PathInfo.java\"); info(p); Path ap = p.toAbsolutePath(); info(ap); info(ap.getParent()); try { info(p.toRealPath()); } catch(IOException e) { System.out.println(e); } URI u = p.toUri(); System.out.println(\"URI: \" + u); Path puri = Paths.get(u); System.out.println(Files.exists(puri)); File f = ap.toFile(); // Don't be fooled }}/* 输出:Windows 10toString: C:\\path\\to\\nowhere\\NoFile.txtExists: falseRegularFile: falseDirectory: falseAbsolute: trueFileName: NoFile.txtParent: C:\\path\\to\\nowhereRoot: C:\\******************toString: PathInfo.javaExists: trueRegularFile: trueDirectory: falseAbsolute: falseFileName: PathInfo.javaParent: nullRoot: null******************toString: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\files\\PathInfo.javaExists: trueRegularFile: trueDirectory: falseAbsolute: trueFileName: PathInfo.javaParent: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\filesRoot: C:\\******************toString: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\filesExists: trueRegularFile: falseDirectory: trueAbsolute: trueFileName: filesParent: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamplesRoot: C:\\******************toString: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\files\\PathInfo.javaExists: trueRegularFile: trueDirectory: falseAbsolute: trueFileName: PathInfo.javaParent: C:\\Users\\Bruce\\Documents\\GitHub\\onjava\\ExtractedExamples\\filesRoot: C:\\******************URI: file:///C:/Users/Bruce/Documents/GitHub/onjava/ExtractedExamples/files/PathInfo.javatrue*/","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://example.com/tags/Programming/"}]},{"title":"TCP/IP, UDP and Socket","slug":"TCP-IP-UDP-and-Socket","date":"2022-03-26T01:56:22.000Z","updated":"2022-03-26T02:12:39.805Z","comments":true,"path":"2022/03/26/TCP-IP-UDP-and-Socket/","link":"","permalink":"http://example.com/2022/03/26/TCP-IP-UDP-and-Socket/","excerpt":"","text":"本篇旨在解决如下三个问题： 什么是TCP/IP、UDP？ Socket是什么？ 如何使用上述的服务？ 让我们开始吧！ 1. 什么是TCP/IP、UDP？TCP/IP（Transmission Control Protocol/ Internet Protocol）即传输控制协议/网间协议。是一个工业标准的protocol集，他是为广域网（WANs）设计的。 UDP（User Data Protocal，用户数据报协议）是与TCP相对应的协议。他是属于TCP/IP协议集中的一种。 ![截屏2022-03-26 11.04.16](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.04.16.png) TCP/IP协议族包括运输层、网络层、链路层。TCP与UDP都是运用在运输层上的协议。 2. Socket是什么？在上图中，我们并未看到Socket的影子。 Socket究竟在网络服务中扮演了怎样的角色呢？ 实际上Socket的位置应该在应用层与运输层之间。起到了一个将应用层传输给运输层的信息进行抽象的作用。 Socket是应用层与TCP/IP协议族通信的中间软件抽象层，他是一组接口。在设计模式中，Socket其实就是一个门面模式，他可以将复杂的TCP/IP协议族隐藏在后面，提供给用户一个简单的接口信息。用户只需要让Socket去组织数据，以符合制定的协议。 3. 如何使用上述的服务？![截屏2022-03-26 11.09.35](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.09.35.png)先从服务器端讲起。服务器端先初始化Socket，然后与端口绑定（bind），对端口进行监听（Listen），调用Accept阻塞，等待客户端链接。在这时候如果有客户端初始化了一个Socket，然后连接服务器（connect），如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接受请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。 原文连接","categories":[],"tags":[{"name":"Project-Web","slug":"Project-Web","permalink":"http://example.com/tags/Project-Web/"}]},{"title":"gototp: A TOTP Library Written by Go","slug":"gototp-A-TOTP-Library-Written-by-Go","date":"2022-03-15T23:48:50.000Z","updated":"2022-03-16T00:04:24.934Z","comments":true,"path":"2022/03/16/gototp-A-TOTP-Library-Written-by-Go/","link":"","permalink":"http://example.com/2022/03/16/gototp-A-TOTP-Library-Written-by-Go/","excerpt":"","text":"gototpA TOTP(Time Based One-Time Password, RFC6328) Library Written by Golang. The way to create this library Github of totp RFC6328 How to Get the Library1go get github.com/xiaogeamadeus/gototp","categories":[],"tags":[{"name":"Project-Go","slug":"Project-Go","permalink":"http://example.com/tags/Project-Go/"}]},{"title":"Gogee-Day3-Trie木ルータ","slug":"Gogee-Day3-Trie木ルータ","date":"2022-03-14T00:47:07.000Z","updated":"2022-03-26T01:02:54.523Z","comments":true,"path":"2022/03/14/Gogee-Day3-Trie木ルータ/","link":"","permalink":"http://example.com/2022/03/14/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/","excerpt":"","text":"本篇主要内容：1. 使用Trie树实现动态路由(dynamic route)解析。 支持两种模式:name和*filepath* Trie Tree Router之前，我们用了一个非常简单的map结构储存了路由表(router map)，使用map存储键值对，索引非常高效，但是有一个弊端，键值对存储的方式只适用于静态路由. 如果我们想要支持/hello/:name这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类而非某一条固定的路由。比如/hello/:name，可以匹配/hello/xiaogeamadeus、hello/tom等。 动态路由有很多种实现方式，支持的规则、性能等有很大的差异。例如开源的路由实现gorouter支持在路由规则中嵌入正则表达式，例如/p/[0-9A-Za-z]+，即路径中的参数仅匹配数字和字母；另一个开源实现httprouter就不支持正则表达式。gin在早期的版本，并没有实现自己的路由，而是直接使用了httprouter，后来放弃了，自己实现了一个版本。 实现动态路由最常用的数据结构，被称为前缀树(Trie Tree)：每一个节点的所有子节点都拥有相同的前缀。这种结构非常适用于路由匹配。例如，我们定义了如下路由规则： 123456/:lang/doc/:lang/tutorial/:lang/intro/about/p/blog/p/related 我们用前缀树来表示的话就会变成三颗子树/:lang、/about、/p HTTP请求的路径恰好是由/分隔的多段构成的，因此，每一段可以作为前缀树的一个节点。我们通过树结构查询，如果中间某一层的节点都不满足条件，那么就说明没有匹配到的路由，查询结束。 我们接下来实现的路由具有如下两个功能。 参数匹配：/p/:lang/doc可以匹配/p/c/doc或者/p/go/doc 通配符*。例如/static/*filepath，可以匹配/static/fav.ico，也可以匹配/static/js/jQuery.js，这种模式常用于静态服务器，能够递归的匹配子路径。 Trie木の実現123456ttype node struct { pattern string //带匹配路由，例如/p/:lang part string //路由中的一部分，例如:lang children []*node //子节点，例如[doc, tutorial,intro] isWild bool //是否精确匹配，part含有:或*时为true} 与普通的树不同，为了实现动态路由匹配，加上了isWild这个参数。即当我们匹配到/p/go/doc这个路由时，第一层节点，p精准的匹配到了p，第二层节点，go模糊匹配到:lang，那么将会把lang这个参数赋值为go，继续下一层匹配。我们将匹配的逻辑包装为一个辅助函数。 12345678910111213141516171819//第一个匹配成功的节点，用于插入func (n *node)matchChild(part string) *node{ for _, child := range n.children { if child.part == part || child.isWild{ return child } } return nil}// 所有匹配成功的节点，用于查找func (n *node) matchChildren(part string) []*node { nodes := make([]*node, 0) for _, child := range n.children { if child.part == part||child.isWild{ nodes = append(nodes, child) } } return nodes} 对于路由来说，注册和匹配是最重要的。开发服务时，注册路由规则，映射handler; 访问时，匹配路由规则，查找到对应的handler。因此，Trie树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前part的节点，则新建一个。有一点需要注意，/p/:lang/doc只有在第三层节点，即doc节点，pattern才会设置为/p/:lang/doc。 p和:lang节点的pattern属性皆为空。因此，当匹配结束时，我们可以使用n.pattern == \"\"来判断路由规则是否匹配成功。例如，/p/python虽能成功匹配到:lang，但lang的pattern值为空，因此匹配失败。查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到了*，匹 配失败，或者匹配到了第len(parts)层节点。 12345678910111213141516171819202122232425262728293031323334353637// Trie tree's insertfunc (n *node) insert(pattern string, parts []string, height int) { if len(parts) == height { n.pattern = pattern return } part := parts[height] child := n.matchChild(part) if child == nil { child = &amp;node{part: part, isWild: part[0] == ':'|| part[0] == '*'} n.children = append(n.children, child) } child.insert(pattern, parts, height+1)}//Trie tree's searchfunc (n *node) search(parts []string, height int) *node{ if len(parts) == height || strings.HasPrefix(n.part, '*') { if n.pattern == \"\"{ return nil } return n } part := parts[height] children := n.matchChildren(part) for _, child := range children { result := child.search(parts, height+1) if result != nil { return result } } return nil} RouterTrie 树的插入和查找实现之后，就可以将Trie树应用到路由之中了。使用roots来储存每种请求方式的Trie树根节点。使用handlers存储每种请求方式的HandlerFunc。getRoute函数中，还解析了:和*两种匹配符的参数，返回一个map。例如/p/go/doc匹配到/p/:lang/doc，解析结果为：{lang:\"go\"}，/static/css/xiaogeamadeus.css匹配到/static/*filepath，解析结果为{file path:\"css/xiaogeamadeus.css\"} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970type router struct{ roots map[string]*node handlers map[string]HandlerFunc}// roots key eg, roots['GET'] roots['POST']// handlers key eg, handlers['GET-/p/:lang/doc'], handlers['POST-/p/book']func newRouter() *router { return &amp;router{ roots: make(map[string]*node), handlers: make(map[string]HandlerFunc), }}// Only one * is allowedfunc parsePattern(pattern stirng) []string{ vs := strings.Split(pattern, \"/\") parts := make([]string, 0) for _, item := range vs { if item != \"\"{ parts = append()(parts, item) if item[0] == '*'{ break } } } return parts}func (r *router) addRoute(method string, pattern string, handler HandlerFunc){ parts := parsePattern(pattern) key := method + \"_\" + pattern _, ok := r.roots[method] if !ok { r.roots[method] = &amp;node{} } r.roots[method].insert(pattern, parts, 0) r.handlers[key] = handler}func (r *router) getRoute(method string, path string) (*node, map[string]string){ searchParts := parsePattern(path) params := make(map[string]string) root, ok := r.roots[method] if !ok{ return nil, nil } n := root.search(searchParts, 0) if n != nil { parts : parsePattern(n.pattern) for index, part := range parts { if part[0] == ':'{ params[part[1:]] = searchParts[index] } if parts[0] == '*'&amp;&amp; len(part) &gt;1{ params[part[1:]] = strings.Join(searchParts[index:],\"/\") break } } return n, params } return nil, nil} Contextとhandleの変化在HandleFunc 中，希望能够访问到解析的参数。因此，我们需要对Context对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到Params中，通过c/Param(\"lang\")的方式获取到对应的值。","categories":[],"tags":[{"name":"Project-Go","slug":"Project-Go","permalink":"http://example.com/tags/Project-Go/"}]},{"title":"RFC2617: HTTP Authentication","slug":"RFC2617-HTTP-Authentication","date":"2022-03-11T01:07:06.000Z","updated":"2022-03-11T01:21:45.924Z","comments":true,"path":"2022/03/11/RFC2617-HTTP-Authentication/","link":"","permalink":"http://example.com/2022/03/11/RFC2617-HTTP-Authentication/","excerpt":"","text":"HTTP Authentication: Basic and Digest Access Authentication在做课题的过程中需要了解RFC2617的知识，在此做一个中文总结。 Basic Authentication Scheme基本认证方案(Basic Authentication Scheme)是基于这样的模型：客户必须用一个用户ID和一个密码来认证自己的每个realm，realm vakye应当被认为是一个不透明的字符串，只能与该服务器上的其他realm进行比较以确定是否相等，服务器只有在能够验证Request-URI的用户ID和密码的情况下才能为请求提供服务。 basic-credentials = base64-user-pass base64-user-pass = &lt;base64 [4] encoding of user-pass, except not limited to 76 char/line&gt; user-pass = userid “:” password userid = *&lt;TEXT excluding “:”&gt; password = *TEXT","categories":[],"tags":[{"name":"Project-Web","slug":"Project-Web","permalink":"http://example.com/tags/Project-Web/"}]},{"title":"RFC6328: Time Based One-Time Password","slug":"RFC6328-Time-Based-One-Time-Password","date":"2022-03-11T00:01:02.000Z","updated":"2022-03-16T02:08:44.246Z","comments":true,"path":"2022/03/11/RFC6328-Time-Based-One-Time-Password/","link":"","permalink":"http://example.com/2022/03/11/RFC6328-Time-Based-One-Time-Password/","excerpt":"","text":"RFC6328: Time Based One-Time Password (TOTP)最近做到的课题需要我利用RFC6328将自己的邮箱信息加密，作为账号密码发送给对方的服务器。中文全网对于RFC6328的文章较少，在此稍微记载下学习的过程与心得。 Go写的TOTP库 gototp TOTP是什么？TOTP指基于时间的一次性密码。TOTP是基于OTP (One-Time Password, 一次性密码)的扩展。在RFC4226中，定义了一种基于HMAC的一次性密码，被命名为HOTP。HOTP算法是基于事件的，对其来说移动因子是一个事件计数器。而在TOTP当中，移动因子建立在了一个时间值上。该算法通过利用时间值，提供了一个短命的OTP值，可以有效提高安全性。 HOTP算法HOTP(HMAC-based One-Time Password, RFC4226)算法是基于HMAC-SHA-1算法的，该算法公式如下所示。 HOTP(K, C) = Truncate(HMAC-SHA-1(K, C)) 其中Truncate代表可以将HMAC-SHA-1转换为HOTP值的函数，K代表共享的秘密，C代表计数器值。 换言之，想要得到HOTP密码，有如下几个先决条件： 知道Truncate函数。 服务器端与客户端有共享的秘密。 用相同的计数器方法。 HOTP算法与TOTP算法的区别TOTP算法是HOTP算法基于时间的变体。在TOTP算法中，计数器值C被替换为了由时间参考和时间步长得出的值T。首先你要输入现在的Unixtime，然后减去所设置的T0。实际情况下将时间精确到每秒是无法实现的，一般会提供一个步长。 TOTP可以使用HMAC-SHA-256/512函数，不同于HOTP算法的HMAC-SHA-1函数 TOTP算法要求R1: The prover (e.g., token, soft token) and verifier (authentication or validation server) MUST know or be able to derive the current Unix time (i.e., the number of seconds elapsed since midnight UTC of January 1, 1970) for OTP generation. See [UT] for a more detailed definition of the commonly known “Unix time”. The precision of the time used by the prover affects how often the clock synchronization should be done; see Section 6. （服务器端与客户端均能得知现在的Unix时间） R2: The prover and verifier MUST either share the same secret or the knowledge of a secret transformation to generate a shared secret. （服务器端与客户端需要共享相同的秘密/共享产生共享秘密的转换的知识） R3: The algorithm MUST use HOTP [RFC4226] as a key building block. （算法必须使用HOTP算法来构建） R4: The prover and verifier MUST use the same time-step value X. （服务器端与客户端必须使用相同的步长X） R5: There MUST be a unique secret (key) for each prover. （每个验证者必须有一个独特的秘密（密钥）） R6: The keys SHOULD be randomly generated or derived using key derivation algorithms. （密钥应当是随机生成/使用推导算法） R7: The keys MAY be stored in a tamper-resistant device and SHOULD be protected against unauthorized access and usage. （密钥应当储存在安全设备中） TOTP算法详解符号K代表服务器端与客户端共同了解的秘密。 X代表以秒为单位的时间步长（默认值X=30秒），是一个系统参数。 T0是开始计算时间步长的Unix时间（缺省值为0，即Unix epoch，1970年1月1日），也是一个系统参数。 算法细节我们将TOTP定义为HOTP(K, T), T是一个整数，代表初始计数器时间T0和当前Unix时间之间的时间步数。 TOTP(K, T0, X) = HOTP(K, T(T0, X)) T(T0, X) = (CurrentUnixTime - T0) / X TOTP算法实装123456789package gototpfunc TOTP(k string, t0, x int) int{ return HOTP(k, T(T0, x))}func T(t0, x int) int { return (time.Now().Unix - t0)/x} 上述代码中，我们可以发现HOTP函数并未被定义。所以我们还需要对于HOTP进行定义。 HOTP算法实装想要求出HOTP，其实大体只需要三步。 用Key与Count求出HMAC-SHA1的值。 生成4个字节的字符串 计算HOTP值 我们来逐一分析一下 1. 求解HMAC-SHA1的值HMAC是密钥相关的哈希计算消息认证码（Hash-based Message Authentication Code）在多种网络协议（如SSL）中得到了广泛使用。通过使用哈希函数，可以从Key和Message中生成认证码。 假设HMAC-SHA1的值为HS，计算公式如下所示： HS = HMAC-SHA-1(K, C) K：共同秘密key C：Message，在HOTP函数中为count中的值 对于Golang来说，HMAC和SHA1都有标准包可以引用，HMAC为crypto/hmac、SHA1为crypto/sha1 12345func HMACSHA1(k, c []byte) []byte{ mac := hmac.New(sha1.New, k) mac.Write(c) return mac.Sum(nil)} 对于Golang来说，HMAC是用has.Hash实装的，利用hmac.New(func()has.Hash, []byte)可以得到哈希函数对应的对象。这样我们就成功的计算出了HS值。 注；对于SHA1来说，存储空间最大为160bit，最大支持20文字的字符串。 2. 生成一个4byte的字符串下一步，则是利用第一步计算出的HMAC值，制作一个4byte长度的字符串。 Sbits = DT(HS) 首先计算offsetbits，这是HS的20个字中最后的4bit。 由于Go语言处理的是字节串(Byte String)，所以当我取出20个字的最后一个字时，取出的其实是一个8bit的数字，由于我们只需要最后的4bit，所以一般情况下给到的结果是（0000xxxx）前四位bit被屏蔽了。同时，由于go没有二进制的字符，所以我们实际上表示会使用16进制。 123offsetbits := hs[19] &amp; 0xF// 0x后面的数为16进制// &amp; 位and运算 同1为1 下一步求解offset。 offset可以将offsetbits作为数值取出。 并没有什么特别的变换，仅仅是直接将byte列作为Integer读出。（因为offsetbits是4bit，所以offset这个值为0-15） 1offset := int(offsetbits) 接下来，将HS的第offset位开始之后4个文字拿出来，赋值给p 1p := hs[offset:offset + 4] 然后提取p（32bit）末尾的31bit（0xx…..xx(31个x)） 这也是利用mask来做计算的，换句话说与7FFFFFFF做and运算就可以。 当然，由于用byte列做mask会稍微有些麻烦，所以可以先将[]byte变换为int然后做mask。 由于Go语言不支持直接变换，所以借用一个包encoding/binary 总结一下第二步所做的工作。 1234567// Truncate 函数func DT(hs []byte) int { offsetbits := hs[19] &amp; 0xF offset := int(offsetbits) p := hs[offset : offset+4] return int(binary.BigEndian.Uint32(p)) &amp; 0x7FFFFFFF} 3. 计算HOTP的值123func ReductionModulo(snum int) int { return int(int64(snum) % int64(math.Pow10(g.Digit)))} HOTP算法总结最后将HOTP函数构建一下，将上面的步骤套入。 再次回顾一下HOTP函数 HOTP(K, C) = Truncate(HMAC - SHA- 1(K, C)) Truncate函数是用上面的DT实现的 123func HOTP(k, c []byte) int{ return DT(HMACSHA1(k, c))} 联合TOTP和HOTP完成HOTP函数的构建之后，我们要想办法将其应用在TOTP之中。 之前我们构建的TOTP函数如下所示 1234567func TOTP(k string, t0, x int) int { return HOTP(k, T(T0, x))}func T(t0, x int) int { return (time.Now().Unix - t0) / x} 实际上，T(t0, x)的返回值是int，是无法在func HOTP(k, c []byte) int中使用的，所以要对HOTP函数进行微调。 12345func HOTP(k []byte, c int) int{ cb := make([]byte, 8) binary.BigEndian.PutUint64(cb, c) return DT(HMACSHA1(k, cb))} 这样，我们完成了TOTP算法的基础实现。","categories":[],"tags":[{"name":"Project-Web","slug":"Project-Web","permalink":"http://example.com/tags/Project-Web/"}]},{"title":"Sending HTTP Request with Golang","slug":"Sending-HTTP-Request-with-Golang","date":"2022-03-10T07:10:53.000Z","updated":"2022-03-12T12:12:48.913Z","comments":true,"path":"2022/03/10/Sending-HTTP-Request-with-Golang/","link":"","permalink":"http://example.com/2022/03/10/Sending-HTTP-Request-with-Golang/","excerpt":"","text":"The way to send a HTTP request with golang1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"encoding/base64\" \"github.com/imroc/req/v3\" \"github.com/jltorresm/otpgo\" \"github.com/jltorresm/otpgo/config\")func main() { t := otpgo.TOTP{ Key: \"wang.tianchen333@gmail.comHENNGECHALLENGE003\", Algorithm: config.HmacSHA512, } token, _ := t.Generate() token1 := \"wang.tianchen333@gmail.com\" +\":\" + token auto := \"basic \" + base64.StdEncoding.EncodeToString([]byte(token1)) user := &amp;User{github: \"https://gist.github.com/xiaogeamadeus/ad9d74723a99a882c850eabb66c51d9d\", contact: \"wang.tianchen333@gmail.com\", solution: \"golang\"} client := req.C().EnableDumpAllWithoutResponse() client.R(). SetHeaders(\"Authorization\", auto, \"Content-Type\", \"application/json\",). SetBody(user). Post(\"https://api.challenge.hennge.com/challenges/003\")}type User struct { github string `json:\"github_url\"` contact string `json:\"contact_email\"` solution string `json:\"solution_language\"`} 12345678910111213141516171819202122232425262022/03/12 20:53:40.763848 DEBUG [req] GET https://api.challenge.hennge.com/challenges/003:authority: api.challenge.hennge.com:method: GET:path: /challenges/003:scheme: httpsuser-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36accept-encoding: gzip:status: 403content-type: application/jsoncontent-length: 68date: Sat, 12 Mar 2022 11:53:42 GMTx-amzn-requestid: 2492fed6-b665-4d3e-becb-0532ed6fb218access-control-allow-origin: https://challenge.hennge.comaccess-control-allow-headers: Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Tokenx-amzn-errortype: MissingAuthenticationTokenExceptionx-amz-apigw-id: O3p3EH04NjMFdIQ=access-control-allow-methods: GET,OPTIONS,POST,PUTx-cache: Error from cloudfrontvia: 1.1 e2f427863e6bdb72ad8bed72b596d81e.cloudfront.net (CloudFront)x-amz-cf-pop: OSL50-P1x-amz-cf-id: nLWbqmaTIGAh2btKEQOFDkk5LDTgu6DBtboJS9a-OCPfaEZ08ubPqQ=={ \"message\": \"User is not authorized to access this resource\"} 1\"github_url\": \"https://gist.github.com/xiaogeamadeus/ad9d74723a99a882c850eabb66c51d9d\",\"contact_email\": \"wang.tianchen333@gmail.com\",\"solution_language\": \"golang\" 1{\"github_url\":\"https://gist.github.com/hennge/b859bd12e7a7fb418141\",\"contact_email\":\"ninja@example.com\",\"solution_language\":\"golang\"}","categories":[],"tags":[{"name":"Project-Go","slug":"Project-Go","permalink":"http://example.com/tags/Project-Go/"}]},{"title":"Gogee_Day2 コンテキスト","slug":"Gogee-Day2-コンテキスト","date":"2022-03-09T11:03:59.000Z","updated":"2022-03-14T00:59:34.460Z","comments":true,"path":"2022/03/09/Gogee-Day2-コンテキスト/","link":"","permalink":"http://example.com/2022/03/09/Gogee-Day2-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88/","excerpt":"","text":"本部分主要内容： 将router独立出来，方便之后增强。 设计context，封装Request和Response，提供对JSON（JavaScript Object Notation）、HTML等返回类型的支持。 コンテキストの設計必要がある？ 对于web服务来说，无非就是根据Request*http.Request，构造响应http.ResponseWriter。但这两个对象所提供的API太细了，比如，如果我们想要构建一个完整的Response，需要考虑Header，Body，而Header包含了状态码 (StatusCode)，消息类型(ContentType) 等几乎每次请求都要设置的信息。所以如果不进行有效的封装，使用这个框架的用户需要写大量重复且复杂的代码，还容易出错。所以说对于一个好的框架而言，能够高效的构造出HTTP响应是一个关键点。 针对使用场景来说，封装*http.Request和http.ResponseWriter的方法，简化相关port的调用只是设计Context原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态router/hello/:name，参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context可以随着每一个请求的出现而产生，也随着请求的结束而销毁。所以设计Context结构，我们可以将复杂性和扩展性留在内部，对外简化了port和router的处理函数；要实现的中间件、参数都统一使用Context实例，就像一个百宝箱，可以在其中找到任何东西。 具体的に実現する123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package gogeeimport( \"encoding/json\" \"fmt\" \"net/http\")type H map[string]interface{}type Context struct{ //origin objects Writer http.ResponseWriter Req *http.Request //request info Path string Method string //response info StatusCode int}func newContext(w http.ResponseWriter, req *http.Request) *Context{ return &amp;Context{ Writer: w, Req: req, Path: req.URL.Path, Method: req.Method, }}func (c *Context) PostForm(key string) string{ return c.Req.FormValue(key)}func (c *Context) Query(key string) string{ return c.Req.URL.Query().Get(key)}func (c *Context) Status(code int) { c.StatusCode = code c.Writer.WriteHeader(code)}func (c *Context) SetHeader(key string, value string){ c.Writer.Header().Set(key, value)}func (c *Context) String(code int, format string, values ...interface{}){ c.SetHeader(\"Content-Type\", \"text/plain\") c.Status(code) c.Writer.Write([]byte(fmt.Sprintf(format, values...)))}func (c *Context) JSON(code int, obj interface{}){ c.SetHeader(\"Content-Type\", \"application/json\") c.Status(code) encoder := json.NewEncoder(c.Writer) if err := encoder.Encode(obj); err != nil{ http.Error(c.Writer, err.Error(), 500) }}func (c *Context) Data(code int, data []byte){ c.Status(code) c.Writer.Write(data)}func (c *Context) HTML(code int, html string){ c.SetHeader(\"Content-Type\",\"text/html\") c.Status(code) c.Writer.Write([]byte(html))} 第一步给map[string]interface{}起别名gogee.H这样在构建JSON数据时更加简洁。 Context结构目前只包含http.ResponseWriter和*http.Request不过同时提供了对于Method/Path等request的常用属性的直接访问。 代码提供了访问Query和PostForm参数的方法。 代码提供了快速构造String/Data/JSON/HTML响应的方法。 Router我们将路由相关的方法和结构提取出来，放到了一个新的文件router.go中，方便我们下一次对于router的功能进行增强，比如提供动态路由的支持。同时，router的handle方法做了一个细微的调整，将handler的参数变为了Context。 12345678910111213141516171819202122232425262728package gogeeimport ( \"net/http\")type router struct { handlers map[string]HandlerFunc}func newRouter() *router { return &amp;router{handlers: make(map[string]HandlerFunc)}}func (r *router) addRoute(method string, pattern string, handler HandlerFunc) { key := method + \"_\" + pattern r.handlers[key] = handler}func (r *router) handle(c *Context) { key := c.Method + \"_\" + c.Path if handler, ok := r.handlers[key]; ok { handler(c) } else { c.String(http.StatusNotFound, \"404 NOT FOUND: %s\\n\", c.Path) }} 框架入口在修改了router并且增加了context部分之后，我们可以大幅度缩减gogee.go文件的内容。因为一些复杂的东西已经被放在router.go和Context.go之中了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package gogeeimport ( \"log\" \"net/http\")// HandlerFunc defines the request handler used by Gogeetype HandlerFunc func(*Context)// Engine implement the interface of ServeHTTPtype Engine struct { router *router}// New is the constructor of Gogee.Enginefunc New() *Engine { return &amp;Engine{router: newRouter()}}// addRoute is the way to add something to routefunc (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) { log.Printf(\"Route %4s - %s\", method, pattern) engine.router.addRoute(method, pattern, handler)}// GET defines the method to add GET requestfunc (engine *Engine) GET(pattern string, handler HandlerFunc) { engine.addRoute(\"GET\", pattern, handler)}//POST defines the method to POST requestfunc (engine *Engine) POST(pattern string, handler HandlerFunc) { engine.addRoute(\"POST\", pattern, handler)}//Run definesd the method to start a http serverfunc (engine *Engine) Run(addr string) (err error) { return http.ListenAndServe(addr, engine)}// To use the ListenAndServe, we need to set a ServeHTTP structfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := newContext(w, req) engine.router.handle(c)} 当然最重要的还是通过实现了ServeHTTP的接口之后，接管了所有的HTTP请求。 最后，稍微修改一下main.go文件。 123456789101112131415161718192021222324252627package mainimport ( \"gogee\" \"net/http\")func main() { r := gogee.New() r.GET(\"/\", func(c *gogee.Context) { c.HTML(http.StatusOK, \"&lt;h1&gt;Hello Gogee&lt;/h1&gt;\") }) r.GET(\"/hello\", func(c *gogee.Context) { c.String(http.StatusOK, \"hello %s, you're at %s\\n\", c.Query(\"name\"), c.Path) }) r.POST(\"/login\", func(c *gogee.Context) { c.JSON(http.StatusOK, gogee.H{ \"username\": c.PostForm(\"username\"), \"password\": c.PostForm(\"password\"), }) }) r.Run(\":9999\")}","categories":[],"tags":[{"name":"Project-Go","slug":"Project-Go","permalink":"http://example.com/tags/Project-Go/"}]},{"title":"Terminal for Mac","slug":"Terminal-for-Mac","date":"2022-03-09T01:15:29.000Z","updated":"2022-03-31T00:32:52.403Z","comments":true,"path":"2022/03/09/Terminal-for-Mac/","link":"","permalink":"http://example.com/2022/03/09/Terminal-for-Mac/","excerpt":"","text":"The Basic Operation of Shell for Mac更改目录：123cd &lt;Path&gt; //找到对应路径cd .. //移动到上一级目录pushd &lt;Path&gt; //记住来源的同时移动到其他目录，popd 返回来源 目录列举123456ls //列举出当前目录下所有的文件和子目录 //可以使用通配符 * 来缩小搜索范围。 //例1: 列举所有以\".java\"结尾的文件 ls *.java //例2：列举所有以\"F\"开头，\".java\"结尾的文件 ls F*.java 创建目录12mkdir //系统mkdir books //示例 移除文件12rm //系统rm somefile.java //示例 移除目录12rm -r //系统rm -r books //示例 重复命令12!! //重复上条命令!n //重复倒数第n条命令 命令历史1history //系统 文件解压1234//Linux/Mac 都有命令行解压程序 unzip，你可以通过互联网为 Windows 安装命令行解压程序 unzip。//图形界面下（Windows 资源管理器，Mac Finder，Linux Nautilus 或其他等效软件）右键单击该文件，//在 Mac 上选择“open”","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://example.com/tags/Shell/"}]},{"title":"Git基礎","slug":"Git基礎","date":"2022-03-09T01:10:22.000Z","updated":"2022-03-10T12:15:42.074Z","comments":true,"path":"2022/03/09/Git基礎/","link":"","permalink":"http://example.com/2022/03/09/Git%E5%9F%BA%E7%A4%8E/","excerpt":"","text":"Gitを使って方法（Mac）建立仓库，并与git连接方法一 github上新建一个repository 复制repository的ssh地址 打开终端输入命令 cd /users/xiaogeamadeus/mygo/src 然后克隆项目 git clone ssh (copy from github) 在vscode新建一个工程，路径为刚克隆的文件夹 方法二 本地创建一个repository mkdir projectname cd projectname 通过git init命令将这个projectname目录变为git可以管理的目录 git init 如何提交修改 切换到项目文件夹所在的路径 ``cd /users/xiaogeamadeus/mygo/project(created)` 输入 git add . 将文件添加到仓库（.代表提交所有文件） git commit -m \"day1\" 把文件提交到暂存区（””内为本次提交的说明，用于方便找到提交记录） git push 上传到github","categories":[],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://example.com/tags/Tools/"}]},{"title":"Go Module","slug":"Go-Module","date":"2022-03-09T00:13:39.000Z","updated":"2022-03-09T00:30:04.420Z","comments":true,"path":"2022/03/09/Go-Module/","link":"","permalink":"http://example.com/2022/03/09/Go-Module/","excerpt":"","text":"Go Moduleとはgo在更新到1.13版本之后，由官方将其令人诟病的依赖管理进行了维护。 go module 是 go 官方自带的go依赖管理库(Dependency Management Library) go module 可以将某个项目（文件夹）下所有的依赖整理成一个go.mod文件，里面写入了依赖的版本等。 使用了go module之后我们可以不用将代码放在src下了。 Go Module的使用方法初始化 12cd /your catalog/test(your project)go mod init test 这时候会发现项目文件夹下多出了一个go.mod文件夹","categories":[],"tags":[{"name":"Project-Go","slug":"Project-Go","permalink":"http://example.com/tags/Project-Go/"}]},{"title":"ウェブサービス設計基礎","slug":"ウェブサービス設計基礎","date":"2022-03-08T07:39:37.000Z","updated":"2022-03-30T05:23:25.426Z","comments":true,"path":"2022/03/08/ウェブサービス設計基礎/","link":"","permalink":"http://example.com/2022/03/08/%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E8%A8%AD%E8%A8%88%E5%9F%BA%E7%A4%8E/","excerpt":"","text":"How the Web Works?平时在上网的时候，打开浏览器，输入网址，按下回车，显示想要的内容。这个过程电脑端与服务器端是怎样实现的呢？ 对于普通的上网过程，系统是这样做的：浏览器是一个客户端(client-site)，当你输入URL时，首先浏览器会请求DNS服务器，通过DNS服务器获取域名所对应的IP，然后通过IP地址找到Ip对应的服务器，要求建立TCP链接，等浏览器发送完HTTP Request（请求）包之后，服务器(server-site)接收到请求包，处理请求包，调用自身服务，返回HTTP Response（响应）包；客户端收到来自服务器的响应后开始渲染这个Response包中的主体(body)，等收到全部的内容后端开与服务器之间的TCP链接。 一个web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。这个客户端一般指的是web浏览器。 web服务器端的功能可以被总结为以下几点 客户端通过TCP/IP协议建立到服务器的TCP连接。 客户端向服务器发送HTTP协议请求包(HTTP Request)，请求服务器里的资源文档。 服务器向客户端发送HTTP协议应答包(HTTP Response)，如果请求的资源包含动态语言，服务器会调用动态语言的解释引擎处理“动态内容”，并将处理得到的数据返回给客户端。 客户端与服务器断开，由客户端解释HTML文档，在客户端屏幕上渲染图形结果。 注：客户端与服务器之间的通讯是非持久性的，服务器发送了应答之后就会与客户端断开连接，等待下一次请求。 URLとDNS略，Computer Science：an Overview讲过 注：DNS使用的是递归查询过程+迭代查询过程，最后获取IP地址 HTTP ProtocolHTTP协议是web工作的核心。想要了解web的工作原理，就要了解HTTP是怎么工作的。 HTTP(Hyper Text Transfer Protocol) 超文本传输协议：客户端可能发送给服务器什么样的消息以及得到什么样的响应。 HTTP是一种让web服务器与浏览器（客户端）通过互联网(Internet)发送与接收数据的协议，它建立在TCP协议之上，一般采用TCP的80端口。它是一个请求与响应的协议：客户端发出请求，服务器响应请求。服务器不能主动联系客户端，也不能给客户端发出回调链接。客户端与服务器端都可以提前中断一个连接。 HTTP协议是无状态的，同一个客户端的这次请求和上次请求没有任何对应关系。服务器并不知道这两个请求是否来自同一个客户端。为了解决这个问题，web程序引入了cookie机制来维护连接的可持续状态。 HTTP Requests (Client Site)对于客户端发出的HTTP请求包，其结构分为三部分。第一部分为Request line（请求行），第二部分叫request header（请求头），第三部分是body（主体）。header 和 body之间有个空行，如下所示。 12345678GET /domains/example/ HTTP/1.1 //请求行: 请求方法 请求URI HTTP协议/协议版本Host：www.iana.org //服务端的主机名User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4 //浏览器信息Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 //客户端能接收的MIMEAccept-Encoding：gzip,deflate,sdch //是否支持流压缩Accept-Charset：UTF-8,*;q=0.5 //客户端字符编码集//空行,用于分割请求头和消息体//消息体,请求资源参数,例如POST传递的参数 HTTP协议定义了许多与服务器交互的请求方法，最基本的有4种，GET/ POST/ PUT/ DELETE。一个URL地址用于描述一个网络上的资源，而HTTP的四个基本操作对应着对这个资源的查，增，改，删。 GET一般用于获取/查询资源信息，POST一般用于更新资源信息。 GET与POST的区别如下： GET的请求body为空，而POST的body不为空 GET提交的数据会放到URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx? name=test1&amp;id=123456POST方法则是把提交的数据放到HTTP包的body中。 GET提交的数据大小有限制，POST无限制 GET提交数据会带来安全问题（URL会显示账号密码，类似zoom的登陆URL） HTTP Response (Server site)HTTP的response包结构如下 123456789HTTP/1.1 200 OK //状态行Server: nginx/1.0.8 //服务器使用的WEB软件名及版本Date:Date: Tue, 30 Oct 2012 04:14:25 GMT //发送时间Content-Type: text/html //服务器发送信息的类型Transfer-Encoding: chunked //表示发送HTTP包是分段发的Connection: keep-alive //保持连接状态Content-Length: 90 //主体内容长度//空行 用来分割消息头和主体&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"... //消息体 其第一行叫做状态行，由HTTP协议版本号，状态码，状态消息三部分组成 状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response。对于HTTP/1.1版本来说，状态码情况如下： 1XX 提示信息 - 表示请求已被成功接收，继续处理 2XX 成功 - 表示请求已被成功接收，理解，接受 3XX 重定向 - 要完成请求必须进行更进一步的处理 4XX 客户端错误 - 请求有语法错误或请求无法实现 5XX 服务器端错误 - 服务器未能实现合法的请求 本质上还是被分为Header（包含状态行）与Body。 HTTP と Connection: keep-alive从HTTP/1.1起，默认开启了Keep-Alive保持连接特性，其含义是当一个网页完成打开后，客户端与服务器之间用于传输的TCP连接不会被关闭。如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。 Keep-Alive不会永久保持，有一个保持时间，可以设定。 Goを使ってウェブサーバーをつくよう！对于Go语言来说，其提供给了我们一个完整的net/http包，这样可以很方便的搭建起一个可以运行的web服务。这个使用包也能很简单的对于web的router、静态文件、模版、cookie等数据进行操作和设置。 Use net/http Package to Create a Web Server123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"log\" \"net/http\" \"strings\")func sayhelloName(w http.ResponseWriter, r *http.Request) { r.ParseForm() // 解析参数，default是不解析的。 fmt.Println(r.Form) // 这些信息是输出到服务器端的打印信息。 fmt.Println(\"path\", r.URL.Scheme) fmt.Println(\"scheme\", r.URL.Scheme) fmt.Println(r.Form[\"url_long\"]) for k, v := range r.Form { fmt.Println(\"key:\", k) fmt.Println(\"val:\", strings.Join(v, \"\")) } fmt.Fprintf(w, \"Hello XiaoGeAmadeus!\") // 将你想说的话写入w，之后会在客户端输出。}func main() { http.HandleFunc(\"/\", sayhelloName) //设置访问的路由 err := http.ListenAndServe(\":9090\", nil) //设置监听的端口 if err != nil { log.Fatal(\"ListenAndServe: \", err) }} 上面的代码，当我们build之后，就已经在9090端口监听http链接请求了。 可以在浏览器输入http://localhost:9090进行实验。 Goがウェブを動かすの方法我们可以看见简单应用net/http包就可以很轻松的用Go搭建起web服务。那么go在底层是怎么做的呢？ Several concepts of how the web worksRequest：用户请求的信息，用来解析用户的请求信息，包括POST、GET、cookie、url等信息。 Response：服务器需要反馈给客户端的信息 Conn：用户的每次请求链接 Handler：处理请求和生成返回信息的处理逻辑 Analyze the http package operation mechanism 创建Listen Socket，监听指定的端口，等待客户端请求到来。（Socket是什么） Listen Socket接受客户端的请求，得到Client Socket，接下来通过Client Socket与客户端通信。 处理客户端的请求，首先从Client Socket读取HTTP请求的协议头，如果是POST方法，还需要读取客户端提交的数据，然后交给相应的handler处理请求，handler处理完毕准备好客户端需要的数据，通过Client Socket写给客户端。 在整个过程中，我们只需要了解三个问题，就可以明白Go是如何让Web运行起来的。 如何监听端口？ 如何接收客户端请求？ 如何分配handler？ How to Listen the Part从前面小节的代码中我们可以看出，对于监听来说，net/http包中有一个专用的APIListenAndServe来进行处理。 1234func ListenAndServe(addr string, handler Handler) error { server := &amp;Server{Addr: addr, Handler: handler} return server.ListenAndServe()} ListenAndServe会初始化一个sever对象，然后调用了Server对象的方法ListenAndServe。其源码如下： 1234567891011121314151617func (srv *Server) ListenAndServe() error{ //对于Server对象的ListenAndServe方法。 if srv.shuttingDown() { return ErrServerClosed } addr := srv.Addr if addr == \"\" { addr = \":http\" } ln, err := net.Listen(\"tcp\", addr) if err != nil { //若err值不为空（出现了错误值） return err //返回错误值 } return srv.Serve(ln)} ListenAndServe调用了net.Listen(\"tcp, addr\")，也就是底层用TCP协议搭建了一个服务，最后调用src.Serve监控我们设置的端口。监控之后如何接受客户端的请求呢？ How to Accept the Request from client-sideServe的具体实现如下（仅包括关键代码），通过下面的分析源码我们可以看到客户端请求的具体处理过程： 1234567891011121314151617181920func (srv *Server) Serve(l net.Listener) error { ... ctx := context.WithValue(baseCtx, ServerContextKey, srv) for { rw, err := l.Accept() ... connCtx := ctx if cc := srv.ConnContext; cc != nil { connCtx = cc(connCtx, rw) if connCtx == nil { panic(\"ConnContext returned nil\") } } tempDelay = 0 c := srv.newConn(rw) c.setState(c.rwc, stateNew, runHooks) //before Serve can return go c.serve(connCtx) }} 这个函数利用了for循环，首先通过Listener接受请求l.Accept()，其次创建一个Conn：c := srv.newConn(rw) ，最后单独开了一个goroutine，把这个请求的数据当成参数扔给这个conn去服务：go c.serve(connCtx)。这个就是对于高并发的体现。用户的每一次请求都是在一个新的goroutine去服务，相互不影响。 How to distribute the function to solve request.那么如何分配具体的函数来处理请求呢？我们继续分析conn的serve方法，其源码如下（仅展示关键代码）： 12345func (c *conn) serve(ctx context.Context) { ... ctx, cancelCtx := context.WithCancel(ctx)}","categories":[],"tags":[{"name":"Project-Web","slug":"Project-Web","permalink":"http://example.com/tags/Project-Web/"}]},{"title":"Routing for Web Developer","slug":"Routing-for-Web-Developer","date":"2022-03-08T01:38:20.000Z","updated":"2022-03-14T09:26:51.349Z","comments":true,"path":"2022/03/08/Routing-for-Web-Developer/","link":"","permalink":"http://example.com/2022/03/08/Routing-for-Web-Developer/","excerpt":"","text":"在web开发过程中，经常会遇到“路由”（Routing）的概念。路由到底是什么？简单来说，路由就是URL到函数的映射。是用来跟后端服务器进行交互的一种方式，通过不同的路径来请求不同的资源，请求不同的页面。ネットワーク上でデータを転送する際、その経路を導き出すことをルーティングと呼びます。 The Flow Path of Routing 服务器发出请求。 服务器端监听到80端口（http）或者443端口（https）有请求，并且解析URL路径。 根据服务器的路由配置，返回相应信息（html / json / image）。 浏览器根据数据包的content-type来决定如何解析数据。 The Difference between Router and Routeroute 就是一条路由，将一条URL路径与一个函数进行映射，例如 /users -&gt; getAlUsers() /users/count -&gt; getUsersCount() 这就是两条路由，访问users时，将会执行getAllUsers()函数；当访问 /users/count时，会执行getUsersCount()函数 而router（路由器）可以理解为一个容器，或者说一种机制，他管理了一组route。route执行的过程是由router来处理的。”The router routes you to a route.” The Route of Server对于服务器来说，当接收到客户端发来的http请求，会根据请求的URL，来找到相应的映射函数，并且执行，将返回值发回客户端。 12345app.get('/', (req, res)=&gt;{undefinedres.sendFile('index')}) 1234app.get('/users', (req,res)=&gt;{undefineddb.queryAllUsers().then(data =&gt; res,send(data))}) 这里定义了两条路由，访问/时，会返回index界面；访问/users时，会从数据库中读取所有的用户数据并返回。 Dynamic Router と Static RouterStatic Router静态路由是由管理员手工配置的，简单直接，是什么就是什么。但缺点在于如果网络拓扑发生变化/故障时静态路由也得由管理员亲手修改。 举个例子来说，就像公交车一样，路线与停靠站都是决定好的，就算有近路或者路线被堵了也只能按照规定好的路线走。 对于家用路由器来说每个家用路由中都有一条设定好的默认路由。默认添加了一条指向wan口的默认路由。因为没有第二条路走所以大丈夫。 Dynamic Router现在我们来到一座陌生的城市，我们用google map进行导航。这里面，googlemap其实分了两步操作。第一步手机会自动下载我们周围的道路信息，第二步是根据算法计算出一条最好的路径去目的地。 动态路由适合大型网络，不需要手动添加路由条目，方便管理。 就好比出租车，会抄近路，也可以看路况抄近路，出租车司机的路由表是随时更新的。动态路由的最大特点是路由器上运行路由协议，使路由器可以自动根据网络拓扑的变化调整路由条目。 动态路由的工作方式：第一步，路由器获得全网的拓扑，包含了所有路由器和路由器之间的链路信息，拓扑就是地图。 第二步，路由器在拓扑中计算出到达目的地网址的最优路径。 Pros and Cons优点：静态路由：简单、高效、可靠、网络安全、转发效率高。 ​ 动态路由：灵活，能够适应网络结构的变化，无需管理员手工维护，减轻了管理员的工作负担。 缺点：静态路由：不能灵活的适应网络动态变化 ​ 动态路由：占用网络带宽。（用于传输路由更新信息） 使用场景：静态路由：网络规模不大，拓扑结构固定的网络中。 ​ 动态路由：网络规模大，网络拓扑机构复杂的网络。","categories":[],"tags":[{"name":"Web_Developer","slug":"Web-Developer","permalink":"http://example.com/tags/Web-Developer/"}]},{"title":"Gogee_Day1 HTTP基礎・APIの構築","slug":"Gogee-Day1-HTTP基礎・APIの構築","date":"2022-03-08T01:24:28.000Z","updated":"2022-03-09T02:53:42.667Z","comments":true,"path":"2022/03/08/Gogee-Day1-HTTP基礎・APIの構築/","link":"","permalink":"http://example.com/2022/03/08/Gogee-Day1-HTTP%E5%9F%BA%E7%A4%8E%E3%83%BBAPI%E3%81%AE%E6%A7%8B%E7%AF%89/","excerpt":"","text":"Goでウェブサービスを動かすGo语言内置了net/http库，并且封装了http网络编程的基础接口。这样我们可以很便利的实现web接入。Gogee也是基于net/http的框架。举个例子： 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"log\" \"net/http\")func main() { // set 2 route- \"/\" and \"/hello\" http.HandleFunc(\"/\", indexHandler) http.HandleFunc(\"/hello\", helloHandler) // launch web service // :9999 : address AT 9999 port // nil : solve instance by Standard library log.Fatal(http.ListenAndServe(\":9999\", nil))}//handler echoes r.URL.Pathfunc indexHandler(w http.ResponseWriter, req *http.Request) { fmt.Fprintf(w, \"URL.Path = %q\\n\", req.URL.Path)}//handler echoes r.URL.Headerfunc helloHandler(w http.ResponseWriter, req *http.Request) { for k, v := range req.Header { fmt.Fprintf(w, \"Header[%q] = %q\\n\", k, v) }} ![截屏2022-03-08 11.44.50](Gogee-Day1-HTTP基礎・APIの構築/截屏2022-03-08 11.44.50.png) http.handler API の実現handler是什么呢？查看一下net/http的源码。 1234567package httptype Handler interface { ServeHTTP(w ResponseWriter, r *Request)}func ListenAndServe(address string, h Handler)error 12345678910111213141516171819202122232425262728#### ServeHTTPとは在Golang中，你要构建一个web服务，必然要用到```http.ListenAndServe```对于```ListenAndServe```来说，他的方法签名为```http.ListenAndServe(address, handler)```所以，如果想要用```ListenAndServe``` 两种方式。1. 自己定一个struct，并在上面实现```ServeHTTP```方法。 ```go type myhandler int func(m myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request){ -, err := fmt.Fprintln(w, \"hello this is golang ServeHTTP\") if err != nil{ fmt.Println(\"the error occured:\", err) }else{ fmt.Println(\"someone is accessing:\" r.Method) } } func main(){ var hello myHandler fmt.println(\"begin to listen\") http.ListenAndServe(\":9999\", hello) } 使用nil作为handler。 nil在golang的http包下的server.go文件中有过定义。 123if handler == nil{handler = DefaultServeMux} 可以看到在ListenAndServe中传入nil，本质上就是在调用DefaultServeMux 所以，利用ListenAndServe的第一个特点，我们可以构建自己的structengine，并在上面实现Serve HTTP。 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"log\" \"net/http\")// Engine is the uni handler for all requeststype Engine struct{}// ResponseWriter: create the response of this HTTP request.// http.Request: all the information of this HTTP request. For example, the address, Header and Bodyfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request){ switch req.URL.Path{ case \"/\": fmt.Fprintf(w, \"URL.Path = %q\\n\", req.URL.Path) case \"/hello\": for k, v := range req.Header{ fmt.Fprintf(w, \"Header[%q] = %q\\n\", k, v) } default: fmt.Fprintf(w, \"404 NOT FOUND: %s\\n\", req.URL) }}func main() { // Transfer all the request to our own solution. engine := new(Engine) // launch web service // :9999 : address AT 9999 port // log.Fatal(http.ListenAndServe(\":9999\", engine))} 在实现了engine之后，我们拦截了所有的HTTP请求，拥有了统一的控制入口，并且可以自由定义这些请求的路由映射的规则，或者统一处理他们。到这里我们就可以发现我们走出了实现web框架的第一步。 Gogeeフレームワークの骨組み我们所设想的框架目录结构是这样的。 12345Gogee/ |--Gogee.go |--go.modmain.gogo.mod 把Gogee与main分开放两个文件夹的原因是 Go语言的package对于每个文件夹有且只能有一个，所以Gogee的package和main的package重复了 go.mod借用go module来管理依赖 12345678module Gogeego 1.17require Gogee v0.0.0// Reference relative pathreplace Gogee =&gt; ./Gogee 用replace将Gogee指向 ./Gogee main.go123456789101112131415161718192021222324package mainimport ( \"fmt\" \"net/http\" \"Gogee\")func main() { r := Gogee.New() r.GET(\"/\", func(w http.ResponseWriter, req *http.Request) { fmt.Fprintf(w, \"URL.Path = %q\\n\", req.URL.Path) }) r.GET(\"/hello\", func(w http.ResponseWriter, req *http.Request) { for k, v := range req.Header { fmt.Fprintf(w, \"Header[%q] = %q\\n\", k, v) } }) r.Run(\":9999\")} 使用New()创建Gogee的实例，使用GET()添加路由，最后使用Run()启动Web服务。（目前只是静态路由） Gogee.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Gogeeimport ( \"fmt\" \"net/http\")// HandlerFunc defines the request handler used by Gogeetype HandlerFunc func(http.ResponseWriter, *http.Request)// Engine implement the interface of ServeHTTPtype Engine struct{ router map[string]HandlerFunc}// New is the constructor of Gogee.Enginefunc New() *Engine{ return &amp;Engine{router: make(map[string]HandlerFunc)}}// addRoute is the way to add something to routefunc (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc){ key := method + \"-\" + pattern engine.router[key] = handler}// GET defines the method to add GET requestfunc (engine *Engine) GET(pattern string, handler HandlerFunc){ engine.addRoute(\"GET\", pattern, handler)}//POST defines the method to POST requestfunc (engine *Engine) POST(pattern string, handler HandlerFunc){ engine.addRoute(\"POST\", pattern, handler)}//Run definesd the method to start a http serverfunc (engine *Engine) Run(addr string) (err error){ return http.ListenAndServe(addr, engine)}// To use the ListenAndServe, we need to set a ServeHTTP structfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { key := req.Method + \"-\" + req.URL.Path if handler, ok := engine.router[key]; ok { handler(w, req) } else { w.WriteHeader(http.StatusNotFound) fmt.Fprintf(w, \"404 MOT FOUND: %s\\n\", req.URL) }} 首先定义了type HandlerFunc，这是提供给框架用户的，用来定义路由映射的处理方法。 我们在Engine中，添加了一张路由映射表router， key由请求方法与静态路由地址构成，比如GET-/、GET-/hello、POST-/hello，这样针对相同的路由，如果请求的方式不同，可以映射不同的Handler 当用户调用(*Engine).GET()方法时，会将路由和处理方法注册到router中（addroute方法）。(*Engine).Run()方法，是ListenAndServe的封装。 Engine实现的ServeHTTP方法的作用是解析请求的路径，查找router，如果查到，执行注册的处理方法，如果查不到，返回404 NOT FOUND。 执行go run main.go再用curl访问即可。","categories":[],"tags":[{"name":"Project-Go","slug":"Project-Go","permalink":"http://example.com/tags/Project-Go/"}]},{"title":"GoでWebフレームワークを書く","slug":"GoでWebフレームワークを書く","date":"2022-03-08T01:09:47.000Z","updated":"2022-03-16T00:07:09.707Z","comments":true,"path":"2022/03/08/GoでWebフレームワークを書く/","link":"","permalink":"http://example.com/2022/03/08/Go%E3%81%A7Web%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%92%E6%9B%B8%E3%81%8F/","excerpt":"","text":"Goを使ってWebフレームワークを作りましょう最近Go言語には興味があり、GoでWebサービスを構築できるようになるために、GinのWebフレームワークを学んでいます。Ginの特性は深く理解できるのため、Goで自分のWebフレームワークを作ってみようと思います。「Gogee」と言います。GogeeのコードはGinのソースコードを研究して得たもので、あくまで学習用として使用しています。 カタログDAY 1：HTTP基礎・APIの構築 DAY 2：コンテキスト DAY 3：Trie木ルータ","categories":[],"tags":[{"name":"Project-Go","slug":"Project-Go","permalink":"http://example.com/tags/Project-Go/"}]},{"title":"Map & Collection","slug":"Map-Collection","date":"2022-03-01T07:53:50.000Z","updated":"2022-03-01T08:14:20.554Z","comments":true,"path":"2022/03/01/Map-Collection/","link":"","permalink":"http://example.com/2022/03/01/Map-Collection/","excerpt":"","text":"この記事は、日本語やプログラミングスキルを向上するために書きました。著者は中国出身ですから、言語、文法のミスがいっぱいあるかもしれない… Map と Collection のまとめ（自分用）一种优化查询时间的常用方法 ——Map。 预处理线性，查询时间为对数。 Map：成对的元素，每个元素由键与值构成。 &lt;index, value&gt; Collection：孤立的元素，只包含元素的值。 &lt;value&gt; 注意： Map中的值可以重复，但键不允许重复。 常用的Map集合：HashMap/ LinkedHashMap HashMap 方法HashMap&lt;k, v&gt; 采用哈希表结构存储数据，元素的存取顺序不能保证是一致的 LinkedHashMap 方法LinkedHashMap&lt;k, v&gt; 采用哈希表+链表结构存储数据，可以保证元素的存取顺序一致 Map结构的APIget(Object k)：返回指定键所映射的值 put(key k, value v)：将值与映射中的键关联 remove(Object k)：如果存在一个键为k的映射关系，将其删除 clear()：删除Map中所有键/值对 Map集合遍历键找值方式Map集合遍历键值对方式","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://example.com/tags/Programming/"}]},{"title":"AWS Solutions Architect Associate C02","slug":"AWS-Solutions-Architect-Associate-C02","date":"2022-02-26T04:21:45.000Z","updated":"2022-02-26T05:06:03.708Z","comments":true,"path":"2022/02/26/AWS-Solutions-Architect-Associate-C02/","link":"","permalink":"http://example.com/2022/02/26/AWS-Solutions-Architect-Associate-C02/","excerpt":"","text":"この記事は、AWS-SAAC02に関連するレビューの概要を記録しました。 英語試験を選択したため、英語/中国語で書きました。 AWS Solutions Architect Associate C02At the beginning, please remember that you’re a architect associate. So you just need to know how to construct scalable, highly available, cost-effective, secure, performant, resilient AWS structure. About test170 min (If you aren’t a native speaker of English, the AWS will offer you extra time) 65 questions (15 questions without points) 1000 points (you need to gain more than 720 points to pass the exam) From the exam guide, we can find that there is 4 domains of AWS-SAA: ​ Domain 1: Design Resilient Architectures 30% ​ Domain 2: Design High-performing Architectures 28% ​ Domain 3: Design Secure Applications and Architectures 24% ​ Domain 4: Design Cost-Optimized Architectures 18% OverviewsI divided the AWS for some parts: Compute, Storage, Network, Database, Security, Tools, Contains and Others. ​ Compute: EC2, Elastic Beanstalk, Lambda ​ Storage: EBS, EFS, S3, FsX, instance store, Glacier, Storage gateway ​ Network: VPC, Route53, ELB ​ Database: RDS, DynamoDB, Redshift, Elastic Cache, Aurora, Athena ​ Security: IAM, plenty of Security Groups ​ Tools: Cloud Watch ​ Contains: ECS/EKS ​ Others: ComputeStorageNetworkDatabaseSecurityToolsContainsOthers","categories":[],"tags":[{"name":"AWS-SAAC02","slug":"AWS-SAAC02","permalink":"http://example.com/tags/AWS-SAAC02/"}]},{"title":"全探索","slug":"全探索","date":"2022-02-26T00:39:13.000Z","updated":"2022-02-26T04:20:33.651Z","comments":true,"path":"2022/02/26/全探索/","link":"","permalink":"http://example.com/2022/02/26/%E5%85%A8%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"この記事は、日本語やプログラミングスキルを向上するために書きました。著者は中国出身ですから、言語、文法のミスがいっぱいあるかもしれない… 全探索のまとめ（自分用） 全探索とは、中国語”暴力解法”と言います。多分計算量や時間複雑性はすごく高い、アルゴリズム全然使えない方法です。全探索を選択する前、必ずTime Complexityを確認してください。（P.S. 競プロについて、計算量は 10^8 ~ 10^9 回数のループを越えれば、ACはできません） ビット全探索と順列全探索は別のものです！普通の問題に対して、データが10個以下の場合は順列全探索を、20個以下の場合はビット全探索を使えます。 普段な全探索は、四つの種類があります： 本当に ”全部を調べる” の全探索 なるべく探索の数を減らすの全探索 ビット全探索 順列全探索 本当に”全部を調べる” の全探索 それは普通です、普通のfor/whileループを使って（二層ループの場合もある）コードを書くだけです。 例：ABC144B、ABC150B、ABC122B、ABC136B、ABC106B、ABC120B （ABCに対してレベルBの感じ） なるべく探索の数を減らすの全探索 ”全部を調べる”の全探索より探索数を減らす方法です。今僕を書いた問題は代々”全部を調べる”ことはできないの場合（TLE、ループ回数を超える）、そいよう方法を考えようと思っています。 多分探索したのことを二度と探索しないのために、順列やハッシュなどのデータ構造を使って探索したことを記録します。 例：ABC057C、ABC095C、三井住友信託銀行プログラミングコンテスト2019 D - Lucky PIN （ABCに対して簡単なレベルCの感じ） ビット全探索 初めて知りましたの全探索の種類、ブログ記事に勉強しています。代々みんなはCPPを使って競プロをやります（プログラミング速度を上がくため）。僕はJavaやPythonを使った場合が多いので、多分CPPを練習しようと思っています。 ビット全探索とは、二進数とビットを用いて、ある集合の部分集合を全列挙（全探索）するアルゴリズムのこと。 基礎（Javaに対して）： i &gt;&gt; j：iの桁をjビット右シフトする 例１：6 &gt;&gt; 3 0000 0000 0000 1010（6）右シフト3 結果：0000 0000 0000 0001（1） 例２：-92 &gt;&gt; 2 1111 1111 1111 1111 1111 1111 1010 0100 ​ 0011 1111 1111 1111 1111 1111 1110 1001（1073741801） &amp;：論理積。左右双方の式にセットされているビット。対応するビットが両方とも1の場合，結果は1，それ以外の場合は0となる。 例１：0011 1100 &amp; 0000 1101 0011 1100 (60) ​ 0000 1101 (13) 結果：0000 1100 (12) ビット全探索コード例： 12345678910String[] ar = {\"a\",\"b\",\"c\"}; int n = 3;for (int i=0; i&lt;(Math.pow(2,n)); i++) { String s = \"-\"; for (int j=0; j&lt;n; j++) { if ((1&amp;i&gt;&gt;j) == 1) {s += ar[j];} } System.out.println(s); } 入力：String {a, b, c} 出力：-a, -b, -ab, -c, -ac, -bc, -abc 例：ABC128C、ABC147C 順列全探索 順列全探索とは、決まった数字や文字の列の全ての順列を出力します。時間複雑性はN!ですから、普通は10以下のことを計算すると思います。","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://example.com/tags/Programming/"}]},{"title":"Road to Kyoto University","slug":"Road-to-Kyoto-University-1","date":"2022-02-24T12:04:16.000Z","updated":"2022-02-26T04:26:22.023Z","comments":true,"path":"2022/02/24/Road-to-Kyoto-University-1/","link":"","permalink":"http://example.com/2022/02/24/Road-to-Kyoto-University-1/","excerpt":"","text":"This essay is in honor of one of the most courageous moments of my life. この記事は、短い人生で一つ最も勇気を持ている瞬間を記録するために書いたものです。 京都大学大学院社会情报学修士夏入试经验分享在人生最动荡不安的一段时间，我独身一人来到疫情下的东京，最终合格了第一志愿的京都大学。趁着热忱与记忆还未模糊，决定先将我的备考历程写下，希望能够给正在准备中的你提供微不足道的帮助。 0 はじめに如果要给京大社会情报学修士备考定下一个基调，那么应当是“情报战”。 作为外国人的我们，想要在京大学部生与日本外部生环绕下撕下一个合格名额，那在情报上就要努力与他们站在同一起跑线。我是有些database属性的人，我坚信收集的情报越多，上岸的可能性就越高。 为了收集“情报”，我基本反复看过十遍全网所有的社情经验贴（中文/日文）；潜入了一个上岸日本人组建的社情备考slack组，享受了他们分享的google drive材料；推特上找曾经上岸的日本人私聊；最终找到了适合我的备考路。（P.S.1 这一点可能仅适合于京大社情）（P.S.2 今年确实有我所知的因为情报收集不到位而落的朋友）(P.S.3 更多情报可以参考我的收藏夹中“日本留学”部分) 除此之外，与中文环境下的朋友交流是获得“情报”最快的方式。闭门造车不可取，你是清北佬当我没说。请牢记我们的敌人是日本考生，而不是与中国人自己恶意内卷。共同交流绝对优于隐瞒信息。 或许我这篇文章可以提供足够的“情报”给你，但我仍然希望你重走一遍我的这条路，至少应当看过所有已存在的经验贴吧。之后我会将链接放到文末。 我人生的信条是要么不做，要么全力以赴。恰好和数据库事务的Atomicity碰上了。所以： 本篇经验贴只适合给对日本修士备考有基础了解，有良好的信息收集能力和抗逆能力的同学。我宁可多在这里废话几句也不会给那些随便查一下就明白的基础知识提一个字，如果你向我提问的问题让我觉得你完全没有认真做信息收集的话，我不会回应的。但除此之外的问题我都会认真回答。 另，出售个人备考所写的过去问答案，同时可以提供京大社情辅导，有意者私聊。 1 背景出身校：北京某双非一本/二本（因地区而异）GPA：2.7/5.0专业：自动化科研经历：很水的三作以及更水的一作TOEIC：810日语：语言学校在读，无日语成绩，可以与日本教授完成日常对话级别。以我个人观点来看，以上的所有背景，唯一会对你的考试造成影响的就是英语成绩。英语成绩将换算进入笔试总成绩，对于社情来说，英语占比总成绩的1/4，毫无疑问是决定性的项目。 2 备考历程以下按照时间顺序复述我从开始准备日本修士考试的备考历程。 2019.3 申请语言学校 2020年7月生2019.7 裸考N2 不合格2019.12 裸考托福 492020.1 进入某航道培训托福2020.2 托福取消2020.3 托福取消2020.3 日本封国2020.5 托业 6252020.7 早大综合机械工学 落2020.8 进入某日语培训机构锻炼日语2020.9 托业 7402020.10 菅义伟 我滴超人 宣布日本开门2020.11 第一时间进入日本隔离2021.1 疫情扩大 日本重新关门2021.1 京都大学智能情报学 書類落ち2021.1 东京大学情报学环 先端情报 書類落ち2021.3 托业 7002021.3 东京都立大学 横滨国立大学 筑波大学考试内诺一个没陶瓷到2021.3 拿到早大考试内诺，拿到名大考试内诺，拿到保底的立命馆大学考试内诺2021.4 托业 8102021.5 京大社情说明会2021.7 早大综合机械工学 弃考2021.8 名大智能情报学 弃考2021.8 立命馆大学人间情报专攻 弃考2021.8 京大社会情报学 合格可以看到基本是充斥着失败的两年呢（笑）。可以看到defer一年第二年四月才拿到差不多的英语成绩的我依然合格了，事实证明什么时候准备都不晚（bushi）。 由于此篇经验贴为京大社情相关，其他学校的备考过程略过，以下仅阐述京大社情的备考履历。（P.S.从今时今日的角度来看，因为摸石头过河，我的复习期间仍然有部分决策失误，所幸并没有造成什么后果，所以备考履历仅供参考，对大家的复习建议我会放在后面） 2021年2月，东大学环/京大智能冬入被书类直接鲨掉，我发现以我的背景，只要有书类就一定见不到卷子。痛定思痛之下，决定抛弃东大与京大智能。京大系统需要托福，京大数理难度太高，京大通信不想做硬件，所以将目光聚焦到了京大社情。正好京大社情存在2018年刚刚到来的人机交互世界TOP5神田教授，我决定将2021年夏天的主攻目标放在京大社情神田教授的HRI研究室。 然后看了教授的几十篇论文，写了一篇现在的我看来糟糕的不行的rp去陶瓷了，果不其然石沉大海。实际上想要获得神田老师的邮件回复是要看运气的，对于他来说每天的未知邮件数量太大了。 不过京大是为数不多不需要内诺就可以进行考试的学校之一，总而言之复习的道路就这么开始了。 自此开始全网查找京大社情相关的经验贴，并且在上面的交流群中找到了几位去年上岸的学长。跟他们交流之后决定了自己主要复习的专业课。 在这个时间，自觉自己的托业成绩远远不够，遂连续报名了三月和四月的托业考试，最后拿到了个勉强够用的810。在这个期间也一直在陶瓷保底的学校，因为我已经无法承担再来一年的后果了。家里能够支持，签证时间也不够了。BTW，社情的所有考试科目我在本科都完全没有接触过，所以我的专业课复习分为三轮，第一轮是预习，然后还有二轮复习与三轮复习。 三月开始进行数据库的一轮预习，复习的是一个磨磨叽叽，这期间还把RNG的春季赛皇马的联赛欧冠一场不落的看完了，属实十分拉垮。 四月在复习数据库的基础上花了一个下午总结了人机交互的过去问，发现了考题无限重复，一轮预习直接结束。 五月参加了京大情报研究科的说明会，在说明会上与神田老师对线了十几个问题，发现神田老师和我想象的一样，是一个温柔的人，他真的是我梦想的老师。 参加完说明会后，自觉之前的研究计划书水平太低，遂花两周时间毙掉了无数个idea，憋出一篇新的rp，然后光荣的再次没有收到回复。同时预订了去京都的民宿和新干线，选到了我认为京大周边对于备考生来说最好的民宿。 六月，出愿月，将我四页A4纸的rp缩减到两页，作为了Statement of Objectives而提出。并且完成了数据库的一轮预习，写完了近几年的过去问，开始信息检索的一轮预习。 7月1日，信息检索一轮完成并写完了过去问，看了几天算法和机器学习，机器学习太难了放弃了。同时想了想早大不想复习了直接弃考。 7月2日-7月10日，总结基础的《Computer Science: an Overview》大概总结了40页左右。 7月11日-7月14日，database二轮复习，人机交互过去问背诵 7月15日-7月17日，信息检索二轮复习，人机交互过去问背诵 7月18日-7月20日，基础二轮复习，写完了近几年的基础过去问。 7月21日-7月26日，将之前写过的过去问二轮了一遍， 7月27日-7月30日，最后将三门课三轮复习，每天晚上看一遍基础的书，写过的过去问反复看。 3 复习建议这个小节就是这篇文章的重头戏了。我将详细介绍京大社情考什么，以及每门课怎么复习，重点在哪里。 京大社情的院试总共分为三部分。情报学基础，专业课以及面试。分数配比是情报学基础150分，专业课300分，英语成绩150分，面试100分。但实际上，和其他学长所说的一样，面试的排位基本可以决定你的最终结果，所以说前面的600分至关重要。 在复习建议的最开始，我建议转专业的同学一定要从情报学基础开始。当你把情报学基础复习完成之后，数据库和信息检索的很多知识点就迎刃而解了。比如deadlock/B+树/pagerank我也是在复习完全部才发现了这一点。之前看到日本人的经验贴这么写，我还没有理解… 情报学基础我个人推荐如果希望用英语答题，就用英文版与中文版来复习。如果希望用日语答题，就用日文版和中文版来复习。这本书的章末习题答案很不好找，只有一版英文版。另，第十版和第十一版都可以使用，京大官网给出了对于募集要项的修改。 情报学基础就是将这一本概论性的书籍上的所有东西都考一遍，除了第十章。看着很唬人，实际上总结往年过去问你就能发现，他考的章节是有限的。实际上只聚焦在了： 第一章 数据存储第二章 数据操控第三章 OS第四章 计算机网络第五章+第六章 算法第八章 数据结构第十二章 计算理论这七个部分当中。每年老师会从这七个部分当中抽选五个出题，然后考生可以从这五个中选择三个进行回答，每道题50分。 看起来仍然很头大？没关系，我帮你进一步缩减范围。 21.8考了1 2 4 5 8章 21.2考了1 3 5 8 12章 20.8考了2 3 4 5 8章 20.2考了1 2 4 5 12章… 找到规律了吗？ 任意两次相邻的考试，会将总共七个部分考全，同时第五章的算法每次考试必出。 所以我可以站在这里预测，22.2的社情考试情报学基础将会出OS，算法以及计算理论。剩下两个就不知道了。 所以理论上来讲，你如果能保证这三章能拿到满分，你可以只看三章的内容就可以了。不过我认为还是把这七章老老实实看完吧。 至于怎么复习？所有，所有的课后题以及章末习题全部做一遍。我今年甚至是在全部做一遍的情况下还吃了亏….可以预见性的是今后将越来越难越来越刁钻。只能说祝你好运吧！ P.S.1 过去问有一定可能会重复出，但每年绝对会出大量的新题，所以过去问必须全要会，书上的习题也必须全要会。一般情况下往年的上岸选手都是140/150左右，即底线是错一个小问，但我今年应该是拉垮了。 P.S.2 算法的出题思路从20.8开始转变，老师们开始出课后题的新算法，完全不拘泥于之前的基础算法，算法白给分的好时代已经过去了！ 专业课（所有计算机科学题目中选3）社情是有不少其他方向的专攻的，但完全是黑箱，录取条件复习方法完全不明白。所以我仅在这里讨论计算机科学方向的备考。 对于计算机科学，社情共有六个研究室。 社1 吉川/马研究室，数据库/数据挖掘社2 HRI研究室（神田），人机交互社3 田岛研究室，信息检索社5 伊藤研究室，multiagent，人工智能社6 阿部研究室，密码学社14 緒方研究室，教育工学可以看到，社情的专业课基本上对应了社情这几位教授的专业方向。当然研究室的录取跟你选择不选择对应的题目没有任何关系，毕竟没选不一定代表你不会这个） 目前看下来，目前的出题风向是每年必出的题从原来的四道变成了五道（人机交互、数据库、信息检索、算法、人工智能），算法加入了必出菜单。同时机器学习逐渐淡出出题部分，往年没怎么见过的奇怪题目每年都在增加【21.2的数据挖掘（马强老师）、multiagents（伊藤老师）；21.8的计算机网络，以及非常偏向密码学的算法（阿部老师）】奇怪题目无法准备，建议直接无视。（另，奇怪题目暗示了大概21.2 这两个实验室人没收够所以他们出了题） 对于我个人来说，这五门课的难度是人机交互&lt;数据库&lt;信息检索&lt;算法&lt;人工智能 由于我只复习了前三个最简单的，所以我只会给出详细的前三门课的复习方法，后三门建议看一下其他上岸佬的经验贴。 1. 人机交互京大本科所用书籍如下：Interaction Design: Beyond Human-Computer Interaction 注意是第三版。 中文版只有第四版，实际上区别不大，可以使用，但有不同的地方还是以第三版为主。 这门课正如上岸佬所言，简单粗暴的背就可以了。虽然往年也会出新题，但据我观察新题一般出现在冬天试水，夏天一般很少出现新….. 21.8 出题老师：你再说一遍？ 喜闻乐见的，只准备了底线三道题的我碰到了出了新题的人机交互，我当即就是一个寄。 所以，这道题就是在赌命。如果出了新题，大部分人就直接寄了。得亏今年的新题出的还能编一编。 当然这门课还有更靠谱的复习方式，“你可以每天晚上当故事书看一看。”这是一位上岸佬教我的，这…..我…… 简单罗列一下往年所出的题。这本书其实全篇就是在教你如何构建一个interface/product。历史考过的题有7道，今年新题一道，总共8道题。 开始设计：1. 诺曼6原则（针对交互设计）2. 6个可用性目标（可以被人使用） 如何设计：3. 选择合适界面（12个UI类型）4. 收集数据（收集数据的6个方法以及优缺点）5. 收集数据2（线上调查问卷的优缺点）6. 交互设计的过程（远程合作系统设计4步骤） 产品评价：7. 十大可用性原则（用于评价设计好坏）8. 对比十大可用性原则与诺曼6原则，写出不同点和相同点（21.8新题）。 把这八道题背熟，然后就可以上考场赌命了，赌中就满分，赌错就不选，正所谓尽人事而知天命。 （P.S. 诺曼6原则书上少一个mapping，建议直接谷歌；12个UI书上不够，建议WIKI；远程合作系统4步骤书上也没有，建议自己写一个，大致是 establishing requirments, desiging alternatives, protoyping, evaluating 四个步骤。新题第8题书上也没有，建议自己总结，我考场上现编的） 2. 数据库首先还是书籍介绍：：IT Text データベースの基礎 | 吉川 正俊 |本 | 通販 | Amazon 这本是社1的吉川老师编写的教材，也是京大学部生所用的教材。 数据库可谓是我准备的最为完美的，最为自信的一门课了。我可以说我把这本书吃透了，不论他怎么考我都没问题可以拿到90/100 。 简单粗暴的总结一下，数据库其实是很有趣的一门课。这门课的课程核心在于教会学生们如何设计一个数据库，并利用这个数据库查询到其想要的data。 所以数据库的学习流程就是设计一个数据库的流程。 需求分析——利用自然语言对需求进行分析概念数据库设计——将自然语言的需求转化为ER模型逻辑数据库设计——将ER模型图转化为关系模型，选择DBMS（查询的部分包含在其中，关系代数、域/元组关系演算、SQL）关系模式规范化——范式，分解法与合成法物理数据库设计——考虑存储、负载与索引，最优化查询，file organization。应用与安全设计——事务、并行控制、错误恢复就这么简单，考点就这些了。只要你把这里的每一步都弄明白，你就可以完成过去问。 这道题的出题风格完全无法总结，所以建议拉满，不管怎么出都可以满分。 复习上来说，建议一轮复习以中文资料为主，二轮复习利用京大课本大纲查漏补缺，比如合成法中国学校的讲义一般不讲。还有一些日本和中国写法不同的地方也应当一一确认，比如ER图多对一情况下箭头的画法，比如范式分解时候的步骤等。 另：关系代数，关系演算以及SQL应当多刷题，中文教材推荐的第二本中的课后题非常优秀，我当初复习的时候是全做了一遍，基本可以达到京大考试要求。 其他的中文资料推荐： 3. 信息检索这门课非常小众，但实际上懂得门路复习起来简单的一，考试不就是背几个概念设计一个无向图/有向图… 田岛老师（我猜测的出题者）：？ 然后 21.8 的考题出了四个图的设计…..在考场上有限时间下大脑一片空白真的设计不出来啊亲！在家设计好几个小时设计出来还觉得题很简单的笑歌是屑。 又差点给我送走。我最后蒙了四个上去，看面试排名感觉蒙的好像还蒙对了？不愧是我。 个人建议：建议复习，不建议只复习。这门课是我准备的三门中最难的，也是最吃数学的，需要一定的概率论基础（BIM/语言模型），图论基础（有向图无向图完全图），线性代数基础（线性空间模型/MVD） 困扰诸多考生最大的困难就是，复习起来真的无从下手。往年的学长们依靠中科院王斌老师的讲义也是无法做到完答的。不过我今年搞到了一份神秘资料，让我最后完成了完答。神秘资料是什么不能说，但我可以把里面的要点讲一讲。 这道题的出题风格基本上已经固定了。三小问，第一问一定是概念题，第二问第三问一定是一道Pagerank/HITS相关，一道复杂网络相关（scale free特性，小世界特性，cluster特性）具体可以见京大本科课程的大纲： 首先是第一道基础题，可以看到可能会考的基础范围很广泛，从HTML XML到kd木 再到信息检索模型、信息检索评价、相关反馈与查询扩展，但实际上，第一章第二章在社情考试改版之后已经再没有考过了，我和上岸佬猜测是因为其他地方考过了，反正我当初没有看第一章第二章的东西。 第三章，信息检索模型，重头戏。常考的信息检索模型有如下几个，一个个全弄明白。一般来说，针对一个信息检索模型，他的四元组要弄明白[D、Q、F、R(qi,dj)]。 D——文档集的表示Q——查询集合的表示F——模型框架R——排序函数除此之外，优缺点，VSM与BIM的相同点不同点，扩展布尔模型对布尔模型/vsm的提升都是常考点。 boolean model, fuzzy set model, extended boolean model, Vector space model(VSM), Binary independence model(BIM), Okapi BM25, Language model, Query likelihood, Latent semantic indexing(LSI). 第四章，信息检索评价。与上面一样，将每个评价标准搞明白就可以了，没什么好说的。 一般来说，信息检索中评价的东西只有三个：Efficiency/Effectiveness/Coverage，所以一个评价尺标的好坏一般是用这三个维度定义的。 precision, recall, F-measure/ Balanced F-measure, precision-recall curve, MAP, R-Precision, Precision@N, nDCG, MRR, ERR, MMR, 顺位相关系数 第五章，相关反馈与查询扩展，其实这个东西我直接放在信息检索模型里面一起复习了，虽然他不是信息检索模型，但目标也是帮助信息检索更加合适。 相关反馈分为显式相关反馈、隐式相关反馈以及伪相关反馈。其中针对VSM的rocchio算法往年也考过。 概念题大概就是上述的东西了，逃不出这个范围。 其次：Pagerank/HITS，两个都是基础算法了，网上有无限多的网页介绍。实在弄不清楚的就去看作者原论文，记得HITS一定要normalization） 最后：复杂网络，这道题国内的复习资料非常少，我只找到有限的几个博客。我大概总结一下神秘资料中的考点。 基础：图论，图的设计，图的类型总结（简单图，基础图，定向图，平凡图…..）随便找本图论的书看一下第一章就可以了。 scale free（无标度）考点：节点的次数（degree），幂律分布，以及往年过去问考过的对于ck^-r的求积分然后分析期望E（k），这个是纯粹的数学推导。 small world（小世界特性） 主要考点：紧密中心性（closeness centrality）、间接中心性（betweenness centrality） cluster（社区结构特性） 主要考点，顶点V的cluster性Ci 复杂网络是考试难点，出设计题时非常难顶，全看能不能想到了。所以不推荐只复习这一道。我在考场上觉得人工智能才是真滴好，后悔没复习人工智能。人工智能的稳定性要比信息检索好太多了。 最后，又到了我们最喜欢的考题预测环节。 我预测22.2信息检索基础题会选择某一个评价尺度拿出来考，因为前几年已经把信息检索模型考个差不多了，今年夏天我预测也成功了，考了MRR和MMR。 我预测22.2复杂网络那道题会考Ci的图形设计，和21.8的题会长得很像，因为往年2月的题都和8月的题是一个考点，只是细节上会稍作改动，因为老师也懒得编新题。。。 Pagerank和HITS无法预测，好好把矩阵的计算方式自己多推几个，祈祷考场上别出太难，这题吃理解。 最后的建议，最好复习四门课/五门课，最稳定的其实是数据库 人工智能和人机交互，信息检索稳定程度不高。算法我是菜鸡，题都看不懂，cs出身的朋友可能问题不大。 英语没什么好说的，TOEIC永远滴神，英语分数换算根据我收集到的数据大概如下，仅供参考： 托福82=115/150 托福90/托业810=133/150 托福95/托业835=141/150 在之前的多个经验贴中，有几位学长说英语成绩差不多就行，我斗胆提出这个观点是不够正确的，对于京大社情来说，一个好的英语成绩可以极大弥补你在笔试阶段的发挥失误。 学长们的笔试成绩很好，所以英语成绩只是锦上添花。而我今年的笔试成绩可以预见性的很糟糕，全靠托业救我于水火之中把我抬上岸了。所以，能刷高就刷高，850就是胜利！ 面试社情的面试是由笔试成绩决定的，面试的排位就是笔试成绩的排名。一般来说上午面试的都能全员录取，就是去哪个志愿的问题了，进入上午面试的可以安心一些。下午面试的人，由于成绩不够有说服力，所以志愿填报和面试的表现就会成为决定录取与否的因素。 社情的面试没有那么多弯弯绕，老师需要在一天时间面试40+个学生，这是很浪费时间的。所以一般流程就是 简短的自我介绍 2-3min做一个关于rp的pre（上面的5min是假的） 老师问1-2个rp的相关问题 第二志愿老师可能会询问，为什么选择我做第二志愿。 一般情况下，当第二志愿老师这么问的时候，就代表他有一定兴趣捞你。这时候你的回答就很重要了。所以建议准备面试的时候也准备一下这个问题。 4 合格分数分析目前手头收集了几套数据，众所周知京大社情的面试排序是笔试成绩的排序，所以可以大概看一下什么分数可以排到什么名次。以下分数为英语+基础+专业课。 141+145+251=537 19.8 排名第五 115+148+268=531 20.2 排名四月生第一 117+140+257=514 20.8 排名第十一 104+140+243=487 20.8 排名第二十 133+118+205=456 21.8 排名第二十五 以上人均合格了。 我猜测题的难度不会对分数线有太大的影响，题难老师会多给分，题简单老师会多扣分，控制分数线不会太大变动。一般来说，500分肯定能上岸了。英语多十分，你专业课/基础课就有多错两道题的余裕。 5 套磁与志愿分析不管第一志愿是社情的哪位老师，说明会都一定要参加，rp都一定要好好写，陶瓷一定要去套。 今年笔试第28落了，一个吉川老师的研究生落了（十月第二名），但一个笔试37名的合格了，这很明显问题出在志愿填报上。 社情有两个最热门的研，吉川研和神田研，当你把这两个研究室作为第一志愿和第二志愿，笔试分数还不够有决定性的情况下，你大概率是落榜。所以一般推荐搭配是吉川/神田第一志愿，其他四个中选择一个作为第二志愿。社情基本没有出现调剂到第三志愿的情况，所以第一志愿和第二志愿是最重要的。功利一点，上岸为王可以直接第一志愿阿部研（密码学），只要分够应该就能进，因为太冷门了。（另，社14的续方研在日本人之中很热门，我建议不要和吉川神田凑凑了，这个真说不好）当然，如果你心有所属，那就大胆的把第一志愿填上TA，完全没有问题。 我的笔试是第25名，很尴尬的名次，最终第一志愿神田研失败，调剂到了第二志愿的伊藤研。我的rp质量不错，面试表现也很好，只能说前面的第一志愿人把坑填满了，自己考的不好也没得说。 6 考试过程7月30日，坐新干线抵达京都，入住京大旁边300m的民宿。和之前京大上岸还有一起备考的朋友一起吃饭。晚上再次刷了一遍基础书。 7月31日上午，提前到达考场并且买好了中午的面包，准备中午就在考场干到底了。BTW，8号馆的空调真的应该修一下，4号馆就凉凉快快一点问题没有。 10:00-12:00 情报学基础，从去年的出题特征就能看出老师们开始有意识的提升情报学基础的难度以获得区分度，但我怎么也没想到他能考出来不在那本书上的题目，猝不及防之下，我怀疑我情报学基础只拿到了125/150。今年的情报学基础出了第一章、第二章、第四章、第五章、第八章。最后我选择了第二章、第四章和第五章，第四章有两个知识点总结了没背会，编了上去，这是我的失误，望后人引以为戒。 12:00-13:00 一边啃面包一遍最后看一遍需要死记硬背的知识点，人机交互的考题我预测21.2刚出的新题21.8一定会再考，然后考前背了三遍，果然考了。 13:00-16:00 专业课，一开始人机交互，一看出了新题，心凉了一半。然后看了一眼算法，发现连题都看不懂，只能硬着头皮回来写人机交互。发现新题可以编一编，就很开心的编上去了。然后开始写数据库，看上去踢不多，但出的又怪，要写的字又多，基本上前两道题我把两张答题卡的正反面都拉满了。然后扫了一眼信息检索，一看基础，ok复习过，一看下面，怎么没有HITS/Pagerank了，吓出一身冷汗，定睛一瞧，还是一个东西，就是没挂这个名字。然后开始哼着小曲设计。 五分钟过去了 十分钟过去了 半小时过去了，我已经慌了，怎么也设计不出来。越慌越不冷静越没办法。最后我把四个图的设计，按照我能理解的方法编上去了。看我的排名，估计还是蒙对了6成。 回家万念俱灰，吃了顿饭，感觉自己进不了面试想直接remake了。 强撑着把面试稿写完了，问了上岸佬和朋友当天的考试题，然后背会了面试稿。 第二天惊喜的发现我在面试名单上。然后进入控室，老师将面试顺序写在黑白上，前24个没我，心又全凉了。结果下午第一个面试者就是我，突然又看到了一丝希望。 13:20面试开始。首先是简短自我介绍，然后是研究计划书介绍，最后是第一志愿老师提了一个rp相关问题，第二志愿老师问我你为什么来我们lab。 我：老师，你们说明会我听了，你的video特别coooooool～ 伊藤老师：？ 我能怎么办，我也没研究过啊，我也很绝望啊。 出面试房间嘴里只能念叨：終わりだ。 和朋友在京都吃了最后一顿饭，坐上了回东京的のぞみ号。 8月6日放榜合格，梅雨季的阴霾一扫而空，一束光芒照了下来，告诉我，你成功了。 7 まとめ在21年的上旬，我在语言学校做了一个简短的speech。 九年前的夏天，一位日本少年与来访日本的C罗有过一次直接对话。当时那个少年用带着浓厚日文口音，蹩脚的葡萄牙语向C罗表明了自己的理想：他想要像C罗一样，在足球上站上最高的舞台。因为糟糕的发音，全场发出了笑声。但C罗很严肃，他不明白为什么其他人要发笑。他向那位少年传达了一句话，那句话的日文翻译我至今还记于脑海当中。 “努力すれば必ず夢を叶う。” 毫无疑问，C罗是世界上最有资格说这句话的人之一。 令和3年的冬天，在曾经举办过世界杯的埼玉２００２足球场，山梨学院高校捧起了第九十九届全国高校足球的冠军。而九年前的那位日本少年，如今已是冠军队伍中的主力队员。 我其实很高兴能够将一些留存于我心中的小小热血分享给大家。 从没有什么梦想是100%能够实现的。我可以接受努力过了，流血过了，最后失败，而不能忍受因为没尽全力，面对困难退缩而懊恼。这也是推动着我在疫情环境尚未明朗的20年11月拖着发抖的双腿也要坐上来日本的飞机的原动力，是我一切的原点。 梦想必尽全力，只求无怨无悔。 我祝福大家，在面对绝境之时也有无可匹敌的勇气；我祝福大家，在迷茫困惑之时也有不惜一切的坚定；我祝福大家，在人生的歧路上也能走到happy end。 鸣谢在此篇经验贴的最后，向修士备考期间提供帮助的诸位致以发自内心的感谢。 排名不分先后 19/20：谭佬、黑白佬、东云佬、雪佬、林佬、Sa佬、 锁哥、saika、米酒佬、阿喵佬、乐乐佬、lucky宝、shzhzzz佬、远古的号角佬等。 21：KO宝、MO宝、邱宝、mike佬、亮宝、叶佬、wydx佬、羊驼佬、leno佬、blue佬、折佬、好人佬、夏宝、意呆、蝉佬、路佬、阿椰、aisk、ksia等。 22: 祝愿✌️宝早日上岸 衷心祝福19/20年的诸位就职/博士一切顺利，衷心期望21的各位都能拿到理想校的offer 附录附录部分为所有其他有用经验贴/网站链接，建议一个一个点来看一下。希望我的网页因此成为hub分数超高的网页！ 经验贴部分： 170210：京都大学社会情报专攻，东京工业大学情报通信专攻夏季入试修考经验分享 远古的号角：京都大学大学院社会情报学专攻冬季入试验修考经验分享 shzhzzz：京都大学大学院情報学研究科社会情报学专攻修考经验分享 CTan：京都大学社会情报学大学院夏季入试经验分享 院試の振り返り - けものみち 京大大学院情報学研究科社会情報学専攻に合格するまでにしたこと - chumonのブログ 文系でしたが情報系の大学院に進学します - anytime sleeping 京都大学大学院情報学研究科の入試情報まとめ（自分用） - ひらめの日常","categories":[],"tags":[{"name":"KyotoU","slug":"KyotoU","permalink":"http://example.com/tags/KyotoU/"}]}],"categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://example.com/tags/Programming/"},{"name":"Project-Web","slug":"Project-Web","permalink":"http://example.com/tags/Project-Web/"},{"name":"Project-Go","slug":"Project-Go","permalink":"http://example.com/tags/Project-Go/"},{"name":"Shell","slug":"Shell","permalink":"http://example.com/tags/Shell/"},{"name":"Tools","slug":"Tools","permalink":"http://example.com/tags/Tools/"},{"name":"Web_Developer","slug":"Web-Developer","permalink":"http://example.com/tags/Web-Developer/"},{"name":"AWS-SAAC02","slug":"AWS-SAAC02","permalink":"http://example.com/tags/AWS-SAAC02/"},{"name":"KyotoU","slug":"KyotoU","permalink":"http://example.com/tags/KyotoU/"}]}