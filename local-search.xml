<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git for PyCharm</title>
    <link href="/2022/04/18/Git-for-PyCharm/"/>
    <url>/2022/04/18/Git-for-PyCharm/</url>
    
    <content type="html"><![CDATA[<p>在利用<code>Python</code>进行日常开发中，经常会使用<code>Git</code>来管理项目，IDE使用<code>PyCharm</code>，<code>PyCharm</code>中的<code>Git</code>操作可以节约我们用shell打代码的时间。</p><p>IDE: PyCharm</p><p>OS: MacOS</p><h2 id="拉取仓库"><a href="#拉取仓库" class="headerlink" title="拉取仓库"></a>拉取仓库</h2><p>利用PyCharm使用<code>Git clone</code>的方法：</p><p>直接选择左上角<code>Git</code>，然后克隆，输入克隆地址即可。</p><h2 id="Git-commit"><a href="#Git-commit" class="headerlink" title="Git commit"></a>Git commit</h2><p>修改好文件之后需要<code>commit</code>操作。</p><p>打开<code>commit</code>窗口</p><h3 id="添加到-gitignore"><a href="#添加到-gitignore" class="headerlink" title="添加到.gitignore"></a>添加到.gitignore</h3><p>选中需要添加到<code>.gitignore</code>的文件，鼠标右键选择<code>add to .gitignore</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy &amp; Matplotlib for Python</title>
    <link href="/2022/04/17/Numpy-Matplotlib-for-Python/"/>
    <url>/2022/04/17/Numpy-Matplotlib-for-Python/</url>
    
    <content type="html"><![CDATA[<h2 id="NumPy-amp-Matplotlib-for-Python"><a href="#NumPy-amp-Matplotlib-for-Python" class="headerlink" title="NumPy &amp; Matplotlib for Python"></a>NumPy &amp; Matplotlib for Python</h2><p>写在前面：</p><p>本篇文章为个人学习总结所用。</p><p>使用环境：Anaconda + Python3.7 + Jupyter notebook + Tensorflow</p><p><strong>NumPy 与 Matplotlib一同创造了一个MATLAB的完全替代品。配合Jupiter-notebook一同使用可以在数据处理上达到令人满意的效果。</strong></p><h3 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h3><p>NumPy最重要的一个特点是其N维数组对象ndarray，是一系列同类型数据的集合。</p><p>创建一个ndarray只需要调用NumPy的array函数即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 一维数组</span><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span> (a)<br><span class="hljs-comment"># 输出结果：[1 2 3]</span><br><br><span class="hljs-comment"># 多于一个维度</span><br>a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])<br><span class="hljs-comment"># 输出结果：[[1 2]</span><br><span class="hljs-comment">#           [3 4]]</span><br><br><span class="hljs-comment"># 最小维度</span><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], ndmin = <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> (a)<br><span class="hljs-comment"># 输出结果：[[1 2 3 4 5]]（这是一个二维数组，但是第二行没有赋值）</span><br><br><span class="hljs-comment"># dtype参数</span><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype = <span class="hljs-built_in">complex</span>)<br><span class="hljs-built_in">print</span> (a)<br><span class="hljs-comment"># 输出结果：[1.+0.j 2.+0.j 3.+0.j]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>Matplotlib 是 Python 的绘图库。通常和NumPy共同进行使用。</p><p>Pyplot是Matplotlib的子库，提供了和Matlab类似的绘图API</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># plot()方法绘制二维图形</span><br>xpoints = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">6</span>])<br>ypoints = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">100</span>])<br><br>plt.plot(xpoints, ypoints)<br>plt.show()<br><span class="hljs-comment"># 得到一个(0,0) 到 (6,100) 的直线</span><br></code></pre></td></tr></tbody></table></figure><p>plot函数可以绘制点和线，语法格式如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画单条线</span><br>plt.plot([x], y, [fmt], *, data=<span class="hljs-literal">None</span>, **kwargs)<br><span class="hljs-comment"># 画多条线</span><br>plt.plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)<br></code></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li>x, y：点或线的节点。x为x轴数据，y为y轴数据，数据可以列表或数组。</li><li>fmt：可选，定义基本格式（颜色，标记和线条样式）</li><li>**kwargs：可选，用在二维平面图上，设置指定属性，如标签和线的宽度。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>plot(x, y)        <span class="hljs-comment"># 创建 y 中数据与 x 中对应值的二维线图，使用默认样式</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>plot(x, y, <span class="hljs-string">'bo'</span>)  <span class="hljs-comment"># 创建 y 中数据与 x 中对应值的二维线图，使用蓝色实心圈绘制</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>plot(y)           <span class="hljs-comment"># x 的值为 0..N-1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>plot(y, <span class="hljs-string">'r+'</span>)     <span class="hljs-comment"># 使用红色 + 号</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda for Mac</title>
    <link href="/2022/04/16/Anaconda-for-Mac/"/>
    <url>/2022/04/16/Anaconda-for-Mac/</url>
    
    <content type="html"><![CDATA[<h2 id="Anaconda-使用教程"><a href="#Anaconda-使用教程" class="headerlink" title="Anaconda 使用教程"></a>Anaconda 使用教程</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">查看anaconda的版本</span><br>conda -V<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">查看已安装的envs</span><br>conda info -e<br></code></pre></td></tr></tbody></table></figure><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">1. 创建一个环境，指定python版本</span><br>conda create --prefix=./machinelearning python=3.9<br><span class="hljs-meta"># </span><span class="language-bash">或者</span><br>conda create --name machinelearning python=3.9<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">2. 启动该环境</span><br>conda activate machinelearning<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">3. 验证环境是否被选中</span><br>conda info --envs<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">4. 验证python版本</span><br>python --version<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">5. 禁用环境</span><br>conda deactive<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">6. 删除虚拟环境</span><br>conda env remove -n ENV_NAME<br></code></pre></td></tr></tbody></table></figure><h3 id="管理Python包"><a href="#管理Python包" class="headerlink" title="管理Python包"></a>管理Python包</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">查看当前环境下的包</span><br>conda list<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">包查询</span><br>conda search 'setup' # 替换为自己的包名<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">安装一个包</span><br>conda install [package1]<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">安装多个安装包</span><br>conda install [package1] [package2]<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">删除包</span><br>conda remove [package1]<br><span class="hljs-meta"></span><br><span class="hljs-meta"># </span><span class="language-bash">升级安装包</span><br>conda upgrade [package1]<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法详解</title>
    <link href="/2022/04/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/04/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="回溯问题概述"><a href="#回溯问题概述" class="headerlink" title="回溯问题概述"></a>回溯问题概述</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>注2: dfs与回溯之间并不是并列的关系，dfs是一种深度优先的遍历方法，而回溯是一种解决问题的手段。dfs可以有回溯，回溯也可以用dfs。</p><h4 id="什么是回溯算法？"><a href="#什么是回溯算法？" class="headerlink" title="什么是回溯算法？"></a>什么是回溯算法？</h4><p>回溯法也可以叫做回溯搜索法，是一种搜索的方式。回溯是递归的副产品，有递归就会有回溯。</p><h4 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="回溯法的效率"></a>回溯法的效率</h4><p>回溯法的性能如何呢？实际上不是什么高效的算法。因为本质是穷举。如果想要回溯法高效，可以增加一些剪枝的操作。但效率仍然一般，因为其本质就是穷举。</p><h4 id="回溯法适合解决的问题"><a href="#回溯法适合解决的问题" class="headerlink" title="回溯法适合解决的问题"></a>回溯法适合解决的问题</h4><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等</li></ul><p>注：组合和排列的区别是组合不强调元素顺序，排列强调元素顺序。</p><h4 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h4><p>回溯法解决的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度则构成了树的深度。</p><p>使用递归就要有中止条件，所以树的高度是有限的。</p><p>解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考三个问题。</p><ol><li>路径：也就是已经作出的选择。</li><li>选择列表：也就是你当前可以做的选择。</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java">result = []<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(路径，选择列表)</span>:<br>  <span class="hljs-keyword">if</span> (满足结束条件){<br>    result.add(路径);<br>    <span class="hljs-keyword">return</span>;<br>  }<br>  <span class="hljs-keyword">for</span> (选择 : 选择列表) {<br>     做选择 or 处理节点;<br>     backtrack(路径，选择列表); <span class="hljs-comment">// 递归</span><br>     回溯，撤销选择;<br>  }<br></code></pre></td></tr></tbody></table></figure><p>核心就是for循环里的递归，在递归调用之前做选择，在递归调用之后撤销选择。</p><p>可以看出for循环就是横向的遍历，backtracking就是纵向遍历，这样就把这棵树全遍历完了。</p><p>这个框架的奥秘在哪里呢？我们来看两道例题：</p><h3 id="1-全排列问题"><a href="#1-全排列问题" class="headerlink" title="1. 全排列问题"></a>1. 全排列问题</h3><p>高中的排列组合数学题。对于n个不同的数，全排列共有n!个。</p><p>穷举全排列的方法？[1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1]…..</p><p>可以按照这个逻辑画出一颗决策树。</p><p>只要从root遍历这棵树，记录路径上的数字，其实就是所有的全排列。</p><p>假如我们进行穷举走到了[2, x, y]的分叉，这时候2的含义就是[路径]，用于记录你已经做过的选择；</p><p>而[1]或[3]则是[选择列表]。表示你当前可以做出的选择；</p><p>[结束条件]就是遍历到树的底层，在这里就是选择列表为空的时候。</p><p>这时候可以看出，我们所定义的backtrack函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其[路径]就是一个全排列。</p><p>那么，如何遍历这棵树？</p><p>简单的二叉树遍历罢了，前序遍历 or 后序遍历。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>{<br>  <span class="hljs-keyword">for</span> (TreeNode child : root.children)<br>  <span class="hljs-comment">//前序遍历需要的操作</span><br>    <span class="hljs-built_in">traverse</span>(child);<br>  <span class="hljs-comment">//后序遍历需要的操作</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>稍微回忆一下，前序遍历的代码会在进入某一个节点之前的时间执行，而后序遍历代码会在离开某个节点之后的那个时间点执行。</p><p>而就在刚才我们所述，[路径]和[选择]是每个节点的属性，函数在树上游走要正确维护节点的属性。所以我们应当在前序和后序两个位置选择不同的操作。</p><p>前序为做出选择，而后序为撤销选择。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>  <span class="hljs-comment">#做选择</span><br>  将该选择从选择列表移除<br>  路径.add(选择) <br>  backtrack(路径，选择列表)<br>  <span class="hljs-comment">#撤销选择</span><br>  路径.remove(选择)<br>  将该选择再加入选择列表<br></code></pre></td></tr></tbody></table></figure><p>我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确的得到每个节点的选择列表与路径。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-comment">// 主函数，输入一组不重复的数字，返回他们的全排列</span><br>List&lt;List&lt;Integer&gt;&gt; <span class="hljs-built_in">permute</span>(<span class="hljs-type">int</span>[] nums) {<br>  <span class="hljs-comment">// 记录路径</span><br>  LinkedList&lt;integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-built_in">backtrack</span>(nums, track);<br>  <span class="hljs-keyword">return</span> res;<br>}<br><br><span class="hljs-comment">// 路径：记录在 track 中</span><br><span class="hljs-comment">// 选择列表：nums 中不存在于 track 的那些元素</span><br><span class="hljs-comment">// 结束条件: nums 中的元素全都在track 中出现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>{<br>  <span class="hljs-comment">// 触发结束条件</span><br>  <span class="hljs-keyword">if</span> (track.<span class="hljs-built_in">size</span>() == nums.length) {<br>    res.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedList</span>(track));<br>    <span class="hljs-keyword">return</span>;<br>  }<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; nums.length; i++) {<br>    <span class="hljs-comment">// 排除不合法的选择</span><br>    <span class="hljs-keyword">if</span> (track.<span class="hljs-built_in">contains</span>(nums[i]))<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-comment">// 做选择</span><br>    track.<span class="hljs-built_in">add</span>(nums[i]);<br>    <span class="hljs-comment">// 进入下一层决策树</span><br>    <span class="hljs-built_in">backtrack</span>(nums, track);<br>    <span class="hljs-comment">// 取消选择</span><br>    track.<span class="hljs-built_in">removeLast</span>();<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>自此，我们就通过全排列问题了解了简单的回溯算法。当然，这个算法解决全排列并不高效，<code>contains</code>方法需要O(N)的时间复杂度。有更好的方法可以follow up</p><p>但不论怎样优化，只要符合回溯框架，时间复杂度都不可能低于O(N!)，因为穷举整棵树是无法避免的。一般回溯算法时间复杂度都很高。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Depth First Search 深度优先搜索</title>
    <link href="/2022/04/07/Depth-First-Search-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/04/07/Depth-First-Search-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>注：本文仅为个人学习笔记，无任何版权。</p><p>深度优先算法（DFS, Depth first search），是搜索算法的一种。</p><p>基本思想：沿着树的深度来遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都已被探寻过，搜索讲回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个过程反复进行直到所有节点都被访问为止。</p><p>深度优先算法也可以解决很多经典的图论问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scanner &amp; BufferedReader 用法详解</title>
    <link href="/2022/04/06/Scanner-BufferReader-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/04/06/Scanner-BufferReader-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Scanner-amp-BufferedReader用法详解"><a href="#Scanner-amp-BufferedReader用法详解" class="headerlink" title="Scanner &amp; BufferedReader用法详解"></a>Scanner &amp; BufferedReader用法详解</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>这段时间一直没把java的输入写明白，在该记事里进行一个总结</p><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><p>Scanner使用分隔符模式将其输入分解为标记，默认情况下是利用空白进行分割的。之后可以使用不同的<code>next</code>方法将得到的标记转换为不同类型的值。</p><p>Scanner位于<code>java.util</code>包中，Scanner的具体用法为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">//通过new创建一个Scanner对象</span><br><span class="hljs-comment">//传入一个System.in参数来读取输入</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//输入一个Integer</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextInt(); <br><span class="hljs-comment">//读取一整行字符串（以Enter结尾进行分界）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextLine();<br><span class="hljs-comment">//读取一组字符串（以空格/Tab/Enter进行分界，只要遇到其中之一就返回下一个 //输入）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.next();<br></code></pre></td></tr></tbody></table></figure><h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>BufferedReader位于<code>java.io</code>包中，读取数据比较固定，这样格式也比较单一。只要记住就这一读取数据的方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><br><span class="hljs-comment">//BufferedReader的readLine()方法必须处理java.o.IOException异常，所以需要在Public static void main后面补充处理。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {<br>  <span class="hljs-comment">//创建BufferReader对象，从键盘读入</span><br>  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>  <span class="hljs-comment">//创建BufferReader对象，从文本文件读入</span><br>  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">"test.txt"</span>));<br><br>  <span class="hljs-comment">//读取一行数据并用空格分隔，存入字符串数组</span><br>  String[] temp = br1.readLine().split(<span class="hljs-string">""</span>);<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>BufferedReader readLine()方法可能抛出异常，比如要读的文件不存在的话就会抛异常。会抛异常的方法要么在调用的时候用try catch包围，在调用它的时候就写好处理异常的代码，要么就在当前的函数后面加throw声明可能出现的异常，交给调用当前函数的函数处理异常。</p><p>BufferedReader读取的数据都以字符串的形式存储，如果需要其他形式的数据，需要进行强制转换。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/04/04/%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/04/04/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表题型刷题总结"><a href="#链表题型刷题总结" class="headerlink" title="链表题型刷题总结"></a>链表题型刷题总结</h1><p>注：本文仅为个人学习笔记，无任何版权。</p><h3 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h3><p>一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null</p><p>链表的头节点为head</p><h4 id="链表的类型："><a href="#链表的类型：" class="headerlink" title="链表的类型："></a>链表的类型：</h4><ol><li>单链表</li><li>双链表</li><li>循环链表</li></ol><h4 id="链表在内存中的储存方式"><a href="#链表在内存中的储存方式" class="headerlink" title="链表在内存中的储存方式"></a>链表在内存中的储存方式</h4><p>与数组不同，链表在内存中<strong>不是连续分布。</strong></p><p>链表是通过指针域的指针链接在内存的各个节点，所以链表中的节点在内存中不是连续分布的，而是三楼缘分不在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><h4 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-comment">// 结点的值</span><br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-comment">// 下一个结点</span><br>    ListNode next;<br><br>    <span class="hljs-comment">// 节点的构造函数(无参)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> {<br>    }<br><br>    <span class="hljs-comment">// 节点的构造函数(有一个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> {<br>        <span class="hljs-built_in">this</span>.val = val;<br>    }<br><br>    <span class="hljs-comment">// 节点的构造函数(有两个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> {<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    }<br>}<br><br>List&lt;&gt; xxx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></tbody></table></figure><h4 id="删除节点："><a href="#删除节点：" class="headerlink" title="删除节点："></a>删除节点：</h4><p>只要将被删除节点的前一个节点的指针，指向后一个节点就可以了。如果要删除第n个节点，可以将第n-1个节点的指针指到第n+1个节点，java会自动释放那块内存。</p><h4 id="添加节点："><a href="#添加节点：" class="headerlink" title="添加节点："></a>添加节点：</h4><p>同理，修改指针即可。</p><p>可以看出链表的增添/删除都是O(1)的操作，不会影响到其他节点。但是，如果要删除第c个节点，需要从头节点找到第c-1个节点，查找的时间复杂度为O(c)</p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>链表删除/插入：O(1)</p><p>链表查找：          O(n)</p><p>数组删除/插入：O(n)</p><p>数组查找：          O(1)</p><p>数组：数据量固定，频繁查找，较少增删</p><p>链表：数据量不固定，频繁增删，较少查找</p><h3 id="链表的经典题目"><a href="#链表的经典题目" class="headerlink" title="链表的经典题目"></a>链表的经典题目</h3><h4 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h4><p>链表操作的一大问题就是当前节点必须要找前一个节点才能操作，在这种情况下，用一个虚拟头节点可以解决这个问题。</p><p>203</p><h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><p>一道题写一个链表ListNode的class出来，非常好的题目 </p><p>707</p><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>高频题目，递归和迭代都可以解决，建议一定熟练掌握本质。</p><p>206</p><h4 id="删除倒数第N个节点"><a href="#删除倒数第N个节点" class="headerlink" title="删除倒数第N个节点"></a>删除倒数第N个节点</h4><p>虚拟头节点 + 双指针，第一个指针走n 然后第二个指针跟第一个指针一起出发。</p><p>19</p><h4 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h4><p>很trick的方法。虽然两个链表到达相交点的距离可能不一样，但我们可以加两个链表加起来。一个指针从A遍历到B，一个指针从B遍历到A。这样他们就可以同时到达交点了！</p><p>面试题 02.07</p><h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><p>难点在数学证明，方法是快慢指针。很有趣的题目。</p><p>142</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2022/04/02/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/04/02/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="数组题型刷题总结"><a href="#数组题型刷题总结" class="headerlink" title="数组题型刷题总结"></a>数组题型刷题总结</h1><p>注：本文仅为个人学习笔记，无任何版权。</p><p>数组：存放在连续空间的相同类型元素的集合，一般不进行删除操作。</p><p>两点注意；</p><ol><li>数组下标都是从0开始</li><li>数组内存空间地址连续（增添删除都很麻烦）</li></ol><p>二维数组在系统中的存储方式</p><p>m*n的二维数组来说，一般由一个头节点指向一个长为n的一维列数组，每个列数组又作为另一个长为m的一维行数组的头节点。</p><p>并不是连续地址空间</p><p>一般看到链表/子串/数组之类的题，直接上双指针就行</p><p>常用方法：</p><ol><li>二分法</li><li>双指针</li><li>滑动窗口</li><li>模拟行为</li></ol><h3 id="1-二分法"><a href="#1-二分法" class="headerlink" title="1. 二分法"></a>1. 二分法</h3><p>704, 35, 34, 69, 367</p><p>限制条件：<strong>有序数组</strong>  且 <strong>无重复元素</strong></p><p>Key：边界条件的设定。在二分查找过程中，每次区间变化都遵守边界条件不变。</p><p>常用区间：[lo, hi],  [lo, hi)</p><p>注：乘法溢出时用除法处理即可。</p><p>暴力解法一般时间复杂度为O(N)</p><p>二分法一般时间复杂度为O(logN)</p><h3 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2. 双指针"></a>2. 双指针</h3><p>27, 26, 283, 844, 977</p><p>双指针技巧可以分为两类：【快慢指针】和【左右指针】。前者解决链表中的问题，比如判断链表是否包含环；后者主要解决数组（字符串）中的问题，二分查找也是左右指针的一种特殊情况。</p><p>常见的双指针问题还有移除元素/移除字符串等。</p><p>快慢指针常见问题：链表操作/找中点/归并排序/链表环</p><p>左右指针常见问题：反转数组/二分搜索</p><p>暴力解法时间复杂度一般为O(N^2)</p><p>双指针法时间复杂度一般为O(N)</p><h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h3><p>209, 904, 76</p><p>实际上滑动窗口也是一种特殊的双指针。不过因为其在<strong>子串</strong>问题中的优异表现，我将其单独作为一个部分来讲。</p><p>滑动窗口算法的大致逻辑如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; s.size()) {<br>  <span class="hljs-comment">//增大窗口</span><br>  window.add(s[right]);<br>  right++;<br>  <br>  <span class="hljs-keyword">while</span> (window needs shrink) {<br>    <span class="hljs-comment">//缩小窗口</span><br>    window.remove(s[left]);<br>    left++;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度O(N)， 比一般的字符串暴力算法高效的多。</p><p>滑动窗口的关键在于各种细节问题。比如如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即使你明白了这些细节，也容易报错。</p><p>使用一套来自labuladong 的滑动窗口代码框架。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>Map&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//需要的字符传入need</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) {<br>  need. put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>}<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (right &lt; s.length()) {<br>  <span class="hljs-comment">//c是移入窗口的字符</span><br>  <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>  <span class="hljs-comment">//右边界右移</span><br>  right++;<br>  <br>  <span class="hljs-comment">//进入窗口的一系列操作.....</span><br>  <br>  <span class="hljs-comment">//当满足时，进行窗口缩减</span><br>  <span class="hljs-keyword">while</span> (window needs shrink) {<br>    <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left);<br>    <span class="hljs-comment">//左边界右移</span><br>    left++;<br>    <br>    <span class="hljs-comment">//出窗口</span><br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-模拟行为"><a href="#4-模拟行为" class="headerlink" title="4. 模拟行为"></a>4. 模拟行为</h3><p>48， 54， 59</p><p>不涉及太多算法，单纯模拟，考验对代码的掌控能力。</p><p>循环不变量原则十分重要。</p><p>真正解决题目的代码都是简洁的，有原则性的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OnJava8-File</title>
    <link href="/2022/03/31/OnJava8-File/"/>
    <url>/2022/03/31/OnJava8-File/</url>
    
    <content type="html"><![CDATA[<h2 id="The-Way-to-Input-x2F-Output-File-by-Java"><a href="#The-Way-to-Input-x2F-Output-File-by-Java" class="headerlink" title="The Way to Input/Output File by Java"></a>The Way to Input/Output File by Java</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>打开并读取文件对于大多数编程语言来说是非常实用的。Java8与java7新增的<code>java.nio.file</code>包以及streams与文件结合使得文件操作编程变得十分简单。</p><p>对于文件操作来说，最基本的两个组件是</p><ol><li>文件或者目录的路径；</li><li>文件本身。</li></ol><h3 id="文件和目录路径"><a href="#文件和目录路径" class="headerlink" title="文件和目录路径"></a>文件和目录路径</h3><p>一个<code>Path</code>对象表示一个文件或者目录的路径，可以跨操作系统和文件系统。</p><p><code>java.nio.file.Path</code>包含一个重载方法<code>static get()</code>，该方法接受一系列<code>String</code>字符串或一个URI作为参数，进行转换返回一个<code>Path</code>对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// files/PathInfo.java</span><br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PathInfo</span> {<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String id, Object p)</span> {<br>        System.out.println(id + <span class="hljs-string">": "</span> + p);<br>    }<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(Path p)</span> {<br>        show(<span class="hljs-string">"toString"</span>, p);<br>        show(<span class="hljs-string">"Exists"</span>, Files.exists(p));<br>        show(<span class="hljs-string">"RegularFile"</span>, Files.isRegularFile(p));<br>        show(<span class="hljs-string">"Directory"</span>, Files.isDirectory(p));<br>        show(<span class="hljs-string">"Absolute"</span>, p.isAbsolute());<br>        show(<span class="hljs-string">"FileName"</span>, p.getFileName());<br>        show(<span class="hljs-string">"Parent"</span>, p.getParent());<br>        show(<span class="hljs-string">"Root"</span>, p.getRoot());<br>        System.out.println(<span class="hljs-string">"******************"</span>);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        System.out.println(System.getProperty(<span class="hljs-string">"os.name"</span>));<br>        info(Paths.get(<span class="hljs-string">"C:"</span>, <span class="hljs-string">"path"</span>, <span class="hljs-string">"to"</span>, <span class="hljs-string">"nowhere"</span>, <span class="hljs-string">"NoFile.txt"</span>));<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"PathInfo.java"</span>);<br>        info(p);<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">ap</span> <span class="hljs-operator">=</span> p.toAbsolutePath();<br>        info(ap);<br>        info(ap.getParent());<br>        <span class="hljs-keyword">try</span> {<br>            info(p.toRealPath());<br>        } <span class="hljs-keyword">catch</span>(IOException e) {<br>           System.out.println(e);<br>        }<br>        <span class="hljs-type">URI</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> p.toUri();<br>        System.out.println(<span class="hljs-string">"URI: "</span> + u);<br>        <span class="hljs-type">Path</span> <span class="hljs-variable">puri</span> <span class="hljs-operator">=</span> Paths.get(u);<br>        System.out.println(Files.exists(puri));<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ap.toFile(); <span class="hljs-comment">// Don't be fooled</span><br>    }<br>}<br><br><span class="hljs-comment">/* 输出:</span><br><span class="hljs-comment">Windows 10</span><br><span class="hljs-comment">toString: C:\path\to\nowhere\NoFile.txt</span><br><span class="hljs-comment">Exists: false</span><br><span class="hljs-comment">RegularFile: false</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: NoFile.txt</span><br><span class="hljs-comment">Parent: C:\path\to\nowhere</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: false</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: null</span><br><span class="hljs-comment">Root: null</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files\PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: false</span><br><span class="hljs-comment">Directory: true</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: files</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">toString: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files\PathInfo.java</span><br><span class="hljs-comment">Exists: true</span><br><span class="hljs-comment">RegularFile: true</span><br><span class="hljs-comment">Directory: false</span><br><span class="hljs-comment">Absolute: true</span><br><span class="hljs-comment">FileName: PathInfo.java</span><br><span class="hljs-comment">Parent: C:\Users\Bruce\Documents\GitHub\onjava\</span><br><span class="hljs-comment">ExtractedExamples\files</span><br><span class="hljs-comment">Root: C:\</span><br><span class="hljs-comment">******************</span><br><span class="hljs-comment">URI: file:///C:/Users/Bruce/Documents/GitHub/onjava/</span><br><span class="hljs-comment">ExtractedExamples/files/PathInfo.java</span><br><span class="hljs-comment">true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP, UDP and Socket</title>
    <link href="/2022/03/26/TCP-IP-UDP-and-Socket/"/>
    <url>/2022/03/26/TCP-IP-UDP-and-Socket/</url>
    
    <content type="html"><![CDATA[<p>注：本文仅为个人学习笔记，无任何版权。</p><p>本篇旨在解决如下三个问题：</p><ol><li>什么是TCP/IP、UDP？</li><li>Socket是什么？</li><li>如何使用上述的服务？</li></ol><p>让我们开始吧！</p><h2 id="1-什么是TCP-x2F-IP、UDP？"><a href="#1-什么是TCP-x2F-IP、UDP？" class="headerlink" title="1. 什么是TCP/IP、UDP？"></a>1. 什么是TCP/IP、UDP？</h2><p>TCP/IP（Transmission Control Protocol/ Internet Protocol）即传输控制协议/网间协议。是一个工业标准的protocol集，他是为广域网（WANs）设计的。</p><p>UDP（User Data Protocal，用户数据报协议）是与TCP相对应的协议。他是属于TCP/IP协议集中的一种。</p><p>![截屏2022-03-26 11.04.16](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.04.16.png)</p><p>TCP/IP协议族包括运输层、网络层、链路层。TCP与UDP都是运用在运输层上的协议。</p><h2 id="2-Socket是什么？"><a href="#2-Socket是什么？" class="headerlink" title="2. Socket是什么？"></a>2. Socket是什么？</h2><p>在上图中，我们并未看到Socket的影子。</p><p>Socket究竟在网络服务中扮演了怎样的角色呢？</p><p>实际上Socket的位置应该在应用层与运输层之间。起到了一个将应用层传输给运输层的信息进行抽象的作用。</p><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，他是一组接口。在设计模式中，Socket其实就是一个门面模式，他可以将复杂的TCP/IP协议族隐藏在后面，提供给用户一个简单的接口信息。用户只需要让Socket去组织数据，以符合制定的协议。</p><h2 id="3-如何使用上述的服务？"><a href="#3-如何使用上述的服务？" class="headerlink" title="3. 如何使用上述的服务？"></a>3. 如何使用上述的服务？</h2><h4 id="截屏2022-03-26-11-09-35-TCP-IP-UDP-and-Socket-x2F-截屏2022-03-26-11-09-35-png"><a href="#截屏2022-03-26-11-09-35-TCP-IP-UDP-and-Socket-x2F-截屏2022-03-26-11-09-35-png" class="headerlink" title="![截屏2022-03-26 11.09.35](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.09.35.png)"></a>![截屏2022-03-26 11.09.35](TCP-IP-UDP-and-Socket/截屏2022-03-26 11.09.35.png)</h4><p>先从服务器端讲起。服务器端先初始化Socket，然后与端口绑定（bind），对端口进行监听（Listen），调用Accept阻塞，等待客户端链接。在这时候如果有客户端初始化了一个Socket，然后连接服务器（connect），如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接受请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><p><a href="https://blog.csdn.net/pashanhu6402/article/details/96428887">原文连接</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gototp: A TOTP Library Written by Go</title>
    <link href="/2022/03/16/gototp-A-TOTP-Library-Written-by-Go/"/>
    <url>/2022/03/16/gototp-A-TOTP-Library-Written-by-Go/</url>
    
    <content type="html"><![CDATA[<h1 id="gototp"><a href="#gototp" class="headerlink" title="gototp"></a>gototp</h1><p>A TOTP(Time Based One-Time Password, RFC6328) Library Written by Golang. </p><p><a href="https://xiaogeamadeus.github.io/2022/03/11/RFC6328-Time-Based-One-Time-Password/">The way to create this library</a></p><p><a href="https://github.com/xiaogeamadeus/gototp">Github of totp</a></p><p><a href="https://datatracker.ietf.org/doc/html/rfc6328">RFC6328</a></p><h2 id="How-to-Get-the-Library"><a href="#How-to-Get-the-Library" class="headerlink" title="How to Get the Library"></a>How to Get the Library</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/xiaogeamadeus/gototp<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gogee-Day3-Trie木ルータ</title>
    <link href="/2022/03/14/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/"/>
    <url>/2022/03/14/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/</url>
    
    <content type="html"><![CDATA[<p>注：本文仅为个人学习笔记，无任何版权。</p><p>本篇主要内容：1. 使用Trie树实现动态路由(dynamic route)解析。</p><p>支持两种模式<code>:name</code>和<code>*filepath*</code></p><h2 id="Trie-Tree-Router"><a href="#Trie-Tree-Router" class="headerlink" title="Trie Tree Router"></a>Trie Tree Router</h2><p>之前，我们用了一个非常简单的map结构储存了路由表(router map)，使用map存储键值对，索引非常高效，但是有一个弊端，键值对存储的方式只适用于静态路由.</p><p>如果我们想要支持<code>/hello/:name</code>这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类而非某一条固定的路由。比如<code>/hello/:name</code>，可以匹配<code>/hello/xiaogeamadeus</code>、<code>hello/tom</code>等。</p><p>动态路由有很多种实现方式，支持的规则、性能等有很大的差异。例如开源的路由实现<code>gorouter</code>支持在路由规则中嵌入正则表达式，例如<code>/p/[0-9A-Za-z]+</code>，即路径中的参数仅匹配数字和字母；另一个开源实现<code>httprouter</code>就不支持正则表达式。<code>gin</code>在早期的版本，并没有实现自己的路由，而是直接使用了httprouter，后来放弃了，自己实现了一个版本。<img src="/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/IMG_573DEF5931EE-1.jpeg" alt="IMG_573DEF5931EE-1"></p><p>实现动态路由最常用的数据结构，被称为前缀树(Trie Tree)：每一个节点的所有子节点都拥有相同的前缀。这种结构非常适用于路由匹配。例如，我们定义了如下路由规则：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/:lang/</span>doc<br><span class="hljs-regexp">/:lang/</span>tutorial<br><span class="hljs-regexp">/:lang/i</span>ntro<br>/about<br><span class="hljs-regexp">/p/</span>blog<br><span class="hljs-regexp">/p/</span>related<br></code></pre></td></tr></tbody></table></figure><p>我们用前缀树来表示的话就会变成三颗子树/:lang、/about、/p</p><p>HTTP请求的路径恰好是由<code>/</code>分隔的多段构成的，因此，每一段可以作为前缀树的一个节点。我们通过树结构查询，如果中间某一层的节点都不满足条件，那么就说明没有匹配到的路由，查询结束。</p><p>我们接下来实现的路由具有如下两个功能。</p><ol><li>参数匹配：<code>/p/:lang/doc</code>可以匹配<code>/p/c/doc</code>或者<code>/p/go/doc</code></li><li>通配符<code>*</code>。例如<code>/static/*filepath</code>，可以匹配<code>/static/fav.ico</code>，也可以匹配<code>/static/js/jQuery.js</code>，这种模式常用于静态服务器，能够递归的匹配子路径。</li></ol><h2 id="Trie木の実現"><a href="#Trie木の実現" class="headerlink" title="Trie木の実現"></a>Trie木の実現</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ttype node <span class="hljs-keyword">struct</span> {<br>  pattern <span class="hljs-type">string</span> <span class="hljs-comment">//带匹配路由，例如/p/:lang</span><br>  part <span class="hljs-type">string</span> <span class="hljs-comment">//路由中的一部分，例如:lang</span><br>  children []*node <span class="hljs-comment">//子节点，例如[doc, tutorial,intro]</span><br>  isWild <span class="hljs-type">bool</span> <span class="hljs-comment">//是否精确匹配，part含有:或*时为true</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>与普通的树不同，为了实现动态路由匹配，加上了<code>isWild</code>这个参数。即当我们匹配到<code>/p/go/doc</code>这个路由时，第一层节点，<code>p</code>精准的匹配到了<code>p</code>，第二层节点，<code>go</code>模糊匹配到<code>:lang</code>，那么将会把<code>lang</code>这个参数赋值为<code>go</code>，继续下一层匹配。我们将匹配的逻辑包装为一个辅助函数。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//第一个匹配成功的节点，用于插入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span>matchChild(part <span class="hljs-type">string</span>) *node{<br>  <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> n.children {<br>    <span class="hljs-keyword">if</span> child.part == part || child.isWild{<br>      <span class="hljs-keyword">return</span> child<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>}<br><span class="hljs-comment">// 所有匹配成功的节点，用于查找</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> matchChildren(part <span class="hljs-type">string</span>) []*node {<br>  nodes := <span class="hljs-built_in">make</span>([]*node, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> n.children {<br>    <span class="hljs-keyword">if</span> child.part == part||child.isWild{<br>      nodes = <span class="hljs-built_in">append</span>(nodes, child)<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> nodes<br>}<br></code></pre></td></tr></tbody></table></figure><p>对于路由来说，注册和匹配是最重要的。开发服务时，注册路由规则，映射handler; 访问时，匹配路由规则，查找到对应的handler。因此，Trie树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前<code>part</code>的节点，则新建一个。有一点需要注意，<code>/p/:lang/doc</code>只有在第三层节点，即<code>doc</code>节点，pattern才会设置为<code>/p/:lang/doc</code>。</p><p><code>p</code>和<code>:lang</code>节点的<code>pattern</code>属性皆为空。因此，当匹配结束时，我们可以使用<code>n.pattern == ""</code>来判断路由规则是否匹配成功。例如，<code>/p/python</code>虽能成功匹配到<code>:lang</code>，但<code>lang</code>的<code>pattern</code>值为空，因此匹配失败。查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到了<code>*</code>，匹</p><p>配失败，或者匹配到了第<code>len(parts)</code>层节点。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Trie tree's insert</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> insert(pattern <span class="hljs-type">string</span>, parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) {<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height {<br>    n.pattern = pattern<br>    <span class="hljs-keyword">return</span><br>  }<br>  <br>  part := parts[height]<br>  child := n.matchChild(part)<br>  <span class="hljs-keyword">if</span> child == <span class="hljs-literal">nil</span> {<br>    child = &amp;node{part: part, isWild: part[<span class="hljs-number">0</span>] == <span class="hljs-string">':'</span>|| part[<span class="hljs-number">0</span>] == <span class="hljs-string">'*'</span>}<br>    n.children = <span class="hljs-built_in">append</span>(n.children, child)<br>  }<br>  child.insert(pattern, parts, height+<span class="hljs-number">1</span>)<br>}<br><br><span class="hljs-comment">//Trie tree's search</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> search(parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) *node{<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="hljs-string">'*'</span>) {<br>    <span class="hljs-keyword">if</span> n.pattern == <span class="hljs-string">""</span>{<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    }<br>    <span class="hljs-keyword">return</span> n<br>  }<br>  <br>  part := parts[height]<br>  children := n.matchChildren(part)<br>  <br>  <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> children {<br>    result := child.search(parts, height+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> result != <span class="hljs-literal">nil</span> {<br>      <span class="hljs-keyword">return</span> result<br>    }<br>  }<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Trie 树的插入和查找实现之后，就可以将Trie树应用到路由之中了。使用<code>roots</code>来储存每种请求方式的Trie树根节点。使用<code>handlers</code>存储每种请求方式的<code>HandlerFunc</code>。<code>getRoute</code>函数中，还解析了<code>:</code>和<code>*</code>两种匹配符的参数，返回一个map。例如<code>/p/go/doc</code>匹配到<code>/p/:lang/doc</code>，解析结果为：<code>{lang:"go"}</code>，<code>/static/css/xiaogeamadeus.css</code>匹配到<code>/static/*filepath</code>，解析结果为<code>{file path:"css/xiaogeamadeus.css"}</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> router <span class="hljs-keyword">struct</span>{<br>  roots    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node<br>  handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>}<br><br><span class="hljs-comment">// roots key eg, roots['GET'] roots['POST']</span><br><span class="hljs-comment">// handlers key eg, handlers['GET-/p/:lang/doc'], handlers['POST-/p/book']</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouter</span><span class="hljs-params">()</span></span> *router {<br>  <span class="hljs-keyword">return</span> &amp;router{<br>    roots:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node),<br>    handlers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc),<br>  }<br>}<br><br><span class="hljs-comment">// Only one * is allowed</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePattern</span><span class="hljs-params">(pattern stirng)</span></span> []<span class="hljs-type">string</span>{<br>  vs := strings.Split(pattern, <span class="hljs-string">"/"</span>)<br>  <br>  parts := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> vs {<br>    <span class="hljs-keyword">if</span> item != <span class="hljs-string">""</span>{<br>      parts = <span class="hljs-built_in">append</span>()(parts, item)<br>      <span class="hljs-keyword">if</span> item[<span class="hljs-number">0</span>] == <span class="hljs-string">'*'</span>{<br>        <span class="hljs-keyword">break</span><br>      }<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> parts<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc){<br>  parts := parsePattern(pattern)<br>  <br>  key := method + <span class="hljs-string">"_"</span> + pattern<br>  _, ok := r.roots[method]<br>  <span class="hljs-keyword">if</span> !ok {<br>    r.roots[method] = &amp;node{}<br>  }<br>  r.roots[method].insert(pattern, parts, <span class="hljs-number">0</span>)<br>  r.handlers[key] = handler<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> getRoute(method <span class="hljs-type">string</span>, path <span class="hljs-type">string</span>) (*node, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>){<br>  searchParts := parsePattern(path)<br>  params := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>  root, ok := r.roots[method]<br>  <br>  <span class="hljs-keyword">if</span> !ok{<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>  }<br>  <br>  n := root.search(searchParts, <span class="hljs-number">0</span>)<br>  <br>  <span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> {<br>    parts : parsePattern(n.pattern)<br>    <span class="hljs-keyword">for</span> index, part := <span class="hljs-keyword">range</span> parts {<br>      <span class="hljs-keyword">if</span> part[<span class="hljs-number">0</span>] == <span class="hljs-string">':'</span>{<br>        params[part[<span class="hljs-number">1</span>:]] = searchParts[index]<br>      }<br>      <span class="hljs-keyword">if</span> parts[<span class="hljs-number">0</span>] == <span class="hljs-string">'*'</span>&amp;&amp; <span class="hljs-built_in">len</span>(part) &gt;<span class="hljs-number">1</span>{<br>        params[part[<span class="hljs-number">1</span>:]] = strings.Join(searchParts[index:],<span class="hljs-string">"/"</span>)<br>        <span class="hljs-keyword">break</span><br>      }<br>    }<br>    <span class="hljs-keyword">return</span> n, params<br>  }<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Contextとhandleの変化"><a href="#Contextとhandleの変化" class="headerlink" title="Contextとhandleの変化"></a>Contextとhandleの変化</h2><p>在HandleFunc 中，希望能够访问到解析的参数。因此，我们需要对Context对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到<code>Params</code>中，通过<code>c/Param("lang")</code>的方式获取到对应的值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RFC2617: HTTP Authentication</title>
    <link href="/2022/03/11/RFC2617-HTTP-Authentication/"/>
    <url>/2022/03/11/RFC2617-HTTP-Authentication/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP-Authentication-Basic-and-Digest-Access-Authentication"><a href="#HTTP-Authentication-Basic-and-Digest-Access-Authentication" class="headerlink" title="HTTP Authentication: Basic and Digest Access Authentication"></a>HTTP Authentication: Basic and Digest Access Authentication</h2><p>在做课题的过程中需要了解RFC2617的知识，在此做一个中文总结。注：本文仅为个人学习笔记，无任何版权。</p><h3 id="Basic-Authentication-Scheme"><a href="#Basic-Authentication-Scheme" class="headerlink" title="Basic Authentication Scheme"></a>Basic Authentication Scheme</h3><p>基本认证方案(Basic Authentication Scheme)是基于这样的模型：客户必须用一个用户ID和一个密码来认证自己的每个realm，realm vakye应当被认为是一个不透明的字符串，只能与该服务器上的其他realm进行比较以确定是否相等，服务器只有在能够验证Request-URI的用户ID和密码的情况下才能为请求提供服务。</p><p>basic-credentials = base64-user-pass </p><p>base64-user-pass = &lt;base64 [4] encoding of user-pass, except not limited to 76 char/line&gt;</p><p>user-pass = userid “:” password</p><p>userid  = *&lt;TEXT excluding “:”&gt;</p><p>password = *TEXT</p>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RFC6328: Time Based One-Time Password</title>
    <link href="/2022/03/11/RFC6328-Time-Based-One-Time-Password/"/>
    <url>/2022/03/11/RFC6328-Time-Based-One-Time-Password/</url>
    
    <content type="html"><![CDATA[<h2 id="RFC6328-Time-Based-One-Time-Password-TOTP"><a href="#RFC6328-Time-Based-One-Time-Password-TOTP" class="headerlink" title="RFC6328: Time Based One-Time Password (TOTP)"></a>RFC6328: Time Based One-Time Password (TOTP)</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>最近做到的课题需要我利用<a href="https://datatracker.ietf.org/doc/html/rfc6328">RFC6328</a>将自己的邮箱信息加密，作为账号密码发送给对方的服务器。中文全网对于RFC6328的文章较少，在此稍微记载下学习的过程与心得。</p><p>Go写的TOTP库 <a href="https://github.com/xiaogeamadeus/gototp">gototp</a></p><h3 id="TOTP是什么？"><a href="#TOTP是什么？" class="headerlink" title="TOTP是什么？"></a>TOTP是什么？</h3><p>TOTP指基于时间的一次性密码。TOTP是基于OTP (One-Time Password, 一次性密码)的扩展。在RFC4226中，定义了一种基于HMAC的一次性密码，被命名为HOTP。HOTP算法是基于事件的，对其来说移动因子是一个事件计数器。而在TOTP当中，移动因子建立在了一个时间值上。该算法通过利用时间值，提供了一个短命的OTP值，可以有效提高安全性。</p><h3 id="HOTP算法"><a href="#HOTP算法" class="headerlink" title="HOTP算法"></a>HOTP算法</h3><p>HOTP(HMAC-based One-Time Password, RFC4226)算法是基于HMAC-SHA-1算法的，该算法公式如下所示。</p><p>HOTP(K, C) = Truncate(HMAC-SHA-1(K, C))</p><p>其中Truncate代表可以将HMAC-SHA-1转换为HOTP值的函数，K代表共享的秘密，C代表计数器值。</p><p>换言之，想要得到HOTP密码，有如下几个先决条件：</p><ol><li>知道Truncate函数。</li><li>服务器端与客户端有共享的秘密。</li><li>用相同的计数器方法。</li></ol><h3 id="HOTP算法与TOTP算法的区别"><a href="#HOTP算法与TOTP算法的区别" class="headerlink" title="HOTP算法与TOTP算法的区别"></a>HOTP算法与TOTP算法的区别</h3><p>TOTP算法是HOTP算法基于时间的变体。在TOTP算法中，计数器值C被替换为了由时间参考和时间步长得出的值T。首先你要输入现在的Unixtime，然后减去所设置的T0。实际情况下将时间精确到每秒是无法实现的，一般会提供一个步长。</p><p>TOTP可以使用HMAC-SHA-256/512函数，不同于HOTP算法的HMAC-SHA-1函数</p><h3 id="TOTP算法要求"><a href="#TOTP算法要求" class="headerlink" title="TOTP算法要求"></a>TOTP算法要求</h3><p>R1: The prover (e.g., token, soft token) and verifier (authentication or validation server) MUST know or be able to derive the current Unix time (i.e., the number of seconds elapsed since midnight UTC of January 1, 1970) for OTP generation. See [UT] for a more detailed definition of the commonly known “Unix time”. The precision of the time used by the prover affects how often the clock synchronization should be done; see Section 6.</p><p>（服务器端与客户端均能得知现在的Unix时间）</p><p>R2: The prover and verifier MUST either share the same secret or the knowledge of a secret transformation to generate a shared secret.</p><p>（服务器端与客户端需要共享相同的秘密/共享产生共享秘密的转换的知识）</p><p>R3: The algorithm MUST use HOTP [RFC4226] as a key building block.</p><p>（算法必须使用HOTP算法来构建）</p><p>R4: The prover and verifier MUST use the same time-step value X.</p><p>（服务器端与客户端必须使用相同的步长X）</p><p>R5: There MUST be a unique secret (key) for each prover.</p><p>（每个验证者必须有一个独特的秘密（密钥））</p><p>R6: The keys SHOULD be randomly generated or derived using key derivation algorithms.</p><p>（密钥应当是随机生成/使用推导算法）</p><p>R7: The keys MAY be stored in a tamper-resistant device and SHOULD be protected against unauthorized access and usage.</p><p>（密钥应当储存在安全设备中）</p><h3 id="TOTP算法详解"><a href="#TOTP算法详解" class="headerlink" title="TOTP算法详解"></a>TOTP算法详解</h3><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>K代表服务器端与客户端共同了解的秘密。</p><p>X代表以秒为单位的时间步长（默认值X=30秒），是一个系统参数。</p><p>T0是开始计算时间步长的Unix时间（缺省值为0，即Unix epoch，1970年1月1日），也是一个系统参数。</p><h4 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h4><p>我们将TOTP定义为HOTP(K, T), T是一个整数，代表初始计数器时间T0和当前Unix时间之间的时间步数。</p><blockquote><p>TOTP(K, T0, X) = HOTP(K, T(T0, X))</p><p>T(T0, X) = (CurrentUnixTime - T0) / X</p></blockquote><h3 id="TOTP算法实装"><a href="#TOTP算法实装" class="headerlink" title="TOTP算法实装"></a>TOTP算法实装</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gototp<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TOTP</span><span class="hljs-params">(k <span class="hljs-type">string</span>, t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>{<br><span class="hljs-keyword">return</span> HOTP(k, T(T0, x))<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">T</span><span class="hljs-params">(t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> (time.Now().Unix - t0)/x<br>}<br></code></pre></td></tr></tbody></table></figure><p>上述代码中，我们可以发现HOTP函数并未被定义。所以我们还需要对于HOTP进行定义。</p><h3 id="HOTP算法实装"><a href="#HOTP算法实装" class="headerlink" title="HOTP算法实装"></a>HOTP算法实装</h3><p>想要求出HOTP，其实大体只需要三步。</p><ol><li>用Key与Count求出HMAC-SHA1的值。</li><li>生成4个字节的字符串</li><li>计算HOTP值</li></ol><p>我们来逐一分析一下</p><h4 id="1-求解HMAC-SHA1的值"><a href="#1-求解HMAC-SHA1的值" class="headerlink" title="1. 求解HMAC-SHA1的值"></a>1. 求解HMAC-SHA1的值</h4><p>HMAC是密钥相关的哈希计算消息认证码（Hash-based Message Authentication Code）在多种网络协议（如SSL）中得到了广泛使用。通过使用哈希函数，可以从Key和Message中生成认证码。</p><p>假设HMAC-SHA1的值为HS，计算公式如下所示：</p><blockquote><p>HS = HMAC-SHA-1(K, C)</p></blockquote><p>K：共同秘密key</p><p>C：Message，在HOTP函数中为count中的值</p><p>对于Golang来说，HMAC和SHA1都有标准包可以引用，HMAC为<code>crypto/hmac</code>、SHA1为<code>crypto/sha1</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HMACSHA1</span><span class="hljs-params">(k, c []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span>{<br>mac := hmac.New(sha1.New, k)<br>mac.Write(c)<br><span class="hljs-keyword">return</span> mac.Sum(<span class="hljs-literal">nil</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><p>对于Golang来说，HMAC是用<code>has.Hash</code>实装的，利用<code>hmac.New(func()has.Hash, []byte)</code>可以得到哈希函数对应的对象。这样我们就成功的计算出了HS值。</p><p>注；对于SHA1来说，存储空间最大为160bit，最大支持20文字的字符串。</p><h4 id="2-生成一个4byte的字符串"><a href="#2-生成一个4byte的字符串" class="headerlink" title="2. 生成一个4byte的字符串"></a>2. 生成一个4byte的字符串</h4><p>下一步，则是利用第一步计算出的HMAC值，制作一个4byte长度的字符串。</p><blockquote><p>Sbits = DT(HS)</p></blockquote><p>首先计算<code>offsetbits</code>，这是HS的20个字中最后的4bit。</p><p>由于Go语言处理的是字节串(Byte String)，所以当我取出20个字的最后一个字时，取出的其实是一个8bit的数字，由于我们只需要最后的4bit，所以一般情况下给到的结果是（0000xxxx）前四位bit被屏蔽了。同时，由于go没有二进制的字符，所以我们实际上表示会使用16进制。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">offsetbits := hs[<span class="hljs-number">19</span>] &amp; <span class="hljs-number">0xF</span><br><span class="hljs-comment">// 0x后面的数为16进制</span><br><span class="hljs-comment">// &amp; 位and运算 同1为1</span><br></code></pre></td></tr></tbody></table></figure><p>下一步求解<code>offset</code>。</p><p><code>offset</code>可以将<code>offsetbits</code>作为数值取出。</p><p>并没有什么特别的变换，仅仅是直接将byte列作为Integer读出。（因为<code>offsetbits</code>是4bit，所以<code>offset</code>这个值为0-15）</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">offset := <span class="hljs-type">int</span>(offsetbits)<br></code></pre></td></tr></tbody></table></figure><p>接下来，将HS的第<code>offset</code>位开始之后4个文字拿出来，赋值给<code>p</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p := hs[offset:offset + <span class="hljs-number">4</span>]<br></code></pre></td></tr></tbody></table></figure><p>然后提取<code>p</code>（32bit）末尾的31bit（0xx…..xx(31个x)）</p><p>这也是利用mask来做计算的，换句话说与7FFFFFFF做and运算就可以。</p><p>当然，由于用byte列做mask会稍微有些麻烦，所以可以先将<code>[]byte</code>变换为<code>int</code>然后做mask。</p><p>由于Go语言不支持直接变换，所以借用一个包<code>encoding/binary</code></p><p>总结一下第二步所做的工作。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Truncate 函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DT</span><span class="hljs-params">(hs []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> {<br>offsetbits := hs[<span class="hljs-number">19</span>] &amp; <span class="hljs-number">0xF</span><br>offset := <span class="hljs-type">int</span>(offsetbits)<br>p := hs[offset : offset+<span class="hljs-number">4</span>]<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(binary.BigEndian.Uint32(p)) &amp; <span class="hljs-number">0x7FFFFFFF</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="3-计算HOTP的值"><a href="#3-计算HOTP的值" class="headerlink" title="3. 计算HOTP的值"></a>3. 计算HOTP的值</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReductionModulo</span><span class="hljs-params">(snum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(<span class="hljs-type">int64</span>(snum) % <span class="hljs-type">int64</span>(math.Pow10(g.Digit)))<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="HOTP算法总结"><a href="#HOTP算法总结" class="headerlink" title="HOTP算法总结"></a>HOTP算法总结</h4><p>最后将HOTP函数构建一下，将上面的步骤套入。</p><p>再次回顾一下HOTP函数</p><blockquote><p>HOTP(K, C) = Truncate(HMAC - SHA- 1(K, C))</p></blockquote><p>Truncate函数是用上面的<code>DT</code>实现的</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HOTP</span><span class="hljs-params">(k, c []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span>{<br><span class="hljs-keyword">return</span> DT(HMACSHA1(k, c))<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="联合TOTP和HOTP"><a href="#联合TOTP和HOTP" class="headerlink" title="联合TOTP和HOTP"></a>联合TOTP和HOTP</h3><p>完成HOTP函数的构建之后，我们要想办法将其应用在TOTP之中。</p><p>之前我们构建的TOTP函数如下所示</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TOTP</span><span class="hljs-params">(k <span class="hljs-type">string</span>, t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> HOTP(k, T(T0, x))<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">T</span><span class="hljs-params">(t0, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br><span class="hljs-keyword">return</span> (time.Now().Unix - t0) / x<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上，<code>T(t0, x)</code>的返回值是<code>int</code>，是无法在<code>func HOTP(k, c []byte) int</code>中使用的，所以要对HOTP函数进行微调。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HOTP</span><span class="hljs-params">(k []<span class="hljs-type">byte</span>, c <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>{<br>cb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br>binary.BigEndian.PutUint64(cb, c)<br><span class="hljs-keyword">return</span> DT(HMACSHA1(k, cb))<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，我们完成了TOTP算法的基础实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sending HTTP Request with Golang</title>
    <link href="/2022/03/10/Sending-HTTP-Request-with-Golang/"/>
    <url>/2022/03/10/Sending-HTTP-Request-with-Golang/</url>
    
    <content type="html"><![CDATA[<h2 id="The-way-to-send-a-HTTP-request-with-golang"><a href="#The-way-to-send-a-HTTP-request-with-golang" class="headerlink" title="The way to send a HTTP request with golang"></a>The way to send a HTTP request with golang</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"encoding/base64"</span><br><br><span class="hljs-string">"github.com/imroc/req/v3"</span><br><span class="hljs-string">"github.com/jltorresm/otpgo"</span><br><span class="hljs-string">"github.com/jltorresm/otpgo/config"</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>t := otpgo.TOTP{<br>Key: <span class="hljs-string">"wang.tianchen333@gmail.comHENNGECHALLENGE003"</span>,<br>Algorithm: config.HmacSHA512,<br>}<br>token, _ := t.Generate()<br>token1 := <span class="hljs-string">"wang.tianchen333@gmail.com"</span> +<span class="hljs-string">":"</span> + token<br>auto := <span class="hljs-string">"basic "</span> + base64.StdEncoding.EncodeToString([]<span class="hljs-type">byte</span>(token1))<br><br>user := &amp;User{github: <span class="hljs-string">"https://gist.github.com/xiaogeamadeus/ad9d74723a99a882c850eabb66c51d9d"</span>,<br>                  contact: <span class="hljs-string">"wang.tianchen333@gmail.com"</span>,<br>  solution: <span class="hljs-string">"golang"</span>}<br>client := req.C().EnableDumpAllWithoutResponse()<br>client.R().<br>    SetHeaders(<span class="hljs-string">"Authorization"</span>, auto,<br>           <span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>,).<br>    SetBody(user).<br>    Post(<span class="hljs-string">"https://api.challenge.hennge.com/challenges/003"</span>)<br><br>}<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {<br>github <span class="hljs-type">string</span> <span class="hljs-string">`json:"github_url"`</span><br>contact <span class="hljs-type">string</span> <span class="hljs-string">`json:"contact_email"`</span><br>solution <span class="hljs-type">string</span> <span class="hljs-string">`json:"solution_language"`</span><br>}<br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">2022</span>/<span class="hljs-number">03</span>/<span class="hljs-number">12</span> <span class="hljs-number">20</span><span class="hljs-punctuation">:</span><span class="hljs-number">53</span><span class="hljs-punctuation">:</span><span class="hljs-number">40.763848</span> DEBUG <span class="hljs-punctuation">[</span>req<span class="hljs-punctuation">]</span> GET https<span class="hljs-punctuation">:</span><span class="hljs-comment">//api.challenge.hennge.com/challenges/003</span><br><span class="hljs-punctuation">:</span>authority<span class="hljs-punctuation">:</span> api.challenge.hennge.com<br><span class="hljs-punctuation">:</span>method<span class="hljs-punctuation">:</span> GET<br><span class="hljs-punctuation">:</span>path<span class="hljs-punctuation">:</span> /challenges/<span class="hljs-number">003</span><br><span class="hljs-punctuation">:</span>scheme<span class="hljs-punctuation">:</span> https<br>user-agent<span class="hljs-punctuation">:</span> Mozilla/<span class="hljs-number">5.0</span> (Macintosh; Intel Mac OS X <span class="hljs-number">10</span>_15_7) AppleWebKit/<span class="hljs-number">537.36</span> (KHTML<span class="hljs-punctuation">,</span> like Gecko) Chrome/<span class="hljs-number">97.0</span><span class="hljs-number">.4692</span><span class="hljs-number">.71</span> Safari/<span class="hljs-number">537.36</span><br>accept-encoding<span class="hljs-punctuation">:</span> gzip<br><br><span class="hljs-punctuation">:</span>status<span class="hljs-punctuation">:</span> <span class="hljs-number">403</span><br>content-type<span class="hljs-punctuation">:</span> application/json<br>content-length<span class="hljs-punctuation">:</span> <span class="hljs-number">68</span><br>date<span class="hljs-punctuation">:</span> Sat<span class="hljs-punctuation">,</span> <span class="hljs-number">12</span> Mar <span class="hljs-number">2022</span> <span class="hljs-number">11</span><span class="hljs-punctuation">:</span><span class="hljs-number">53</span><span class="hljs-punctuation">:</span><span class="hljs-number">42</span> GMT<br>x-amzn-requestid<span class="hljs-punctuation">:</span> <span class="hljs-number">2492</span>fed6-b665<span class="hljs-number">-4</span>d3e-becb<span class="hljs-number">-0532</span>ed6fb218<br>access-control-allow-origin<span class="hljs-punctuation">:</span> https<span class="hljs-punctuation">:</span><span class="hljs-comment">//challenge.hennge.com</span><br>access-control-allow-headers<span class="hljs-punctuation">:</span> Content-Type<span class="hljs-punctuation">,</span>X-Amz-Date<span class="hljs-punctuation">,</span>Authorization<span class="hljs-punctuation">,</span>X-Api-Key<span class="hljs-punctuation">,</span>X-Amz-Security-Token<br>x-amzn-errortype<span class="hljs-punctuation">:</span> MissingAuthenticationTokenException<br>x-amz-apigw-id<span class="hljs-punctuation">:</span> O3p3EH04NjMFdIQ=<br>access-control-allow-methods<span class="hljs-punctuation">:</span> GET<span class="hljs-punctuation">,</span>OPTIONS<span class="hljs-punctuation">,</span>POST<span class="hljs-punctuation">,</span>PUT<br>x-cache<span class="hljs-punctuation">:</span> Error from cloudfront<br>via<span class="hljs-punctuation">:</span> <span class="hljs-number">1.1</span> e2f427863e6bdb72ad8bed72b596d81e.cloudfront.net (CloudFront)<br>x-amz-cf-pop<span class="hljs-punctuation">:</span> OSL50-P1<br>x-amz-cf-id<span class="hljs-punctuation">:</span> nLWbqmaTIGAh2btKEQOFDkk5LDTgu6DBtboJS9a-OCPfaEZ08ubPqQ==<br><br><span class="hljs-punctuation">{</span><br>     <span class="hljs-attr">"message"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"User is not authorized to access this resource"</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">"github_url"</span>: <span class="hljs-string">"https://gist.github.com/xiaogeamadeus/ad9d74723a99a882c850eabb66c51d9d"</span>,<span class="hljs-string">"contact_email"</span>: <span class="hljs-string">"wang.tianchen333@gmail.com"</span>,<span class="hljs-string">"solution_language"</span>: <span class="hljs-string">"golang"</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">{<span class="hljs-string">"github_url"</span>:<span class="hljs-string">"https://gist.github.com/hennge/b859bd12e7a7fb418141"</span>,<span class="hljs-string">"contact_email"</span>:<span class="hljs-string">"ninja@example.com"</span>,<span class="hljs-string">"solution_language"</span>:<span class="hljs-string">"golang"</span>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gogee_Day2 コンテキスト</title>
    <link href="/2022/03/09/Gogee-Day2-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88/"/>
    <url>/2022/03/09/Gogee-Day2-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88/</url>
    
    <content type="html"><![CDATA[<p>注：本文仅为个人学习笔记，无任何版权。</p><p>本部分主要内容：</p><ol><li>将router独立出来，方便之后增强。</li><li>设计context，封装Request和Response，提供对JSON（JavaScript Object Notation）、HTML等返回类型的支持。</li></ol><h2 id="コンテキストの設計"><a href="#コンテキストの設計" class="headerlink" title="コンテキストの設計"></a>コンテキストの設計</h2><h4 id="必要がある？"><a href="#必要がある？" class="headerlink" title="必要がある？"></a>必要がある？</h4><ol><li>对于web服务来说，无非就是根据Request<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。但这两个对象所提供的API太细了，比如，如果我们想要构建一个完整的Response，需要考虑Header，Body，而Header包含了状态码 (StatusCode)，消息类型(ContentType) 等几乎每次请求都要设置的信息。所以如果不进行有效的封装，使用这个框架的用户需要写大量重复且复杂的代码，还容易出错。所以说对于一个好的框架而言，能够高效的构造出HTTP响应是一个关键点。</li><li>针对使用场景来说，封装<code>*http.Request</code>和<code>http.ResponseWriter</code>的方法，简化相关port的调用只是设计Context原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态router<code>/hello/:name</code>，参数<code>:name</code>的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context可以随着每一个请求的出现而产生，也随着请求的结束而销毁。所以设计Context结构，我们可以将复杂性和扩展性留在内部，对外简化了port和router的处理函数；要实现的中间件、参数都统一使用Context实例，就像一个百宝箱，可以在其中找到任何东西。</li></ol><h4 id="具体的に実現する"><a href="#具体的に実現する" class="headerlink" title="具体的に実現する"></a>具体的に実現する</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gogee<br><br><span class="hljs-keyword">import</span>(<br><span class="hljs-string">"encoding/json"</span><br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-keyword">type</span> H <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>{}<br><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span>{<br><span class="hljs-comment">//origin objects</span><br>Writer http.ResponseWriter<br>Req    *http.Request<br><span class="hljs-comment">//request info</span><br>Path <span class="hljs-type">string</span><br>Method <span class="hljs-type">string</span><br><span class="hljs-comment">//response info</span><br>StatusCode <span class="hljs-type">int</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newContext</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> *Context{<br><span class="hljs-keyword">return</span> &amp;Context{<br>Writer: w,<br>Req:    req,<br>Path:   req.URL.Path,<br>Method: req.Method,<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> PostForm(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span>{<br><span class="hljs-keyword">return</span> c.Req.FormValue(key)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Query(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span>{<br><span class="hljs-keyword">return</span> c.Req.URL.Query().Get(key)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Status(code <span class="hljs-type">int</span>) {<br>c.StatusCode = code<br>c.Writer.WriteHeader(code)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SetHeader(key <span class="hljs-type">string</span>, value <span class="hljs-type">string</span>){<br>c.Writer.Header().Set(key, value)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> String(code <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, values ...<span class="hljs-keyword">interface</span>{}){<br>c.SetHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"text/plain"</span>)<br>c.Status(code)<br>c.Writer.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(format, values...)))<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> JSON(code <span class="hljs-type">int</span>, obj <span class="hljs-keyword">interface</span>{}){<br>c.SetHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>)<br>c.Status(code)<br>encoder := json.NewEncoder(c.Writer)<br><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span>{<br>http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Data(code <span class="hljs-type">int</span>, data []<span class="hljs-type">byte</span>){<br>c.Status(code)<br>c.Writer.Write(data)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, html <span class="hljs-type">string</span>){<br>c.SetHeader(<span class="hljs-string">"Content-Type"</span>,<span class="hljs-string">"text/html"</span>)<br>c.Status(code)<br>c.Writer.Write([]<span class="hljs-type">byte</span>(html))<br>}<br></code></pre></td></tr></tbody></table></figure><p>第一步给<code>map[string]interface{}</code>起别名<code>gogee.H</code>这样在构建JSON数据时更加简洁。</p><p><code>Context</code>结构目前只包含<code>http.ResponseWriter</code>和<code>*http.Request</code>不过同时提供了对于Method/Path等request的常用属性的直接访问。</p><p>代码提供了访问Query和PostForm参数的方法。</p><p>代码提供了快速构造String/Data/JSON/HTML响应的方法。</p><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>我们将路由相关的方法和结构提取出来，放到了一个新的文件<code>router.go</code>中，方便我们下一次对于router的功能进行增强，比如提供动态路由的支持。同时，router的handle方法做了一个细微的调整，将handler的参数变为了Context。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gogee<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-keyword">type</span> router <span class="hljs-keyword">struct</span> {<br>handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouter</span><span class="hljs-params">()</span></span> *router {<br><span class="hljs-keyword">return</span> &amp;router{handlers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc)}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>key := method + <span class="hljs-string">"_"</span> + pattern<br>r.handlers[key] = handler<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) {<br>key := c.Method + <span class="hljs-string">"_"</span> + c.Path<br><span class="hljs-keyword">if</span> handler, ok := r.handlers[key]; ok {<br>handler(c)<br>} <span class="hljs-keyword">else</span> {<br>c.String(http.StatusNotFound, <span class="hljs-string">"404 NOT FOUND: %s\n"</span>, c.Path)<br>}<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="框架入口"><a href="#框架入口" class="headerlink" title="框架入口"></a>框架入口</h4><p>在修改了router并且增加了context部分之后，我们可以大幅度缩减<code>gogee.go</code>文件的内容。因为一些复杂的东西已经被放在<code>router.go</code>和<code>Context.go</code>之中了。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gogee<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"log"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-comment">// HandlerFunc defines the request handler used by Gogee</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span><br><br><span class="hljs-comment">// Engine implement the interface of ServeHTTP</span><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> {<br>router *router<br>}<br><br><span class="hljs-comment">// New is the constructor of Gogee.Engine</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine {<br><span class="hljs-keyword">return</span> &amp;Engine{router: newRouter()}<br>}<br><br><span class="hljs-comment">// addRoute is the way to add something to route</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>log.Printf(<span class="hljs-string">"Route %4s - %s"</span>, method, pattern)<br>engine.router.addRoute(method, pattern, handler)<br>}<br><br><span class="hljs-comment">// GET defines the method to add GET request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>engine.addRoute(<span class="hljs-string">"GET"</span>, pattern, handler)<br>}<br><br><span class="hljs-comment">//POST defines the method to POST request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) {<br>engine.addRoute(<span class="hljs-string">"POST"</span>, pattern, handler)<br>}<br><br><span class="hljs-comment">//Run definesd the method to start a http server</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>) {<br><span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>}<br><br><span class="hljs-comment">// To use the ListenAndServe, we need to set a ServeHTTP struct</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) {<br>c := newContext(w, req)<br>engine.router.handle(c)<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>当然最重要的还是通过实现了ServeHTTP的接口之后，接管了所有的HTTP请求。</p><p>最后，稍微修改一下<code>main.go</code>文件。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"gogee"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>r := gogee.New()<br>r.GET(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gogee.Context)</span></span> {<br>c.HTML(http.StatusOK, <span class="hljs-string">"&lt;h1&gt;Hello Gogee&lt;/h1&gt;"</span>)<br>})<br><br>r.GET(<span class="hljs-string">"/hello"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gogee.Context)</span></span> {<br>c.String(http.StatusOK, <span class="hljs-string">"hello %s, you're at %s\n"</span>, c.Query(<span class="hljs-string">"name"</span>), c.Path)<br>})<br><br>r.POST(<span class="hljs-string">"/login"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gogee.Context)</span></span> {<br>c.JSON(http.StatusOK, gogee.H{<br><span class="hljs-string">"username"</span>: c.PostForm(<span class="hljs-string">"username"</span>),<br><span class="hljs-string">"password"</span>: c.PostForm(<span class="hljs-string">"password"</span>),<br>})<br>})<br><br>r.Run(<span class="hljs-string">":9999"</span>)<br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Terminal for Mac</title>
    <link href="/2022/03/09/Terminal-for-Mac/"/>
    <url>/2022/03/09/Terminal-for-Mac/</url>
    
    <content type="html"><![CDATA[<h2 id="The-Basic-Operation-of-Shell-for-Mac"><a href="#The-Basic-Operation-of-Shell-for-Mac" class="headerlink" title="The Basic Operation of Shell for Mac"></a>The Basic Operation of Shell for Mac</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><h3 id="更改目录："><a href="#更改目录：" class="headerlink" title="更改目录："></a>更改目录：</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">cd &lt;Path&gt; //找到对应路径<br>cd .. //移动到上一级目录<br>pushd &lt;Path&gt; //记住来源的同时移动到其他目录，popd 返回来源<br></code></pre></td></tr></tbody></table></figure><h3 id="目录列举"><a href="#目录列举" class="headerlink" title="目录列举"></a>目录列举</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls //列举出当前目录下所有的文件和子目录<br>   //可以使用通配符 * 来缩小搜索范围。<br>   //例1: 列举所有以".java"结尾的文件<br>     ls *.java<br>   //例2：列举所有以"F"开头，".java"结尾的文件<br>     ls F*.java<br></code></pre></td></tr></tbody></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir //系统<br>mkdir books //示例<br></code></pre></td></tr></tbody></table></figure><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm //系统<br>rm somefile.java //示例<br></code></pre></td></tr></tbody></table></figure><h3 id="移除目录"><a href="#移除目录" class="headerlink" title="移除目录"></a>移除目录</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -r //系统<br>rm -r books //示例<br></code></pre></td></tr></tbody></table></figure><h3 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">!! //重复上条命令<br>!n //重复倒数第n条命令<br></code></pre></td></tr></tbody></table></figure><h3 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">history //系统<br></code></pre></td></tr></tbody></table></figure><h3 id="文件解压"><a href="#文件解压" class="headerlink" title="文件解压"></a>文件解压</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">//Linux/Mac 都有命令行解压程序 unzip，你可以通过互联网为 Windows 安装命令行解压程序 unzip。<br>//图形界面下（Windows 资源管理器，Mac Finder，Linux Nautilus 或其他等效软件）右键单击该文件，<br>//在 Mac 上选择“open”<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基礎</title>
    <link href="/2022/03/09/Git%E5%9F%BA%E7%A4%8E/"/>
    <url>/2022/03/09/Git%E5%9F%BA%E7%A4%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="Gitを使って方法（Mac）"><a href="#Gitを使って方法（Mac）" class="headerlink" title="Gitを使って方法（Mac）"></a>Gitを使って方法（Mac）</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><h2 id="建立仓库，并与git连接"><a href="#建立仓库，并与git连接" class="headerlink" title="建立仓库，并与git连接"></a>建立仓库，并与git连接</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li><p>github上新建一个repository</p></li><li><p>复制repository的ssh地址</p></li><li><p>打开终端输入命令</p><p><code>cd /users/xiaogeamadeus/mygo/src</code></p></li><li><p>然后克隆项目</p><p><code>git clone ssh (copy from github)</code></p></li><li><p>在vscode新建一个工程，路径为刚克隆的文件夹</p></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li><p>本地创建一个repository</p><p><code>mkdir projectname</code></p><p><code>cd projectname</code></p></li><li><p>通过<code>git init</code>命令将这个projectname目录变为git可以管理的目录</p><p><code>git init</code></p></li></ol><h2 id="如何提交修改"><a href="#如何提交修改" class="headerlink" title="如何提交修改"></a>如何提交修改</h2><ol><li><p>切换到项目文件夹所在的路径</p><p>``cd /users/xiaogeamadeus/mygo/project(created)`</p></li><li><p>输入</p><p><code>git add .</code> 将文件添加到仓库（.代表提交所有文件）</p><p><code>git commit -m "day1"</code> 把文件提交到暂存区（””内为本次提交的说明，用于方便找到提交记录）</p><p><code>git push</code> 上传到github</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Module</title>
    <link href="/2022/03/09/Go-Module/"/>
    <url>/2022/03/09/Go-Module/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Moduleとは"><a href="#Go-Moduleとは" class="headerlink" title="Go Moduleとは"></a>Go Moduleとは</h1><p>注：本文仅为个人学习笔记，无任何版权。</p><p>go在更新到1.13版本之后，由官方将其令人诟病的依赖管理进行了维护。</p><p>go module 是 go 官方自带的go依赖管理库(Dependency Management Library)</p><p>go module 可以将某个项目（文件夹）下所有的依赖整理成一个go.mod文件，里面写入了依赖的版本等。</p><p>使用了go module之后我们可以不用将代码放在src下了。</p><h2 id="Go-Module的使用方法"><a href="#Go-Module的使用方法" class="headerlink" title="Go Module的使用方法"></a>Go Module的使用方法</h2><p>初始化</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /your catalog/test(your project)<br>go mod init <span class="hljs-built_in">test</span><br></code></pre></td></tr></tbody></table></figure><p>这时候会发现项目文件夹下多出了一个go.mod文件夹</p>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ウェブサービス設計基礎</title>
    <link href="/2022/03/08/%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E8%A8%AD%E8%A8%88%E5%9F%BA%E7%A4%8E/"/>
    <url>/2022/03/08/%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E8%A8%AD%E8%A8%88%E5%9F%BA%E7%A4%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="How-the-Web-Works"><a href="#How-the-Web-Works" class="headerlink" title="How the Web Works?"></a>How the Web Works?</h2><p>注：本文仅为个人学习笔记，无任何版权。</p><p>平时在上网的时候，打开浏览器，输入网址，按下回车，显示想要的内容。这个过程电脑端与服务器端是怎样实现的呢？</p><p>对于普通的上网过程，系统是这样做的：浏览器是一个客户端(client-site)，当你输入URL时，首先浏览器会请求DNS服务器，通过DNS服务器获取域名所对应的IP，然后通过IP地址找到Ip对应的服务器，要求建立TCP链接，等浏览器发送完HTTP Request（请求）包之后，服务器(server-site)接收到请求包，处理请求包，调用自身服务，返回HTTP Response（响应）包；客户端收到来自服务器的响应后开始渲染这个Response包中的主体(body)，等收到全部的内容后端开与服务器之间的TCP链接。<img src="/%E3%82%A6%E3%82%A7%E3%83%95%E3%82%99%E3%82%B5%E3%83%BC%E3%83%92%E3%82%99%E3%82%B9%E8%A8%AD%E8%A8%88%E5%9F%BA%E7%A4%8E/3.1.web2.png" alt="3.1.web2"></p><p>一个web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信。这个客户端一般指的是web浏览器。</p><p>web服务器端的功能可以被总结为以下几点</p><ol><li>客户端通过TCP/IP协议建立到服务器的TCP连接。</li><li>客户端向服务器发送HTTP协议请求包(HTTP Request)，请求服务器里的资源文档。</li><li>服务器向客户端发送HTTP协议应答包(HTTP Response)，如果请求的资源包含动态语言，服务器会调用动态语言的解释引擎处理“动态内容”，并将处理得到的数据返回给客户端。</li><li>客户端与服务器断开，由客户端解释HTML文档，在客户端屏幕上渲染图形结果。</li></ol><p><strong>注：客户端与服务器之间的通讯是非持久性的，服务器发送了应答之后就会与客户端断开连接，等待下一次请求。</strong></p><h3 id="URLとDNS"><a href="#URLとDNS" class="headerlink" title="URLとDNS"></a>URLとDNS</h3><p>略，Computer Science：an Overview讲过</p><p>注：DNS使用的是递归查询过程+迭代查询过程，最后获取IP地址</p><h3 id="HTTP-Protocol"><a href="#HTTP-Protocol" class="headerlink" title="HTTP Protocol"></a>HTTP Protocol</h3><p>HTTP协议是web工作的核心。想要了解web的工作原理，就要了解HTTP是怎么工作的。</p><p>HTTP(Hyper Text Transfer Protocol) 超文本传输协议：客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><p>HTTP是一种让web服务器与浏览器（客户端）通过互联网(Internet)发送与接收数据的协议，它建立在<strong>TCP协议</strong>之上，一般采用TCP的80端口。它是一个请求与响应的协议：客户端发出请求，服务器响应请求。服务器不能主动联系客户端，也不能给客户端发出回调链接。客户端与服务器端都可以提前中断一个连接。</p><p>HTTP协议是无状态的，同一个客户端的这次请求和上次请求没有任何对应关系。服务器并不知道这两个请求是否来自同一个客户端。为了解决这个问题，web程序引入了<strong>cookie</strong>机制来维护<strong>连接的可持续状态</strong>。</p><h4 id="HTTP-Requests-Client-Site"><a href="#HTTP-Requests-Client-Site" class="headerlink" title="HTTP Requests (Client Site)"></a>HTTP Requests (Client Site)</h4><p>对于客户端发出的HTTP请求包，其结构分为三部分。第一部分为Request line（请求行），第二部分叫request header（请求头），第三部分是body（主体）。header 和 body之间有个空行，如下所示。</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">GET <span class="hljs-regexp">/domains/</span>example<span class="hljs-regexp">/ HTTP/</span><span class="hljs-number">1.1</span><span class="hljs-regexp">//</span>请求行: 请求方法 请求URI HTTP协议/协议版本<br>Host：www.iana.org<span class="hljs-regexp">//</span>服务端的主机名<br>User-Agent：Mozilla<span class="hljs-regexp">/5.0 (Windows NT 6.1) AppleWebKit/</span><span class="hljs-number">537.4</span> (KHTML, like Gecko) Chrome<span class="hljs-regexp">/22.0.1229.94 Safari/</span><span class="hljs-number">537.4</span><span class="hljs-regexp">//</span>浏览器信息<br>Accept：text<span class="hljs-regexp">/html,application/</span>xhtml+xml,application<span class="hljs-regexp">/xml;q=0.9,*/</span>*;q=<span class="hljs-number">0.8</span><span class="hljs-regexp">//</span>客户端能接收的MIME<br>Accept-Encoding：gzip,deflate,sdch<span class="hljs-regexp">//</span>是否支持流压缩<br>Accept-Charset：UTF-<span class="hljs-number">8</span>,*;q=<span class="hljs-number">0.5</span><span class="hljs-regexp">//</span>客户端字符编码集<br><span class="hljs-regexp">//</span>空行,用于分割请求头和消息体<br><span class="hljs-regexp">//</span>消息体,请求资源参数,例如POST传递的参数<br></code></pre></td></tr></tbody></table></figure><p>HTTP协议定义了许多与服务器交互的请求方法，最基本的有4种，GET/ POST/ PUT/ DELETE。一个URL地址用于描述一个网络上的资源，而HTTP的四个基本操作对应着对这个资源的查，增，改，删。</p><p>GET一般用于获取/查询资源信息，POST一般用于更新资源信息。</p><p>GET与POST的区别如下：</p><ol><li>GET的请求body为空，而POST的body不为空</li><li>GET提交的数据会放到URL之后，以<code>?</code>分割URL和传输数据，参数之间以<code>&amp;</code>相连，如<code>EditPosts.aspx? name=test1&amp;id=123456</code>POST方法则是把提交的数据放到HTTP包的body中。</li><li>GET提交的数据大小有限制，POST无限制</li><li>GET提交数据会带来安全问题（URL会显示账号密码，类似zoom的登陆URL）</li></ol><h4 id="HTTP-Response-Server-site"><a href="#HTTP-Response-Server-site" class="headerlink" title="HTTP Response (Server site)"></a>HTTP Response (Server site)</h4><p>HTTP的response包结构如下</p><figure class="highlight sqf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sqf">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<span class="hljs-comment">//状态行</span><br>Server: nginx/<span class="hljs-number">1.0</span>.<span class="hljs-number">8</span><span class="hljs-comment">//服务器使用的WEB软件名及版本</span><br><span class="hljs-built_in">Date</span>:<span class="hljs-built_in">Date</span>: Tue, <span class="hljs-number">30</span> Oct <span class="hljs-number">2012</span> <span class="hljs-number">04</span>:<span class="hljs-number">14</span>:<span class="hljs-number">25</span> GMT<span class="hljs-comment">//发送时间</span><br>Content-<span class="hljs-built_in">Type</span>: <span class="hljs-built_in">text</span>/html<span class="hljs-comment">//服务器发送信息的类型</span><br>Transfer-Encoding: chunked<span class="hljs-comment">//表示发送HTTP包是分段发的</span><br>Connection: keep-<span class="hljs-built_in">alive</span><span class="hljs-comment">//保持连接状态</span><br>Content-Length: <span class="hljs-number">90</span><span class="hljs-comment">//主体内容长度</span><br><span class="hljs-comment">//空行 用来分割消息头和主体</span><br>&lt;!DOCTYPE html PUBLIC <span class="hljs-string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span>... <span class="hljs-comment">//消息体</span><br></code></pre></td></tr></tbody></table></figure><p>其第一行叫做<strong>状态行</strong>，由HTTP协议版本号，状态码，状态消息三部分组成</p><p>状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response。对于HTTP/1.1版本来说，状态码情况如下：</p><ul><li>1XX 提示信息 - 表示请求已被成功接收，继续处理</li><li>2XX 成功 - 表示请求已被成功接收，理解，接受</li><li>3XX 重定向 - 要完成请求必须进行更进一步的处理</li><li>4XX 客户端错误 - 请求有语法错误或请求无法实现</li><li>5XX 服务器端错误 - 服务器未能实现合法的请求</li></ul><p>本质上还是被分为Header（包含状态行）与Body。</p><h4 id="HTTP-と-Connection-keep-alive"><a href="#HTTP-と-Connection-keep-alive" class="headerlink" title="HTTP と Connection: keep-alive"></a>HTTP と Connection: keep-alive</h4><p>从HTTP/1.1起，默认开启了Keep-Alive保持连接特性，其含义是当一个网页完成打开后，客户端与服务器之间用于传输的TCP连接不会被关闭。如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。</p><p>Keep-Alive不会永久保持，有一个保持时间，可以设定。</p><h3 id="Goを使ってウェブサーバーをつくよう！"><a href="#Goを使ってウェブサーバーをつくよう！" class="headerlink" title="Goを使ってウェブサーバーをつくよう！"></a>Goを使ってウェブサーバーをつくよう！</h3><p>对于Go语言来说，其提供给了我们一个完整的<code>net/http</code>包，这样可以很方便的搭建起一个可以运行的web服务。这个使用包也能很简单的对于web的router、静态文件、模版、cookie等数据进行操作和设置。</p><h4 id="Use-net-x2F-http-Package-to-Create-a-Web-Server"><a href="#Use-net-x2F-http-Package-to-Create-a-Web-Server" class="headerlink" title="Use net/http Package to Create a Web Server"></a>Use net/http Package to Create a Web Server</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"log"</span><br><span class="hljs-string">"net/http"</span><br><span class="hljs-string">"strings"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayhelloName</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {<br>r.ParseForm()       <span class="hljs-comment">// 解析参数，default是不解析的。</span><br>fmt.Println(r.Form) <span class="hljs-comment">// 这些信息是输出到服务器端的打印信息。</span><br>fmt.Println(<span class="hljs-string">"path"</span>, r.URL.Scheme)<br>fmt.Println(<span class="hljs-string">"scheme"</span>, r.URL.Scheme)<br>fmt.Println(r.Form[<span class="hljs-string">"url_long"</span>])<br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form {<br>fmt.Println(<span class="hljs-string">"key:"</span>, k)<br>fmt.Println(<span class="hljs-string">"val:"</span>, strings.Join(v, <span class="hljs-string">""</span>))<br>}<br>fmt.Fprintf(w, <span class="hljs-string">"Hello XiaoGeAmadeus!"</span>) <span class="hljs-comment">// 将你想说的话写入w，之后会在客户端输出。</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>http.HandleFunc(<span class="hljs-string">"/"</span>, sayhelloName)       <span class="hljs-comment">//设置访问的路由</span><br>err := http.ListenAndServe(<span class="hljs-string">":9090"</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">//设置监听的端口</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br>log.Fatal(<span class="hljs-string">"ListenAndServe: "</span>, err)<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面的代码，当我们build之后，就已经在9090端口监听http链接请求了。</p><p>可以在浏览器输入<code>http://localhost:9090</code>进行实验。</p><h3 id="Goがウェブを動かすの方法"><a href="#Goがウェブを動かすの方法" class="headerlink" title="Goがウェブを動かすの方法"></a>Goがウェブを動かすの方法</h3><p>我们可以看见简单应用net/http包就可以很轻松的用Go搭建起web服务。那么go在底层是怎么做的呢？</p><h4 id="Several-concepts-of-how-the-web-works"><a href="#Several-concepts-of-how-the-web-works" class="headerlink" title="Several concepts of how the web works"></a>Several concepts of how the web works</h4><p>Request：用户请求的信息，用来解析用户的请求信息，包括POST、GET、cookie、url等信息。</p><p>Response：服务器需要反馈给客户端的信息</p><p>Conn：用户的每次请求链接</p><p>Handler：处理请求和生成返回信息的处理逻辑</p><h4 id="Analyze-the-http-package-operation-mechanism"><a href="#Analyze-the-http-package-operation-mechanism" class="headerlink" title="Analyze the http package operation mechanism"></a>Analyze the http package operation mechanism</h4><ol><li>创建Listen Socket，监听指定的端口，等待客户端请求到来。<a href="https://xiaogeamadeus.github.io/2022/03/26/TCP-IP-UDP-and-Socket/">（Socket是什么）</a></li><li>Listen Socket接受客户端的请求，得到Client Socket，接下来通过Client Socket与客户端通信。</li><li>处理客户端的请求，首先从Client Socket读取HTTP请求的协议头，如果是POST方法，还需要读取客户端提交的数据，然后交给相应的handler处理请求，handler处理完毕准备好客户端需要的数据，通过Client Socket写给客户端。</li></ol><p>在整个过程中，我们只需要了解三个问题，就可以明白Go是如何让Web运行起来的。</p><ol><li>如何监听端口？</li><li>如何接收客户端请求？</li><li>如何分配handler？</li></ol><h5 id="How-to-Listen-the-Part"><a href="#How-to-Listen-the-Part" class="headerlink" title="How to Listen the Part"></a>How to Listen the Part</h5><p>从前面小节的代码中我们可以看出，对于监听来说，<code>net/http</code>包中有一个专用的API<code>ListenAndServe</code>来进行处理。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(addr <span class="hljs-type">string</span>, handler Handler)</span></span> <span class="hljs-type">error</span> {<br>  server := &amp;Server{Addr: addr, Handler: handler}<br>  <span class="hljs-keyword">return</span> server.ListenAndServe()<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>ListenAndServe</code>会初始化一个<code>sever</code>对象，然后调用了<code>Server</code>对象的方法<code>ListenAndServe</code>。其源码如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> ListenAndServe() <span class="hljs-type">error</span>{<br>  <span class="hljs-comment">//对于Server对象的ListenAndServe方法。</span><br>  <span class="hljs-keyword">if</span> srv.shuttingDown() {<br>    <span class="hljs-keyword">return</span> ErrServerClosed<br>  }<br>  addr := srv.Addr<br>  <span class="hljs-keyword">if</span> addr == <span class="hljs-string">""</span> {<br>    addr = <span class="hljs-string">":http"</span><br>  }<br>  ln, err := net.Listen(<span class="hljs-string">"tcp"</span>, addr)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {  <br>    <span class="hljs-comment">//若err值不为空（出现了错误值）</span><br>    <span class="hljs-keyword">return</span> err<br>    <span class="hljs-comment">//返回错误值</span><br>  }<br>  <span class="hljs-keyword">return</span> srv.Serve(ln)<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>ListenAndServe</code>调用了<code>net.Listen("tcp, addr")</code>，也就是底层用TCP协议搭建了一个服务，最后调用<code>src.Serve</code>监控我们设置的端口。监控之后如何接受客户端的请求呢？</p><h5 id="How-to-Accept-the-Request-from-client-side"><a href="#How-to-Accept-the-Request-from-client-side" class="headerlink" title="How to Accept the Request from client-side"></a>How to Accept the Request from client-side</h5><p><code>Serve</code>的具体实现如下（仅包括关键代码），通过下面的分析源码我们可以看到客户端请求的具体处理过程：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> {<br>  ...<br>  <br>  ctx := context.WithValue(baseCtx, ServerContextKey, srv)<br>  <span class="hljs-keyword">for</span> {<br>    rw, err := l.Accept()<br>    ...<br>    connCtx := ctx<br>    <span class="hljs-keyword">if</span> cc := srv.ConnContext; cc != <span class="hljs-literal">nil</span> {<br>      connCtx = cc(connCtx, rw)<br>      <span class="hljs-keyword">if</span> connCtx == <span class="hljs-literal">nil</span> {<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"ConnContext returned nil"</span>)<br>      }<br>    }<br>    tempDelay = <span class="hljs-number">0</span><br>    c := srv.newConn(rw)<br>    c.setState(c.rwc, stateNew, runHooks) <span class="hljs-comment">//before Serve can return </span><br>    <span class="hljs-keyword">go</span> c.serve(connCtx)<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这个函数利用了for循环，首先通过Listener接受请求<code>l.Accept()</code>，其次创建一个Conn：<code>c := srv.newConn(rw)</code> ，最后单独开了一个goroutine，把这个请求的数据当成参数扔给这个conn去服务：<code>go c.serve(connCtx)</code>。这个就是对于高并发的体现。用户的每一次请求都是在一个新的goroutine去服务，相互不影响。</p><h5 id="How-to-distribute-the-function-to-solve-request"><a href="#How-to-distribute-the-function-to-solve-request" class="headerlink" title="How to distribute the function to solve request."></a>How to distribute the function to solve request.</h5><p>那么如何分配具体的函数来处理请求呢？我们继续分析conn的<code>serve</code>方法，其源码如下（仅展示关键代码）：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> serve(ctx context.Context) {<br>  ...<br>  <br>  ctx, cancelCtx := context.WithCancel(ctx)<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Routing for Web Developer</title>
    <link href="/2022/03/08/Routing-for-Web-Developer/"/>
    <url>/2022/03/08/Routing-for-Web-Developer/</url>
    
    <content type="html"><![CDATA[<p>注：本文仅为个人学习笔记，无任何版权。</p><p>在web开发过程中，经常会遇到“路由”（Routing）的概念。路由到底是什么？简单来说，路由就是URL到函数的映射。是用来跟后端服务器进行交互的一种方式，通过不同的路径来请求不同的资源，请求不同的页面。ネットワーク上でデータを転送する際、その経路を導き出すことを<em>ルーティング</em>と呼びます。</p><h3 id="The-Flow-Path-of-Routing"><a href="#The-Flow-Path-of-Routing" class="headerlink" title="The Flow Path of Routing"></a>The Flow Path of Routing</h3><ol><li>服务器发出请求。</li><li>服务器端监听到80端口（http）或者443端口（https）有请求，并且解析URL路径。</li><li>根据服务器的路由配置，返回相应信息（html / json / image）。</li><li>浏览器根据数据包的content-type来决定如何解析数据。</li></ol><h3 id="The-Difference-between-Router-and-Route"><a href="#The-Difference-between-Router-and-Route" class="headerlink" title="The Difference between Router and Route"></a>The Difference between Router and Route</h3><p>route 就是一条路由，将一条URL路径与一个函数进行映射，例如</p><p><code> /users -&gt; getAlUsers()</code> </p><p><code>/users/count -&gt; getUsersCount()</code></p><p>这就是两条路由，访问users时，将会执行getAllUsers()函数；当访问 /users/count时，会执行getUsersCount()函数</p><p>而router（路由器）可以理解为一个容器，或者说一种机制，他管理了一组route。route执行的过程是由router来处理的。”The router routes you to a route.”</p><h3 id="The-Route-of-Server"><a href="#The-Route-of-Server" class="headerlink" title="The Route of Server"></a>The Route of Server</h3><p>对于服务器来说，当接收到客户端发来的http请求，会根据请求的URL，来找到相应的映射函数，并且执行，将返回值发回客户端。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">app.<span class="hljs-built_in">get</span>(<span class="hljs-string">'/'</span>, (req, res)=&gt;{undefined<br><br>res.<span class="hljs-built_in">sendFile</span>(<span class="hljs-string">'index'</span>)<br><br>})<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">app.<span class="hljs-built_in">get</span>(<span class="hljs-string">'/users'</span>, (req,res)=&gt;{undefined<br>db.<span class="hljs-built_in">queryAllUsers</span>()<br>.<span class="hljs-built_in">then</span>(data =&gt; res,<span class="hljs-built_in">send</span>(data))<br>})<br></code></pre></td></tr></tbody></table></figure><p>这里定义了两条路由，访问<code>/</code>时，会返回index界面；访问<code>/users</code>时，会从数据库中读取所有的用户数据并返回。</p><h3 id="Dynamic-Router-と-Static-Router"><a href="#Dynamic-Router-と-Static-Router" class="headerlink" title="Dynamic Router と Static Router"></a>Dynamic Router と Static Router</h3><h4 id="Static-Router"><a href="#Static-Router" class="headerlink" title="Static Router"></a>Static Router</h4><p>静态路由是由管理员手工配置的，简单直接，是什么就是什么。但缺点在于如果网络拓扑发生变化/故障时静态路由也得由管理员亲手修改。</p><p>举个例子来说，就像公交车一样，路线与停靠站都是决定好的，就算有近路或者路线被堵了也只能按照规定好的路线走。</p><p>对于家用路由器来说每个家用路由中都有一条设定好的默认路由。默认添加了一条指向wan口的默认路由。因为没有第二条路走所以大丈夫。</p><h4 id="Dynamic-Router"><a href="#Dynamic-Router" class="headerlink" title="Dynamic Router"></a>Dynamic Router</h4><p>现在我们来到一座陌生的城市，我们用google map进行导航。这里面，googlemap其实分了两步操作。第一步手机会自动下载我们周围的道路信息，第二步是根据算法计算出一条最好的路径去目的地。</p><p>动态路由适合大型网络，不需要手动添加路由条目，方便管理。</p><p>就好比出租车，会抄近路，也可以看路况抄近路，出租车司机的路由表是随时更新的。动态路由的最大特点是路由器上运行路由协议，使路由器可以自动根据网络拓扑的变化调整路由条目。</p><p>动态路由的工作方式：第一步，路由器获得全网的拓扑，包含了所有路由器和路由器之间的链路信息，拓扑就是地图。</p><p>第二步，路由器在拓扑中计算出到达目的地网址的最优路径。</p><h4 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h4><p>优点：静态路由：简单、高效、可靠、网络安全、转发效率高。</p><p>​            动态路由：灵活，能够适应网络结构的变化，无需管理员手工维护，减轻了管理员的工作负担。</p><p>缺点：静态路由：不能灵活的适应网络动态变化</p><p>​            动态路由：占用网络带宽。（用于传输路由更新信息）</p><p>使用场景：静态路由：网络规模不大，拓扑结构固定的网络中。</p><p>​                     动态路由：网络规模大，网络拓扑机构复杂的网络。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web_Developer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gogee_Day1 HTTP基礎・APIの構築</title>
    <link href="/2022/03/08/Gogee-Day1-HTTP%E5%9F%BA%E7%A4%8E%E3%83%BBAPI%E3%81%AE%E6%A7%8B%E7%AF%89/"/>
    <url>/2022/03/08/Gogee-Day1-HTTP%E5%9F%BA%E7%A4%8E%E3%83%BBAPI%E3%81%AE%E6%A7%8B%E7%AF%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Goでウェブサービスを動かす"><a href="#Goでウェブサービスを動かす" class="headerlink" title="Goでウェブサービスを動かす"></a>Goでウェブサービスを動かす</h3><p>注：本文仅为个人学习笔记，无任何版权。</p><p>Go语言内置了<code>net/http</code>库，并且封装了http网络编程的基础接口。这样我们可以很便利的实现web接入。Gogee也是基于<code>net/http</code>的框架。举个例子：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"log"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br><span class="hljs-comment">// set 2 route- "/" and "/hello"</span><br>http.HandleFunc(<span class="hljs-string">"/"</span>, indexHandler)<br>http.HandleFunc(<span class="hljs-string">"/hello"</span>, helloHandler)<br><span class="hljs-comment">// launch web service</span><br><span class="hljs-comment">// :9999 : address AT 9999 port</span><br><span class="hljs-comment">// nil : solve instance by Standard library</span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">":9999"</span>, <span class="hljs-literal">nil</span>))<br>}<br><br><span class="hljs-comment">//handler echoes r.URL.Path</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">indexHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {<br>fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)<br>}<br><br><span class="hljs-comment">//handler echoes r.URL.Header</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header {<br>fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p>![截屏2022-03-08 11.44.50](Gogee-Day1-HTTP基礎・APIの構築/截屏2022-03-08 11.44.50.png)</p><h3 id="http-handler-API-の実現"><a href="#http-handler-API-の実現" class="headerlink" title="http.handler API の実現"></a>http.handler API の実現</h3><p>handler是什么呢？查看一下<code>net/http</code>的源码。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> http<br><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> {<br>  ServeHTTP(w ResponseWriter, r *Request)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-type">string</span>, h Handler)</span></span><span class="hljs-type">error</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Handler```是一个API，要求需要实现方法ServeHTTP，只要传入任何实现了ServeHTTP接口的实例，所有的HTTP请求就都交给该实例处理了。"><br>#### ServeHTTPとは<br><br>在Golang中，你要构建一个web服务，必然要用到```http.ListenAndServe```<br><br>对于```ListenAndServe```来说，他的方法签名为```http.ListenAndServe(address, handler)```<br><br>所以，如果想要用```ListenAndServe``` 两种方式。<br><br>1. 自己定一个struct，并在上面实现```ServeHTTP```方法。<br><br>   ```go<br>   type myhandler int<br>   <br>   func(m myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request){<br>     -, err := fmt.Fprintln(w, "hello this is golang ServeHTTP")<br>     if err != nil{<br>       fmt.Println("the error occured:", err)<br>     }else{<br>       fmt.Println("someone is accessing:" r.Method)<br>     }<br>   }<br>   <br>   func main(){<br>     var hello myHandler<br>     fmt.println("begin to listen")<br>     http.ListenAndServe(":9999", hello)<br>   }<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><p>使用nil作为handler。</p><p>nil在golang的http包下的server.go文件中有过定义。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span>{<br>handler = DefaultServeMux<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看到在ListenAndServe中传入nil，本质上就是在调用DefaultServeMux</p></li></ol><p>所以，利用ListenAndServe的第一个特点，我们可以构建自己的struct<code>engine</code>，并在上面实现<code>Serve HTTP</code>。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"log"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-comment">// Engine is the uni handler for all requests</span><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span>{}<br><br><span class="hljs-comment">// ResponseWriter: create the response of this HTTP request.</span><br><span class="hljs-comment">// http.Request: all the information of this HTTP request. For example, the address, Header and Body</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request){<br><span class="hljs-keyword">switch</span> req.URL.Path{<br><span class="hljs-keyword">case</span> <span class="hljs-string">"/"</span>:<br>fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)<br><span class="hljs-keyword">case</span> <span class="hljs-string">"/hello"</span>:<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header{<br>fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)<br>}<br><span class="hljs-keyword">default</span>:<br>fmt.Fprintf(w, <span class="hljs-string">"404 NOT FOUND: %s\n"</span>, req.URL)<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br><br><span class="hljs-comment">// Transfer all the request to our own solution.</span><br>engine := <span class="hljs-built_in">new</span>(Engine)<br><span class="hljs-comment">// launch web service</span><br><span class="hljs-comment">// :9999 : address AT 9999 port</span><br><span class="hljs-comment">// </span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">":9999"</span>, engine))<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>在实现了engine之后，我们拦截了所有的HTTP请求，拥有了统一的控制入口，并且可以自由定义这些请求的路由映射的规则，或者统一处理他们。到这里我们就可以发现我们走出了实现web框架的第一步。</p><h3 id="Gogeeフレームワークの骨組み"><a href="#Gogeeフレームワークの骨組み" class="headerlink" title="Gogeeフレームワークの骨組み"></a>Gogeeフレームワークの骨組み</h3><p>我们所设想的框架目录结构是这样的。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">Gogee/<br>   |--Gogee.<span class="hljs-keyword">go</span><br>   |--<span class="hljs-keyword">go</span>.mod<br>main.<span class="hljs-keyword">go</span><br><span class="hljs-keyword">go</span>.mod<br></code></pre></td></tr></tbody></table></figure><p>把Gogee与main分开放两个文件夹的原因是 Go语言的package对于每个文件夹有且只能有一个，所以Gogee的package和main的package重复了</p><h4 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h4><p>借用go module来管理依赖</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">module Gogee<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.17</span><br><br>require Gogee v0<span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><br><span class="hljs-comment">// Reference relative path</span><br>replace Gogee =&gt; ./Gogee<br></code></pre></td></tr></tbody></table></figure><p>用<code>replace</code>将Gogee指向 <code>./Gogee</code></p><h4 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"net/http"</span><br><br><span class="hljs-string">"Gogee"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>r := Gogee.New()<br>r.GET(<span class="hljs-string">"/"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {<br>fmt.Fprintf(w, <span class="hljs-string">"URL.Path = %q\n"</span>, req.URL.Path)<br>})<br><br>r.GET(<span class="hljs-string">"/hello"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> {<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header {<br>fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)<br>}<br>})<br><br>r.Run(<span class="hljs-string">":9999"</span>)<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>使用<code>New()</code>创建Gogee的实例，使用<code>GET()</code>添加路由，最后使用<code>Run()</code>启动Web服务。（目前只是静态路由）</p><h4 id="Gogee-go"><a href="#Gogee-go" class="headerlink" title="Gogee.go"></a>Gogee.go</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> Gogee<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"net/http"</span><br>)<br><br><span class="hljs-comment">// HandlerFunc defines the request handler used by Gogee</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span><br><br><span class="hljs-comment">// Engine implement the interface of ServeHTTP</span><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span>{<br>router <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>}<br><br><span class="hljs-comment">// New is the constructor of Gogee.Engine</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine{<br><span class="hljs-keyword">return</span> &amp;Engine{router: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc)}<br>}<br><br><span class="hljs-comment">// addRoute is the way to add something to route</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc){<br>key := method + <span class="hljs-string">"-"</span> + pattern<br>engine.router[key] = handler<br>}<br><br><span class="hljs-comment">// GET defines the method to add GET request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc){<br>engine.addRoute(<span class="hljs-string">"GET"</span>, pattern, handler)<br>}<br><br><span class="hljs-comment">//POST defines the method to POST request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc){<br>engine.addRoute(<span class="hljs-string">"POST"</span>, pattern, handler)<br>}<br><br><span class="hljs-comment">//Run definesd the method to start a http server</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>){<br><span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>}<br><br><span class="hljs-comment">// To use the ListenAndServe, we need to set a ServeHTTP struct</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) {<br>key := req.Method + <span class="hljs-string">"-"</span> + req.URL.Path<br><span class="hljs-keyword">if</span> handler, ok := engine.router[key]; ok {<br>handler(w, req)<br>} <span class="hljs-keyword">else</span> {<br>w.WriteHeader(http.StatusNotFound)<br>fmt.Fprintf(w, <span class="hljs-string">"404 MOT FOUND: %s\n"</span>, req.URL)<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p>首先定义了type <code>HandlerFunc</code>，这是提供给框架用户的，用来定义路由映射的处理方法。</p><p>我们在<code>Engine</code>中，添加了一张路由映射表<code>router</code>， key由请求方法与静态路由地址构成，比如<code>GET-/</code>、<code>GET-/hello</code>、<code>POST-/hello</code>，这样针对相同的路由，如果请求的方式不同，可以映射不同的Handler</p><p>当用户调用<code>(*Engine).GET()</code>方法时，会将路由和处理方法注册到router中（addroute方法）。<code>(*Engine).Run()</code>方法，是ListenAndServe的封装。</p><p><code>Engine</code>实现的ServeHTTP方法的作用是解析请求的路径，查找router，如果查到，执行注册的处理方法，如果查不到，返回404 NOT FOUND。</p><p>执行<code>go run main.go</code>再用<code>curl</code>访问即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GoでWebフレームワークを書く</title>
    <link href="/2022/03/08/Go%E3%81%A7Web%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%92%E6%9B%B8%E3%81%8F/"/>
    <url>/2022/03/08/Go%E3%81%A7Web%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%92%E6%9B%B8%E3%81%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Goを使ってWebフレームワークを作りましょう"><a href="#Goを使ってWebフレームワークを作りましょう" class="headerlink" title="Goを使ってWebフレームワークを作りましょう"></a>Goを使ってWebフレームワークを作りましょう</h1><p>最近Go言語には興味があり、GoでWebサービスを構築できるようになるために、GinのWebフレームワークを学んでいます。Ginの特性は深く理解できるのため、Goで自分のWebフレームワークを作ってみようと思います。「Gogee」と言います。GogeeのコードはGinのソースコードを研究して得たもので、あくまで学習用として使用しています。</p><h2 id="カタログ"><a href="#カタログ" class="headerlink" title="カタログ"></a>カタログ</h2><p><a href="https://xiaogeamadeus.github.io/2022/03/08/Gogee-Day1-HTTP%E5%9F%BA%E7%A4%8E%E3%83%BBAPI%E3%81%AE%E6%A7%8B%E7%AF%89/">DAY 1：HTTP基礎・APIの構築</a></p><p><a href="https://xiaogeamadeus.github.io/2022/03/09/Gogee-Day2-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88/">DAY 2：コンテキスト</a></p><p><a href="https://xiaogeamadeus.github.io/2022/03/14/Gogee-Day3-Trie%E6%9C%A8%E3%83%AB%E3%83%BC%E3%82%BF/">DAY 3：Trie木ルータ</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Project-Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map &amp; Collection</title>
    <link href="/2022/03/01/Map-Collection/"/>
    <url>/2022/03/01/Map-Collection/</url>
    
    <content type="html"><![CDATA[<p>　この記事は、日本語やプログラミングスキルを向上するために書きました。著者は中国出身ですから、言語、文法のミスがいっぱいあるかもしれない…</p><p>注：本文仅为个人学习笔记，无任何版权。</p><h1 id="Map-と-Collection-のまとめ（自分用）"><a href="#Map-と-Collection-のまとめ（自分用）" class="headerlink" title="Map と Collection のまとめ（自分用）"></a>Map と Collection のまとめ（自分用）</h1><p>一种优化查询时间的常用方法 ——Map。</p><p>预处理线性，查询时间为对数。</p><p>Map：成对的元素，每个元素由键与值构成。</p><p><code>&lt;index, value&gt;</code></p><p>Collection：孤立的元素，只包含元素的值。</p><p><code>&lt;value&gt;</code></p><p><strong>注意： Map中的值可以重复，但键不允许重复。</strong></p><p>常用的Map集合：HashMap/ LinkedHashMap</p><h4 id="HashMap-方法"><a href="#HashMap-方法" class="headerlink" title="HashMap 方法"></a>HashMap 方法</h4><p>HashMap&lt;k, v&gt; 采用哈希表结构存储数据，元素的存取顺序不能保证是一致的</p><h4 id="LinkedHashMap-方法"><a href="#LinkedHashMap-方法" class="headerlink" title="LinkedHashMap 方法"></a>LinkedHashMap 方法</h4><p>LinkedHashMap&lt;k, v&gt; 采用哈希表+链表结构存储数据，可以保证元素的存取顺序一致</p><h2 id="Map结构的API"><a href="#Map结构的API" class="headerlink" title="Map结构的API"></a>Map结构的API</h2><p>get(Object k)：返回指定键所映射的值</p><p>put(key k, value v)：将值与映射中的键关联</p><p>remove(Object k)：如果存在一个键为k的映射关系，将其删除</p><p>clear()：删除Map中所有键/值对</p><h2 id="Map集合遍历键找值方式"><a href="#Map集合遍历键找值方式" class="headerlink" title="Map集合遍历键找值方式"></a>Map集合遍历键找值方式</h2><h2 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a>Map集合遍历键值对方式</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS Solutions Architect Associate C02</title>
    <link href="/2022/02/26/AWS-Solutions-Architect-Associate-C02/"/>
    <url>/2022/02/26/AWS-Solutions-Architect-Associate-C02/</url>
    
    <content type="html"><![CDATA[<p>　この記事は、AWS-SAAC02に関連するレビューの概要を記録しました。 英語試験を選択したため、英語/中国語で書きました。</p><h1 id="AWS-Solutions-Architect-Associate-C02"><a href="#AWS-Solutions-Architect-Associate-C02" class="headerlink" title="AWS Solutions Architect Associate C02"></a>AWS Solutions Architect Associate C02</h1><p>At the beginning, please remember that you’re a architect associate. So you just need to know how to construct <strong>scalable, highly available, cost-effective, secure, performant, resilient</strong> AWS structure. </p><h2 id="About-test"><a href="#About-test" class="headerlink" title="About test"></a>About test</h2><p><strong>170 min</strong> (If you aren’t a native speaker of English, the AWS will offer you extra time)</p><p><strong>65 questions</strong> (15 questions without points)</p><p><strong>1000 points</strong> (you need to gain more than 720 points to pass the exam)</p><p>From the exam guide, we can find that there is <strong>4 domains</strong> of AWS-SAA:</p><p>​      <strong>Domain 1:</strong> Design Resilient Architectures                              30%</p><p>​      <strong>Domain 2:</strong> Design High-performing Architectures               28%</p><p>​      <strong>Domain 3:</strong> Design Secure Applications and Architectures  24%</p><p>​      <strong>Domain 4:</strong> Design Cost-Optimized Architectures                 18%</p><h2 id="Overviews"><a href="#Overviews" class="headerlink" title="Overviews"></a>Overviews</h2><p>I divided the AWS for some parts: Compute, Storage, Network, Database, Security, Tools, Contains and Others.</p><p>​    <strong>Compute:</strong>   EC2, Elastic Beanstalk, Lambda</p><p>​    <strong>Storage:</strong>      EBS, EFS, S3, FsX, instance store, Glacier, Storage gateway</p><p>​    <strong>Network:</strong>     VPC, Route53, ELB</p><p>​    <strong>Database:</strong>   RDS, DynamoDB, Redshift, Elastic Cache, Aurora, Athena</p><p>​    <strong>Security:</strong>      IAM, plenty of Security Groups</p><p>​    <strong>Tools:</strong>          Cloud Watch</p><p>​    <strong>Contains:</strong>    ECS/EKS</p><p>​    <strong>Others:</strong>  </p><h3 id="Compute"><a href="#Compute" class="headerlink" title="Compute"></a>Compute</h3><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><h3 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h3><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3>]]></content>
    
    
    
    <tags>
      
      <tag>AWS-SAAC02</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全探索</title>
    <link href="/2022/02/26/%E5%85%A8%E6%8E%A2%E7%B4%A2/"/>
    <url>/2022/02/26/%E5%85%A8%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>　この記事は、日本語やプログラミングスキルを向上するために書きました。著者は中国出身ですから、言語、文法のミスがいっぱいあるかもしれない…</p><h1 id="全探索のまとめ（自分用）"><a href="#全探索のまとめ（自分用）" class="headerlink" title="全探索のまとめ（自分用）"></a>全探索のまとめ（自分用）</h1><p>　全探索とは、中国語”暴力解法”と言います。多分計算量や時間複雑性はすごく高い、アルゴリズム全然使えない方法です。全探索を選択する前、必ずTime Complexityを確認してください。（P.S. 競プロについて、計算量は 10^8 ~ 10^9 回数のループを越えれば、ACはできません）</p><p>　<strong>ビット全探索と順列全探索は別のものです！普通の問題に対して、データが10個以下の場合は順列全探索を、20個以下の場合はビット全探索を使えます。</strong></p><p>　普段な全探索は、四つの種類があります：</p><ol><li>本当に　”全部を調べる”　の全探索</li><li>なるべく探索の数を減らすの全探索</li><li>ビット全探索</li><li>順列全探索</li></ol><h2 id="本当に”全部を調べる”-の全探索"><a href="#本当に”全部を調べる”-の全探索" class="headerlink" title="本当に”全部を調べる” の全探索"></a>本当に”全部を調べる” の全探索</h2><p>　それは普通です、普通のfor/whileループを使って（二層ループの場合もある）コードを書くだけです。</p><p>例：ABC144B、ABC150B、ABC122B、ABC136B、ABC106B、ABC120B</p><p>（ABCに対してレベルBの感じ）</p><h2 id="なるべく探索の数を減らすの全探索"><a href="#なるべく探索の数を減らすの全探索" class="headerlink" title="なるべく探索の数を減らすの全探索"></a>なるべく探索の数を減らすの全探索</h2><p>　”全部を調べる”の全探索より探索数を減らす方法です。今僕を書いた問題は代々”全部を調べる”ことはできないの場合（TLE、ループ回数を超える）、そいよう方法を考えようと思っています。</p><p>　多分探索したのことを二度と探索しないのために、順列やハッシュなどのデータ構造を使って探索したことを記録します。</p><p>例：ABC057C、ABC095C、三井住友信託銀行プログラミングコンテスト2019 D - Lucky PIN</p><p>（ABCに対して簡単なレベルCの感じ）</p><h2 id="ビット全探索"><a href="#ビット全探索" class="headerlink" title="ビット全探索"></a>ビット全探索</h2><p>　初めて知りましたの全探索の種類、ブログ記事に勉強しています。代々みんなはCPPを使って競プロをやります（プログラミング速度を上がくため）。僕はJavaやPythonを使った場合が多いので、多分CPPを練習しようと思っています。</p><p>　ビット全探索とは、二進数とビットを用いて、ある集合の部分集合を全列挙（全探索）するアルゴリズムのこと。</p><p>基礎（Javaに対して）：</p><ol><li><p>i &gt;&gt; j：iの桁をjビット右シフトする</p><p>例１：6 &gt;&gt; 3</p><p>　0000 0000 0000 1010（6）右シフト3</p><p>　結果：0000 0000 0000 0001（1）</p></li></ol><p>　　例２：-92 &gt;&gt; 2</p><p>　　　1111 1111 1111 1111 1111 1111 1010 0100</p><p>​        　0011 1111 1111 1111 1111 1111 1110 1001（1073741801）</p><ol start="2"><li>&amp;：論理積。左右双方の式にセットされているビット。対応するビットが両方とも1の場合，結果は1，それ以外の場合は0となる。</li></ol><p>　　例１：0011 1100 &amp; 0000 1101</p><p>　　　0011 1100 (60)</p><p>​            0000 1101 (13)</p><p>　　　結果：0000 1100 (12)</p><p>ビット全探索コード例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs java">String[] ar = {<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>};<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;(Math.pow(<span class="hljs-number">2</span>,n)); i++) {<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">"-"</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++) {<br><span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span>&amp;i&gt;&gt;j) == <span class="hljs-number">1</span>) {s += ar[j];}<br>}<br>System.out.println(s);<br>}<br></code></pre></td></tr></tbody></table></figure><p>入力：String {a, b, c}</p><p>出力：-a, -b, -ab, -c, -ac, -bc, -abc </p><p>例：ABC128C、ABC147C</p><h2 id="順列全探索"><a href="#順列全探索" class="headerlink" title="順列全探索"></a>順列全探索</h2><p>　順列全探索とは、決まった数字や文字の列の全ての順列を出力します。時間複雑性はN!ですから、普通は10以下のことを計算すると思います。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Road to Kyoto University</title>
    <link href="/2022/02/24/Road-to-Kyoto-University-1/"/>
    <url>/2022/02/24/Road-to-Kyoto-University-1/</url>
    
    <content type="html"><![CDATA[<p>This essay is in honor of one of the most courageous moments of my life.</p><p>この記事は、短い人生で一つ最も勇気を持ている瞬間を記録するために書いたものです。</p><h1 id="京都大学大学院社会情报学修士夏入试经验分享"><a href="#京都大学大学院社会情报学修士夏入试经验分享" class="headerlink" title="京都大学大学院社会情报学修士夏入试经验分享"></a>京都大学大学院社会情报学修士夏入试经验分享</h1><p>在人生最动荡不安的一段时间，我独身一人来到疫情下的东京，最终合格了第一志愿的京都大学。趁着热忱与记忆还未模糊，决定先将我的备考历程写下，希望能够给正在准备中的你提供微不足道的帮助。</p><h2 id="0-はじめに"><a href="#0-はじめに" class="headerlink" title="0 はじめに"></a>0 はじめに</h2><p>如果要给京大社会情报学修士备考定下一个基调，那么应当是“情报战”。</p><p>作为外国人的我们，想要在京大学部生与日本外部生环绕下撕下一个合格名额，那在情报上就要努力与他们站在同一起跑线。我是有些database属性的人，我坚信收集的情报越多，上岸的可能性就越高。</p><p>为了收集“情报”，我基本反复看过十遍全网所有的社情经验贴（中文/日文）；潜入了一个上岸日本人组建的社情备考slack组，享受了他们分享的google drive材料；推特上找曾经上岸的日本人私聊；最终找到了适合我的备考路。（P.S.1 这一点可能仅适合于京大社情）（P.S.2 今年确实有我所知的因为情报收集不到位而落的朋友）(P.S.3 更多情报可以参考我的收藏夹中“日本留学”部分)</p><p>除此之外，与中文环境下的朋友交流是获得“情报”最快的方式。闭门造车不可取，你是清北佬当我没说。请牢记我们的敌人是日本考生，而不是与中国人自己恶意内卷。共同交流绝对优于隐瞒信息。</p><p>或许我这篇文章可以提供足够的“情报”给你，但我仍然希望你重走一遍我的这条路，至少应当看过所有已存在的经验贴吧。之后我会将链接放到文末。</p><p>我人生的信条是要么不做，要么全力以赴。恰好和数据库事务的Atomicity碰上了。所以：</p><p>本篇经验贴只适合给对日本修士备考有基础了解，有良好的信息收集能力和抗逆能力的同学。我宁可多在这里废话几句也不会给那些随便查一下就明白的基础知识提一个字，如果你向我提问的问题让我觉得你完全没有认真做信息收集的话，我不会回应的。但除此之外的问题我都会认真回答。</p><p>另，出售个人备考所写的过去问答案，同时可以提供京大社情辅导，有意者私聊。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>出身校：北京某双非一本/二本（因地区而异）<br>GPA：2.7/5.0<br>专业：自动化<br>科研经历：很水的三作以及更水的一作<br>TOEIC：810<br>日语：语言学校在读，无日语成绩，可以与日本教授完成日常对话级别。<br>以我个人观点来看，以上的所有背景，唯一会对你的考试造成影响的就是英语成绩。英语成绩将换算进入笔试总成绩，对于社情来说，英语占比总成绩的1/4，毫无疑问是决定性的项目。</p><h2 id="2-备考历程"><a href="#2-备考历程" class="headerlink" title="2 备考历程"></a>2 备考历程</h2><p>以下按照时间顺序复述我从开始准备日本修士考试的备考历程。</p><p>2019.3 申请语言学校 2020年7月生<br>2019.7 裸考N2 不合格<br>2019.12 裸考托福 49<br>2020.1 进入某航道培训托福<br>2020.2 托福取消<br>2020.3 托福取消<br>2020.3 日本封国<br>2020.5 托业 625<br>2020.7 早大综合机械工学 落<br>2020.8 进入某日语培训机构锻炼日语<br>2020.9 托业 740<br>2020.10 菅义伟 我滴超人 宣布日本开门<br>2020.11 第一时间进入日本隔离<br>2021.1 疫情扩大 日本重新关门<br>2021.1 京都大学智能情报学 書類落ち<br>2021.1 东京大学情报学环 先端情报 書類落ち<br>2021.3 托业 700<br>2021.3 东京都立大学 横滨国立大学 筑波大学考试内诺一个没陶瓷到<br>2021.3 拿到早大考试内诺，拿到名大考试内诺，拿到保底的立命馆大学考试内诺<br>2021.4 托业 810<br>2021.5 京大社情说明会<br>2021.7 早大综合机械工学 弃考<br>2021.8 名大智能情报学 弃考<br>2021.8 立命馆大学人间情报专攻 弃考<br>2021.8 京大社会情报学 合格<br>可以看到基本是充斥着失败的两年呢（笑）。可以看到defer一年第二年四月才拿到差不多的英语成绩的我依然合格了，事实证明什么时候准备都不晚（bushi）。</p><p>由于此篇经验贴为京大社情相关，其他学校的备考过程略过，以下仅阐述京大社情的备考履历。（P.S.从今时今日的角度来看，因为摸石头过河，我的复习期间仍然有部分决策失误，所幸并没有造成什么后果，所以备考履历仅供参考，对大家的复习建议我会放在后面）</p><p>2021年2月，东大学环/京大智能冬入被书类直接鲨掉，我发现以我的背景，只要有书类就一定见不到卷子。痛定思痛之下，决定抛弃东大与京大智能。京大系统需要托福，京大数理难度太高，京大通信不想做硬件，所以将目光聚焦到了京大社情。正好京大社情存在2018年刚刚到来的人机交互世界TOP5神田教授，我决定将2021年夏天的主攻目标放在京大社情神田教授的HRI研究室。</p><p>然后看了教授的几十篇论文，写了一篇现在的我看来糟糕的不行的rp去陶瓷了，果不其然石沉大海。实际上想要获得神田老师的邮件回复是要看运气的，对于他来说每天的未知邮件数量太大了。</p><p>不过京大是为数不多不需要内诺就可以进行考试的学校之一，总而言之复习的道路就这么开始了。</p><p>自此开始全网查找京大社情相关的经验贴，并且在上面的交流群中找到了几位去年上岸的学长。跟他们交流之后决定了自己主要复习的专业课。</p><p>在这个时间，自觉自己的托业成绩远远不够，遂连续报名了三月和四月的托业考试，最后拿到了个勉强够用的810。在这个期间也一直在陶瓷保底的学校，因为我已经无法承担再来一年的后果了。家里能够支持，签证时间也不够了。BTW，社情的所有考试科目我在本科都完全没有接触过，所以我的专业课复习分为三轮，第一轮是预习，然后还有二轮复习与三轮复习。</p><p>三月开始进行数据库的一轮预习，复习的是一个磨磨叽叽，这期间还把RNG的春季赛皇马的联赛欧冠一场不落的看完了，属实十分拉垮。</p><p>四月在复习数据库的基础上花了一个下午总结了人机交互的过去问，发现了考题无限重复，一轮预习直接结束。</p><p>五月参加了京大情报研究科的说明会，在说明会上与神田老师对线了十几个问题，发现神田老师和我想象的一样，是一个温柔的人，他真的是我梦想的老师。</p><p>参加完说明会后，自觉之前的研究计划书水平太低，遂花两周时间毙掉了无数个idea，憋出一篇新的rp，然后光荣的再次没有收到回复。同时预订了去京都的民宿和新干线，选到了我认为京大周边对于备考生来说最好的民宿。</p><p>六月，出愿月，将我四页A4纸的rp缩减到两页，作为了Statement of Objectives而提出。并且完成了数据库的一轮预习，写完了近几年的过去问，开始信息检索的一轮预习。</p><p>7月1日，信息检索一轮完成并写完了过去问，看了几天算法和机器学习，机器学习太难了放弃了。同时想了想早大不想复习了直接弃考。</p><p>7月2日-7月10日，总结基础的《Computer Science: an Overview》大概总结了40页左右。</p><p>7月11日-7月14日，database二轮复习，人机交互过去问背诵</p><p>7月15日-7月17日，信息检索二轮复习，人机交互过去问背诵</p><p>7月18日-7月20日，基础二轮复习，写完了近几年的基础过去问。</p><p>7月21日-7月26日，将之前写过的过去问二轮了一遍，</p><p>7月27日-7月30日，最后将三门课三轮复习，每天晚上看一遍基础的书，写过的过去问反复看。</p><img src="/2022/02/24/Road-to-Kyoto-University-1/Calander.jpg" class="" title="[Calander]"><h2 id="3-复习建议"><a href="#3-复习建议" class="headerlink" title="3 复习建议"></a>3 复习建议</h2><p>这个小节就是这篇文章的重头戏了。我将详细介绍京大社情考什么，以及每门课怎么复习，重点在哪里。</p><p>京大社情的院试总共分为三部分。情报学基础，专业课以及面试。分数配比是情报学基础150分，专业课300分，英语成绩150分，面试100分。但实际上，和其他学长所说的一样，面试的排位基本可以决定你的最终结果，所以说前面的600分至关重要。</p><p>在复习建议的最开始，我建议转专业的同学一定要从情报学基础开始。当你把情报学基础复习完成之后，数据库和信息检索的很多知识点就迎刃而解了。比如deadlock/B+树/pagerank我也是在复习完全部才发现了这一点。之前看到日本人的经验贴这么写，我还没有理解…</p><h3 id="情报学基础"><a href="#情报学基础" class="headerlink" title="情报学基础"></a>情报学基础</h3><p>我个人推荐如果希望用英语答题，就用英文版与中文版来复习。如果希望用日语答题，就用日文版和中文版来复习。这本书的章末习题答案很不好找，只有一版英文版。另，第十版和第十一版都可以使用，京大官网给出了对于募集要项的修改。</p><p>情报学基础就是将这一本概论性的书籍上的所有东西都考一遍，除了第十章。看着很唬人，实际上总结往年过去问你就能发现，他考的章节是有限的。实际上只聚焦在了：</p><p>第一章 数据存储<br>第二章 数据操控<br>第三章 OS<br>第四章 计算机网络<br>第五章+第六章 算法<br>第八章 数据结构<br>第十二章 计算理论<br>这七个部分当中。每年老师会从这七个部分当中抽选五个出题，然后考生可以从这五个中选择三个进行回答，每道题50分。</p><p>看起来仍然很头大？没关系，我帮你进一步缩减范围。</p><p>21.8考了1 2 4 5 8章</p><p>21.2考了1 3 5 8 12章</p><p>20.8考了2 3 4 5 8章</p><p>20.2考了1 2 4 5 12章…</p><p>找到规律了吗？</p><p>任意两次相邻的考试，会将总共七个部分考全，同时第五章的算法每次考试必出。</p><p>所以我可以站在这里预测，22.2的社情考试情报学基础将会出OS，算法以及计算理论。剩下两个就不知道了。</p><p>所以理论上来讲，你如果能保证这三章能拿到满分，你可以只看三章的内容就可以了。不过我认为还是把这七章老老实实看完吧。</p><p>至于怎么复习？所有，所有的课后题以及章末习题全部做一遍。我今年甚至是在全部做一遍的情况下还吃了亏….可以预见性的是今后将越来越难越来越刁钻。只能说祝你好运吧！</p><p>P.S.1 过去问有一定可能会重复出，但每年绝对会出大量的新题，所以过去问必须全要会，书上的习题也必须全要会。一般情况下往年的上岸选手都是140/150左右，即底线是错一个小问，但我今年应该是拉垮了。</p><p>P.S.2 算法的出题思路从20.8开始转变，老师们开始出课后题的新算法，完全不拘泥于之前的基础算法，算法白给分的好时代已经过去了！</p><h3 id="专业课（所有计算机科学题目中选3）"><a href="#专业课（所有计算机科学题目中选3）" class="headerlink" title="专业课（所有计算机科学题目中选3）"></a>专业课（所有计算机科学题目中选3）</h3><p>社情是有不少其他方向的专攻的，但完全是黑箱，录取条件复习方法完全不明白。所以我仅在这里讨论计算机科学方向的备考。</p><p>对于计算机科学，社情共有六个研究室。</p><p>社1 吉川/马研究室，数据库/数据挖掘<br>社2 HRI研究室（神田），人机交互<br>社3 田岛研究室，信息检索<br>社5 伊藤研究室，multiagent，人工智能<br>社6 阿部研究室，密码学<br>社14 緒方研究室，教育工学<br>可以看到，社情的专业课基本上对应了社情这几位教授的专业方向。当然研究室的录取跟你选择不选择对应的题目没有任何关系，毕竟没选不一定代表你不会这个）</p><p>目前看下来，目前的出题风向是每年必出的题从原来的四道变成了五道（人机交互、数据库、信息检索、算法、人工智能），算法加入了必出菜单。同时机器学习逐渐淡出出题部分，往年没怎么见过的奇怪题目每年都在增加【21.2的数据挖掘（马强老师）、multiagents（伊藤老师）；21.8的计算机网络，以及非常偏向密码学的算法（阿部老师）】奇怪题目无法准备，建议直接无视。（另，奇怪题目暗示了大概21.2 这两个实验室人没收够所以他们出了题）</p><p>对于我个人来说，这五门课的难度是人机交互&lt;数据库&lt;信息检索&lt;算法&lt;人工智能</p><p>由于我只复习了前三个最简单的，所以我只会给出详细的前三门课的复习方法，后三门建议看一下其他上岸佬的经验贴。</p><h4 id="1-人机交互"><a href="#1-人机交互" class="headerlink" title="1. 人机交互"></a>1. 人机交互</h4><p>京大本科所用书籍如下：Interaction Design: Beyond Human-Computer Interaction 注意是第三版。</p><p>中文版只有第四版，实际上区别不大，可以使用，但有不同的地方还是以第三版为主。</p><p>这门课正如上岸佬所言，简单粗暴的背就可以了。虽然往年也会出新题，但据我观察新题一般出现在冬天试水，夏天一般很少出现新…..</p><p>21.8 出题老师：你再说一遍？</p><p>喜闻乐见的，只准备了底线三道题的我碰到了出了新题的人机交互，我当即就是一个寄。</p><p>所以，这道题就是在赌命。如果出了新题，大部分人就直接寄了。得亏今年的新题出的还能编一编。</p><p>当然这门课还有更靠谱的复习方式，“你可以每天晚上当故事书看一看。”这是一位上岸佬教我的，这…..我……</p><p>简单罗列一下往年所出的题。这本书其实全篇就是在教你如何构建一个interface/product。历史考过的题有7道，今年新题一道，总共8道题。</p><p>开始设计：1. 诺曼6原则（针对交互设计）2. 6个可用性目标（可以被人使用）</p><p>如何设计：3. 选择合适界面（12个UI类型）4. 收集数据（收集数据的6个方法以及优缺点）5. 收集数据2（线上调查问卷的优缺点）6. 交互设计的过程（远程合作系统设计4步骤）</p><p>产品评价：7. 十大可用性原则（用于评价设计好坏）8. 对比十大可用性原则与诺曼6原则，写出不同点和相同点（21.8新题）。</p><p>把这八道题背熟，然后就可以上考场赌命了，赌中就满分，赌错就不选，正所谓尽人事而知天命。</p><p>（P.S. 诺曼6原则书上少一个mapping，建议直接谷歌；12个UI书上不够，建议WIKI；远程合作系统4步骤书上也没有，建议自己写一个，大致是 establishing requirments, desiging alternatives, protoyping, evaluating 四个步骤。新题第8题书上也没有，建议自己总结，我考场上现编的）</p><h4 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. 数据库</h4><p>首先还是书籍介绍：：<a href="http://link.zhihu.com/?target=https://www.amazon.co.jp/Text-%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%AE%E5%9F%BA%E7%A4%8E-%E5%90%89%E5%B7%9D-%E6%AD%A3%E4%BF%8A/dp/4274223736/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;dchild=1&amp;keywords=IT+%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9&amp;qid=1628527578&amp;sr=8-1">IT Text データベースの基礎 | 吉川 正俊 |本 | 通販 | Amazon</a></p><p>这本是社1的吉川老师编写的教材，也是京大学部生所用的教材。</p><p>数据库可谓是我准备的最为完美的，最为自信的一门课了。我可以说我把这本书吃透了，不论他怎么考我都没问题可以拿到90/100 。</p><p>简单粗暴的总结一下，数据库其实是很有趣的一门课。这门课的课程核心在于教会学生们如何设计一个数据库，并利用这个数据库查询到其想要的data。</p><p>所以数据库的学习流程就是设计一个数据库的流程。</p><p>需求分析——利用自然语言对需求进行分析<br>概念数据库设计——将自然语言的需求转化为ER模型<br>逻辑数据库设计——将ER模型图转化为关系模型，选择DBMS（查询的部分包含在其中，关系代数、域/元组关系演算、SQL）<br>关系模式规范化——范式，分解法与合成法<br>物理数据库设计——考虑存储、负载与索引，最优化查询，file organization。<br>应用与安全设计——事务、并行控制、错误恢复<br>就这么简单，考点就这些了。只要你把这里的每一步都弄明白，你就可以完成过去问。</p><p>这道题的出题风格完全无法总结，所以建议拉满，不管怎么出都可以满分。</p><p>复习上来说，建议一轮复习以中文资料为主，二轮复习利用京大课本大纲查漏补缺，比如合成法中国学校的讲义一般不讲。还有一些日本和中国写法不同的地方也应当一一确认，比如ER图多对一情况下箭头的画法，比如范式分解时候的步骤等。</p><p>另：关系代数，关系演算以及SQL应当多刷题，中文教材推荐的第二本中的课后题非常优秀，我当初复习的时候是全做了一遍，基本可以达到京大考试要求。</p><p>其他的中文资料推荐：</p><h4 id="3-信息检索"><a href="#3-信息检索" class="headerlink" title="3. 信息检索"></a>3. 信息检索</h4><p>这门课非常小众，但实际上懂得门路复习起来简单的一，考试不就是背几个概念设计一个无向图/有向图…</p><p>田岛老师（我猜测的出题者）：？</p><p>然后 21.8 的考题出了四个图的设计…..在考场上有限时间下大脑一片空白真的设计不出来啊亲！在家设计好几个小时设计出来还觉得题很简单的笑歌是屑。</p><p>又差点给我送走。我最后蒙了四个上去，看面试排名感觉蒙的好像还蒙对了？不愧是我。</p><p>个人建议：建议复习，不建议只复习。这门课是我准备的三门中最难的，也是最吃数学的，需要一定的概率论基础（BIM/语言模型），图论基础（有向图无向图完全图），线性代数基础（线性空间模型/MVD）</p><p>困扰诸多考生最大的困难就是，复习起来真的无从下手。往年的学长们依靠中科院王斌老师的讲义也是无法做到完答的。不过我今年搞到了一份神秘资料，让我最后完成了完答。神秘资料是什么不能说，但我可以把里面的要点讲一讲。</p><p>这道题的出题风格基本上已经固定了。三小问，第一问一定是概念题，第二问第三问一定是一道Pagerank/HITS相关，一道复杂网络相关（scale free特性，小世界特性，cluster特性）具体可以见京大本科课程的大纲：</p><p>首先是第一道基础题，可以看到可能会考的基础范围很广泛，从HTML XML到kd木 再到信息检索模型、信息检索评价、相关反馈与查询扩展，但实际上，第一章第二章在社情考试改版之后已经再没有考过了，我和上岸佬猜测是因为其他地方考过了，反正我当初没有看第一章第二章的东西。</p><p>第三章，信息检索模型，重头戏。常考的信息检索模型有如下几个，一个个全弄明白。一般来说，针对一个信息检索模型，他的四元组要弄明白[D、Q、F、R(qi,dj)]。</p><p>D——文档集的表示<br>Q——查询集合的表示<br>F——模型框架<br>R——排序函数<br>除此之外，优缺点，VSM与BIM的相同点不同点，扩展布尔模型对布尔模型/vsm的提升都是常考点。</p><p>boolean model, fuzzy set model, extended boolean model, Vector space model(VSM), Binary independence model(BIM), Okapi BM25, Language model, Query likelihood, Latent semantic indexing(LSI).</p><p>第四章，信息检索评价。与上面一样，将每个评价标准搞明白就可以了，没什么好说的。</p><p>一般来说，信息检索中评价的东西只有三个：Efficiency/Effectiveness/Coverage，所以一个评价尺标的好坏一般是用这三个维度定义的。</p><p>precision, recall, F-measure/ Balanced F-measure, precision-recall curve, MAP, R-Precision, Precision@N, nDCG, MRR, ERR, MMR, 顺位相关系数</p><p>第五章，相关反馈与查询扩展，其实这个东西我直接放在信息检索模型里面一起复习了，虽然他不是信息检索模型，但目标也是帮助信息检索更加合适。</p><p>相关反馈分为显式相关反馈、隐式相关反馈以及伪相关反馈。其中针对VSM的rocchio算法往年也考过。</p><p>概念题大概就是上述的东西了，逃不出这个范围。</p><p>其次：Pagerank/HITS，两个都是基础算法了，网上有无限多的网页介绍。实在弄不清楚的就去看作者原论文，记得HITS一定要normalization）</p><p>最后：复杂网络，这道题国内的复习资料非常少，我只找到有限的几个博客。我大概总结一下神秘资料中的考点。</p><p>基础：图论，图的设计，图的类型总结（简单图，基础图，定向图，平凡图…..）随便找本图论的书看一下第一章就可以了。</p><p>scale free（无标度）<br>考点：节点的次数（degree），幂律分布，以及往年过去问考过的对于ck^-r的求积分然后分析期望E（k），这个是纯粹的数学推导。</p><ol start="2"><li>small world（小世界特性）</li></ol><p>主要考点：紧密中心性（closeness centrality）、间接中心性（betweenness centrality）</p><ol start="3"><li>cluster（社区结构特性）</li></ol><p>主要考点，顶点V的cluster性Ci</p><p>复杂网络是考试难点，出设计题时非常难顶，全看能不能想到了。所以不推荐只复习这一道。我在考场上觉得人工智能才是真滴好，后悔没复习人工智能。人工智能的稳定性要比信息检索好太多了。</p><p>最后，又到了我们最喜欢的考题预测环节。</p><p>我预测22.2信息检索基础题会选择某一个评价尺度拿出来考，因为前几年已经把信息检索模型考个差不多了，今年夏天我预测也成功了，考了MRR和MMR。</p><p>我预测22.2复杂网络那道题会考Ci的图形设计，和21.8的题会长得很像，因为往年2月的题都和8月的题是一个考点，只是细节上会稍作改动，因为老师也懒得编新题。。。</p><p>Pagerank和HITS无法预测，好好把矩阵的计算方式自己多推几个，祈祷考场上别出太难，这题吃理解。</p><p>最后的建议，最好复习四门课/五门课，最稳定的其实是数据库 人工智能和人机交互，信息检索稳定程度不高。算法我是菜鸡，题都看不懂，cs出身的朋友可能问题不大。</p><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>没什么好说的，TOEIC永远滴神，英语分数换算根据我收集到的数据大概如下，仅供参考：</p><p>托福82=115/150</p><p>托福90/托业810=133/150</p><p>托福95/托业835=141/150</p><p>在之前的多个经验贴中，有几位学长说英语成绩差不多就行，我斗胆提出这个观点是不够正确的，对于京大社情来说，一个好的英语成绩可以极大弥补你在笔试阶段的发挥失误。 学长们的笔试成绩很好，所以英语成绩只是锦上添花。而我今年的笔试成绩可以预见性的很糟糕，全靠托业救我于水火之中把我抬上岸了。所以，<strong>能刷高就刷高</strong>，850就是胜利！</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>社情的面试是由笔试成绩决定的，面试的排位就是笔试成绩的排名。一般来说上午面试的都能全员录取，就是去哪个志愿的问题了，进入上午面试的可以安心一些。下午面试的人，由于成绩不够有说服力，所以志愿填报和面试的表现就会成为决定录取与否的因素。</p><p>社情的面试没有那么多弯弯绕，老师需要在一天时间面试40+个学生，这是很浪费时间的。所以一般流程就是</p><ul><li>简短的自我介绍</li><li>2-3min做一个关于rp的pre（上面的5min是假的）</li><li>老师问1-2个rp的相关问题</li><li>第二志愿老师可能会询问，为什么选择我做第二志愿。</li></ul><p>一般情况下，当第二志愿老师这么问的时候，就代表他有一定兴趣捞你。这时候你的回答就很重要了。所以建议准备面试的时候也准备一下这个问题。</p><h2 id="4-合格分数分析"><a href="#4-合格分数分析" class="headerlink" title="4 合格分数分析"></a>4 合格分数分析</h2><p>目前手头收集了几套数据，众所周知京大社情的面试排序是笔试成绩的排序，所以可以大概看一下什么分数可以排到什么名次。以下分数为英语+基础+专业课。</p><p>141+145+251=537 19.8 排名第五</p><p>115+148+268=531 20.2 排名四月生第一</p><p>117+140+257=514 20.8 排名第十一</p><p>104+140+243=487 20.8 排名第二十</p><p>133+118+205=456 21.8 排名第二十五</p><p>以上人均合格了。</p><p>我猜测题的难度不会对分数线有太大的影响，题难老师会多给分，题简单老师会多扣分，控制分数线不会太大变动。一般来说，500分肯定能上岸了。英语多十分，你专业课/基础课就有多错两道题的余裕。</p><h2 id="5-套磁与志愿分析"><a href="#5-套磁与志愿分析" class="headerlink" title="5 套磁与志愿分析"></a>5 套磁与志愿分析</h2><p>不管第一志愿是社情的哪位老师，说明会都一定要参加，rp都一定要好好写，陶瓷一定要去套。</p><p>今年笔试第28落了，一个吉川老师的研究生落了（十月第二名），但一个笔试37名的合格了，这很明显问题出在志愿填报上。</p><p>社情有两个最热门的研，吉川研和神田研，当你把这两个研究室作为第一志愿和第二志愿，笔试分数还不够有决定性的情况下，你大概率是落榜。所以一般推荐搭配是吉川/神田第一志愿，其他四个中选择一个作为第二志愿。社情基本没有出现调剂到第三志愿的情况，所以第一志愿和第二志愿是最重要的。功利一点，上岸为王可以直接第一志愿阿部研（密码学），只要分够应该就能进，因为太冷门了。（另，社14的续方研在日本人之中很热门，我建议不要和吉川神田凑凑了，这个真说不好）当然，如果你心有所属，那就大胆的把第一志愿填上TA，完全没有问题。</p><p>我的笔试是第25名，很尴尬的名次，最终第一志愿神田研失败，调剂到了第二志愿的伊藤研。我的rp质量不错，面试表现也很好，只能说前面的第一志愿人把坑填满了，自己考的不好也没得说。</p><h2 id="6-考试过程"><a href="#6-考试过程" class="headerlink" title="6 考试过程"></a>6 考试过程</h2><p>7月30日，坐新干线抵达京都，入住京大旁边300m的民宿。和之前京大上岸还有一起备考的朋友一起吃饭。晚上再次刷了一遍基础书。</p><p>7月31日上午，提前到达考场并且买好了中午的面包，准备中午就在考场干到底了。BTW，8号馆的空调真的应该修一下，4号馆就凉凉快快一点问题没有。</p><p>10:00-12:00 情报学基础，从去年的出题特征就能看出老师们开始有意识的提升情报学基础的难度以获得区分度，但我怎么也没想到他能考出来不在那本书上的题目，猝不及防之下，我怀疑我情报学基础只拿到了125/150。今年的情报学基础出了第一章、第二章、第四章、第五章、第八章。最后我选择了第二章、第四章和第五章，第四章有两个知识点总结了没背会，编了上去，这是我的失误，望后人引以为戒。</p><p>12:00-13:00 一边啃面包一遍最后看一遍需要死记硬背的知识点，人机交互的考题我预测21.2刚出的新题21.8一定会再考，然后考前背了三遍，果然考了。</p><p>13:00-16:00 专业课，一开始人机交互，一看出了新题，心凉了一半。然后看了一眼算法，发现连题都看不懂，只能硬着头皮回来写人机交互。发现新题可以编一编，就很开心的编上去了。然后开始写数据库，看上去踢不多，但出的又怪，要写的字又多，基本上前两道题我把两张答题卡的正反面都拉满了。然后扫了一眼信息检索，一看基础，ok复习过，一看下面，怎么没有HITS/Pagerank了，吓出一身冷汗，定睛一瞧，还是一个东西，就是没挂这个名字。然后开始哼着小曲设计。</p><p>五分钟过去了</p><p>十分钟过去了</p><p>半小时过去了，我已经慌了，怎么也设计不出来。越慌越不冷静越没办法。最后我把四个图的设计，按照我能理解的方法编上去了。看我的排名，估计还是蒙对了6成。</p><p>回家万念俱灰，吃了顿饭，感觉自己进不了面试想直接remake了。</p><p>强撑着把面试稿写完了，问了上岸佬和朋友当天的考试题，然后背会了面试稿。</p><p>第二天惊喜的发现我在面试名单上。然后进入控室，老师将面试顺序写在黑白上，前24个没我，心又全凉了。结果下午第一个面试者就是我，突然又看到了一丝希望。</p><p>13:20面试开始。首先是简短自我介绍，然后是研究计划书介绍，最后是第一志愿老师提了一个rp相关问题，第二志愿老师问我你为什么来我们lab。</p><p>我：老师，你们说明会我听了，你的video特别coooooool～</p><p>伊藤老师：？</p><p>我能怎么办，我也没研究过啊，我也很绝望啊。</p><p>出面试房间嘴里只能念叨：終わりだ。</p><p>和朋友在京都吃了最后一顿饭，坐上了回东京的のぞみ号。</p><p>8月6日放榜合格，梅雨季的阴霾一扫而空，一束光芒照了下来，告诉我，你成功了。</p><h2 id="7-まとめ"><a href="#7-まとめ" class="headerlink" title="7 まとめ"></a>7 まとめ</h2><p>在21年的上旬，我在语言学校做了一个简短的speech。</p><p>九年前的夏天，一位日本少年与来访日本的C罗有过一次直接对话。当时那个少年用带着浓厚日文口音，蹩脚的葡萄牙语向C罗表明了自己的理想：他想要像C罗一样，在足球上站上最高的舞台。因为糟糕的发音，全场发出了笑声。但C罗很严肃，他不明白为什么其他人要发笑。他向那位少年传达了一句话，那句话的日文翻译我至今还记于脑海当中。</p><p>“努力すれば必ず夢を叶う。”</p><p>毫无疑问，C罗是世界上最有资格说这句话的人之一。</p><p>令和3年的冬天，在曾经举办过世界杯的埼玉２００２足球场，山梨学院高校捧起了第九十九届全国高校足球的冠军。而九年前的那位日本少年，如今已是冠军队伍中的主力队员。</p><p>我其实很高兴能够将一些留存于我心中的小小热血分享给大家。</p><p>从没有什么梦想是100%能够实现的。我可以接受努力过了，流血过了，最后失败，而不能忍受因为没尽全力，面对困难退缩而懊恼。这也是推动着我在疫情环境尚未明朗的20年11月拖着发抖的双腿也要坐上来日本的飞机的原动力，是我一切的原点。</p><p>梦想必尽全力，只求无怨无悔。</p><p>我祝福大家，在面对绝境之时也有无可匹敌的勇气；我祝福大家，在迷茫困惑之时也有不惜一切的坚定；我祝福大家，在人生的歧路上也能走到happy end。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>在此篇经验贴的最后，向修士备考期间提供帮助的诸位致以发自内心的感谢。</p><p>排名不分先后</p><p>19/20：谭佬、黑白佬、东云佬、雪佬、林佬、Sa佬、 锁哥、saika、米酒佬、阿喵佬、乐乐佬、lucky宝、shzhzzz佬、远古的号角佬等。</p><p>21：KO宝、MO宝、邱宝、mike佬、亮宝、叶佬、wydx佬、羊驼佬、leno佬、blue佬、折佬、好人佬、夏宝、意呆、蝉佬、路佬、阿椰、aisk、ksia等。</p><p>22: 祝愿✌️宝早日上岸</p><p>衷心祝福19/20年的诸位就职/博士一切顺利，衷心期望21的各位都能拿到理想校的offer</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>附录部分为所有其他有用经验贴/网站链接，建议一个一个点来看一下。希望我的网页因此成为hub分数超高的网页！</p><p>经验贴部分：</p><p><a href="https://zhuanlan.zhihu.com/p/262935723">170210：京都大学社会情报专攻，东京工业大学情报通信专攻夏季入试修考经验分享</a></p><p><a href="https://zhuanlan.zhihu.com/p/107050529">远古的号角：京都大学大学院社会情报学专攻冬季入试验修考经验分享</a></p><p><a href="https://zhuanlan.zhihu.com/p/81328495">shzhzzz：京都大学大学院情報学研究科社会情报学专攻修考经验分享</a></p><p><a href="https://zhuanlan.zhihu.com/p/208936333">CTan：京都大学社会情报学大学院夏季入试经验分享</a></p><p><a href="https://drakscake.hatenadiary.com/entry/20190810/1565374114">院試の振り返り - けものみち</a></p><p><a href="https://chum0n.hatenablog.com/entry/2020/10/20/184108">京大大学院情報学研究科社会情報学専攻に合格するまでにしたこと - chumonのブログ</a></p><p><a href="https://huhuhuhahahahah.hateblo.jp/entry/2018/08/18/010644">文系でしたが情報系の大学院に進学します - anytime sleeping</a></p><p><a href="https://hiramekun.hatenablog.com/entry/2019/02/10/174105">京都大学大学院情報学研究科の入試情報まとめ（自分用） - ひらめの日常</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>KyotoU</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
